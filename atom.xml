<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>秋过冬漫长</title>
  
  <subtitle>没有比脚更长的路,走过去就好了</subtitle>
  <link href="https://primeluoqiu.github.io/atom.xml" rel="self"/>
  
  <link href="https://primeluoqiu.github.io/"/>
  <updated>2024-03-23T15:40:20.220Z</updated>
  <id>https://primeluoqiu.github.io/</id>
  
  <author>
    <name>LuoQiu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://primeluoqiu.github.io/2024/03/24/CSAPP/%E7%AC%AC%E4%B8%80%E7%AB%A0/1.8%20%E7%B3%BB%E7%BB%9F%E4%B9%8B%E9%97%B4%E5%88%A9%E7%94%A8%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"/>
    <id>https://primeluoqiu.github.io/2024/03/24/CSAPP/%E7%AC%AC%E4%B8%80%E7%AB%A0/1.8%20%E7%B3%BB%E7%BB%9F%E4%B9%8B%E9%97%B4%E5%88%A9%E7%94%A8%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/</id>
    <published>2024-03-24T02:51:49.636Z</published>
    <updated>2024-03-23T15:40:20.220Z</updated>
    
    <content type="html"><![CDATA[<p>实际上，现代系统经常通过网络和其他系统连接到一起，从一个单独的系统来看，网络可视为一个I&#x2F;O设备。当系统从主存复制一串字节到网络适配器时，数据流经网络到达另一台机器。相似地，系统可以读取其他机器发来的数据，并把数据复制到自己的主存。<br>![[Pasted image 20240323233843.png]]<br>随着Internet全球网络的出现，从一台主机复制信息到另一台主机已经成为计算机系统最重要的用途之一</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;实际上，现代系统经常通过网络和其他系统连接到一起，从一个单独的系统来看，网络可视为一个I&amp;#x2F;O设备。当系统从主存复制一串字节到网络适配器时，数据流经网络到达另一台机器。相似地，系统可以读取其他机器发来的数据，并把数据复制到自己的主存。&lt;br&gt;![[Pasted im</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>CSAPP Chapter1.7 硬件被谁管理啊</title>
    <link href="https://primeluoqiu.github.io/2024/03/24/CSAPP/%E7%AC%AC%E4%B8%80%E7%AB%A0/1.7%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E7%A1%AC%E4%BB%B6/"/>
    <id>https://primeluoqiu.github.io/2024/03/24/CSAPP/%E7%AC%AC%E4%B8%80%E7%AB%A0/1.7%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E7%A1%AC%E4%BB%B6/</id>
    <published>2024-03-24T02:51:49.635Z</published>
    <updated>2024-03-24T02:43:36.991Z</updated>
    
    <content type="html"><![CDATA[<p>从hello的例子可以可以看出来，当shell加载运行包括最后输出的时候，shell和hello都没有直接对硬件进行访问(包括键盘，显示器，主存或者磁盘)。取而代之的是，他们依靠操作系统提供的服务。我们可以把操作系统看成是应用程序和硬件之间插入的一层软件。所有应用程序对硬件的操作尝试都必须通过操作系统<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/24/XDgvCQG1.png"                      alt="Pasted image 20240320002837.png"                ><br>操作系统有两个基本功能，</p><ol><li>防止硬件被失控的应用程序滥用</li><li>向应用程序提供简单一致的机制来控制复杂而又通常大不相同的低级硬件设备。</li></ol><p>操作系统通过几个基本的抽象概念(<strong>进程</strong>、<strong>虚拟内存</strong>和<strong>文件</strong>)来实现这两个功能，如下图所示，文件是对I&#x2F;O设备的抽象表示，虚拟内存是对主存和磁盘I&#x2F;O设备的抽象表示，进程则是对处理器、主存和I&#x2F;O设备的抽象表示<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/24/cavhFdDj.png"                      alt="Pasted image 20240320003206.png"                ></p><h4 id="1-7-1-进程"><a href="#1-7-1-进程" class="headerlink" title="1.7.1 进程"></a>1.7.1 进程</h4><p>像hello这样的程序在现代系统上运行时，操作系统会提供一种假象，就像系统上只有这个程序在运行。程序看上去是独占地只用处理器、主存和I&#x2F;O设备。处理器看上去就像在不间断的一条接一条地执行程序中的指令，即该程序的代码和数据是系统内存中唯一的对象。这些假象是通过进程的概念来实现的，进程是计算机科学中最重要和最成功的概念之一。</p><p><strong>进程</strong>是操作系统对一个正在运行的程序的一种抽象。在一个系统上可以同时运行多个进程，而每个进程都好像在独占的使用硬件。而<strong>并发运行</strong>，则是说一个进程的指令和另一个进程的指令是交错执行的。在大多数系统中，需要运行的进程数是多于可以运行它们的CPU个数的。传统系统在一个时刻只能执行一个程序，而先进的<strong>多核</strong>处理器同时能够执行多个程序。无论是在单核还是多核系统中，一个CPU看上去都像是在并发地执行多个进程，这是通过处理器在进程间切换来实现的。操作系统实现这种操作执行的机制称为<strong>上下文交换</strong>。为了简化讨论，我们只考虑包含一个CPU的<strong>单处理器系统</strong>的情况。后面还会讨论</p><p>操作系统保持跟踪进程运行所需的所有状态信息。这种状态，也就是<strong>上下文</strong>，包括许多信息，比如PC和寄存器文件的当前值，以及主存的内容。在任何一个时刻，单处理器系统都只能执行一个进程的代码。当操作系统决定要把控制权从当前进程转移到某个新进程时，就会进行上下文切换，即保存当前进程的上下文、恢复新进程的上下文，然后将控制权传递到新进程。新进程就会从它上次停止的地方开始。那么hello程序运行场景的基本理念看下面。<br>![[<a class="link"   href="https://hansimov.gitbook.io/~gitbook/image?url=https://4154149387-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%252F-MHt_spaxGgCbp2POnfq%252F-MHzietxOnE2XCBTZHJ7%252F-MHziqrI26zhGJA9_NLL%252F01-12%2520%25E8%25BF%259B%25E7%25A8%258B%25E7%259A%2584%25E4%25B8%258A%25E4%25B8%258B%25E6%2596%2587%25E5%2588%2587%25E6%258D%25A2.png?alt=media&token=5df4420b-e3c7-46ca-8192-ba207aa49f15&width=400&dpr=3&quality=100&sign=7323c7a530eb087f04ecfa52db5f03b77529e0c73a5744a490b2389fecb6b30ehttps://hansimov.gitbook.io/~gitbook/image?url=https://4154149387-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%252F-MHt_spaxGgCbp2POnfq%252F-MHzietxOnE2XCBTZHJ7%252F-MHziqrI26zhGJA9_NLL%252F01-12%2520%25E8%25BF%259B%25E7%25A8%258B%25E7%259A%2584%25E4%25B8%258A%25E4%25B8%258B%25E6%2596%2587%25E5%2588%2587%25E6%258D%25A2.png?alt=media&token=5df4420b-e3c7-46ca-8192-ba207aa49f15&width=400&dpr=3&quality=100&sign=7323c7a530eb087f04ecfa52db5f03b77529e0c73a5744a490b2389fecb6b30e%5D%5D" >https://hansimov.gitbook.io/~gitbook/image?url=https:%2F%2F4154149387-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-legacy-files%2Fo%2Fassets%252F-MHt_spaxGgCbp2POnfq%252F-MHzietxOnE2XCBTZHJ7%252F-MHziqrI26zhGJA9_NLL%252F01-12%2520%25E8%25BF%259B%25E7%25A8%258B%25E7%259A%2584%25E4%25B8%258A%25E4%25B8%258B%25E6%2596%2587%25E5%2588%2587%25E6%258D%25A2.png%3Falt=media%26token=5df4420b-e3c7-46ca-8192-ba207aa49f15&amp;width=400&amp;dpr=3&amp;quality=100&amp;sign=7323c7a530eb087f04ecfa52db5f03b77529e0c73a5744a490b2389fecb6b30ehttps://hansimov.gitbook.io/~gitbook/image?url=https:%2F%2F4154149387-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-legacy-files%2Fo%2Fassets%252F-MHt_spaxGgCbp2POnfq%252F-MHzietxOnE2XCBTZHJ7%252F-MHziqrI26zhGJA9_NLL%252F01-12%2520%25E8%25BF%259B%25E7%25A8%258B%25E7%259A%2584%25E4%25B8%258A%25E4%25B8%258B%25E6%2596%2587%25E5%2588%2587%25E6%258D%25A2.png%3Falt=media%26token=5df4420b-e3c7-46ca-8192-ba207aa49f15&amp;width=400&amp;dpr=3&amp;quality=100&amp;sign=7323c7a530eb087f04ecfa52db5f03b77529e0c73a5744a490b2389fecb6b30e]] <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br>实例当中有两个并发的进程：shell和hello。最开始，只有shell进程在运行，也就是等待命令行上的输入。当我们让他运行hello程序时，shell通过一个专门的函数，也就是系统调用，来执行我们的请求，系统调用会将控制权传递给操作系统。操作系统保存shell进程的上下文，创建一个新的hello进程及其上下文，并将控制权传回给它，shell进程会继续等待下一个命令行输入。</p><p>如图所示，从一个进程到另一个进程的转换是由操作系统<strong>内核(kernel)</strong> 管理的。内核是操作系统代码常驻主存的部分。当应用程序需要操作系统的某些操作时，比如读写文件，它就执行一条特殊的<strong>系统调用(system call)</strong> 指令，将控制权传递给内核。然后内核执行被请求的操作并返回应用程序。注意，内核不是一个独立的进程。相反，它是系统管理全部进程所用代码和数据结构的集合。</p><p>实现进程这个抽象概念需要低级硬件和操作系统软件之间的紧密合作。</p><h4 id="1-7-2-线程"><a href="#1-7-2-线程" class="headerlink" title="1.7.2 线程"></a>1.7.2 线程</h4><p>尽管通常我们认为一个进程只有单一的控制流，但是在现在系统中，一个进程实际上可以由多个称为<strong>线程</strong>的执行单元组成，每个线程都运行在进程的上下文中，并共享的代码和全局数据。由于网络服务器中对并行处理的需求，线程称为越来越重要的编程模型，因为多线程之间比多进程之间更容易共享数据，也因为线程一般来说都比进程更高效。当有多处理器可用的时候，多线程也是一种使得程序可以运行得更快的方法，我们将在后面讨论</p><h4 id="1-7-3-虚拟内存"><a href="#1-7-3-虚拟内存" class="headerlink" title="1.7.3 虚拟内存"></a>1.7.3 虚拟内存</h4><p>虚拟内存是一个抽象概念，它为每一个进程提供了一个假象，即每个进程都在独占地使用主存。每个进程看到的内存都是一致的，称为虚拟地址空间。下图所示的Linux进程的虚拟地址空间(其他Unix系统的设计也与此类似)。在Linux中，地址空间最上面的区域是保留给操作系统中的代码和数据的，这对所有进程来说都一样。地址空间的底部区域存放用户进程定义的代码和数据。图中的地址是从下往上增大的。<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/24/s6u5UnTl.png"                      alt="Pasted image 20240322170742.png"                ><br>每个进程看到的虚拟地址空间由大量准确定义的区构成，每个区都有专门的功能。先做简单的了解，逐步向上介绍</p><ul><li><strong>程序代码和数据</strong>：对所有的进程来说，代码是从同一固定地址开始，紧接着的是C全局变量相对应的数据位置。代码和数据区是直接按照可执行目标文件的内容初始化的，在示例中就是可执行文件hello。</li><li><strong>堆</strong>：代码和数据区后紧随的是运行时堆。代码和数据区在进程一开始运行时就被指定了大小，与此不同，当调用像malloc和free这样的C标准库函数的时候，堆可以在运行时动态地扩展和收缩。</li><li><strong>共享库</strong>：大约在地址空间的中间部分是一块用来存放像C标准库和数学库这样的共享库的代码和数据的区域。共享库的概念非常强大，也相当难懂。</li><li><strong>栈</strong>：位于用户虚拟地址空间顶部的是<strong>用户栈</strong>，编译器用它来实现函数调用。和堆一样，用户栈在程序执行期间可以动态地扩展和收缩。特别的，每次我们调用一个函数时，栈就会增长；从一个函数返回时，栈就会收缩。</li><li><strong>内核虚拟内存</strong>：地址空间顶部的区域是为内核保留的。不允许应用程序读写这个区域的内容或者直接调用内核代码定义的函数。相反，它们必须调用内核来执行这些操作。</li></ul><p>虚拟内存的运作需要硬件和操作系统软件之间精密复杂的交互，包括对处理器生成的每个地址的硬件翻译。基本思想是把一个进程虚拟内存存储在磁盘上，然后用主存作为磁盘的高速缓存。</p><h4 id="1-7-4-文件"><a href="#1-7-4-文件" class="headerlink" title="1.7.4 文件"></a>1.7.4 文件</h4><p><strong>文件</strong>就是字节序列，仅此而已。每个I&#x2F;O设备，包括磁盘、键盘、显示器甚至网络，都可以看成是文件。系统中的所有输入输出都是通过使用一小组称为Unix I&#x2F;O的系统调用读写文件来实现的。</p><p>文件这个简单而精致的概念是十分强大的，因为它向应用程序提供了一个统一的视图，来看待系统中可能含有的所有各式各样的I&#x2F;O设备。例如，处理磁盘文件内容的应用程序员可以非常幸福，因为他们无需了解具体的磁盘技术。进一步说，同一个程序可以在使用不同磁盘技术的不同系统上运行。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;从hello的例子可以可以看出来，当shell加载运行包括最后输出的时候，shell和hello都没有直接对硬件进行访问(包括键盘，显示器，主存或者磁盘)。取而代之的是，他们依靠操作系统提供的服务。我们可以把操作系统看成是应用程序和硬件之间插入的一层软件。所有应用程序对硬件</summary>
      
    
    
    
    <category term="CSAPP" scheme="https://primeluoqiu.github.io/categories/CSAPP/"/>
    
    
  </entry>
  
  <entry>
    <title>CSAPP Chapter1.6 存储设备形成也是有结构的</title>
    <link href="https://primeluoqiu.github.io/2024/03/24/CSAPP/%E7%AC%AC%E4%B8%80%E7%AB%A0/1.6%E5%AD%98%E5%82%A8%E8%AE%BE%E5%A4%87%E5%BD%A2%E6%88%90%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/"/>
    <id>https://primeluoqiu.github.io/2024/03/24/CSAPP/%E7%AC%AC%E4%B8%80%E7%AB%A0/1.6%E5%AD%98%E5%82%A8%E8%AE%BE%E5%A4%87%E5%BD%A2%E6%88%90%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/</id>
    <published>2024-03-24T02:51:49.634Z</published>
    <updated>2024-03-24T02:40:48.774Z</updated>
    
    <content type="html"><![CDATA[<p>也就是说，在处理器中和一个较大较慢的设备(例如主存)之间插入要给更小更快的存储设备(例如高缓)的想法已经成为一个普遍的观念。实际上，每个计算机中的存储设备都被组织成了一个存储器层次结构，如图所示<br>![[<a class="link"   href="https://hansimov.gitbook.io/~gitbook/image?url=https://4154149387-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%252F-MHt_spaxGgCbp2POnfq%252F-MHzhX2vrq6mFP3tN9EU%252F-MHzi1Edm9hUsnQdAkkL%252F01-09%2520%25E4%25B8%2580%25E4%25B8%25AA%25E5%25AD%2598%25E5%2582%25A8%25E5%2599%25A8%25E5%25B1%2582%25E6%25AC%25A1%25E7%25BB%2593%25E6%259E%2584%25E7%259A%2584%25E7%25A4%25BA%25E4%25BE%258B.png?alt=media&token=afb8208e-17dc-475f-9f61-acf0bd0ca891&width=400&dpr=3&quality=100&sign=17fc4e7af9f4033010d24045648add7168e149dc6885e9e1a1730033b06fd7f2%5D%5D" >https://hansimov.gitbook.io/~gitbook/image?url=https:%2F%2F4154149387-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-legacy-files%2Fo%2Fassets%252F-MHt_spaxGgCbp2POnfq%252F-MHzhX2vrq6mFP3tN9EU%252F-MHzi1Edm9hUsnQdAkkL%252F01-09%2520%25E4%25B8%2580%25E4%25B8%25AA%25E5%25AD%2598%25E5%2582%25A8%25E5%2599%25A8%25E5%25B1%2582%25E6%25AC%25A1%25E7%25BB%2593%25E6%259E%2584%25E7%259A%2584%25E7%25A4%25BA%25E4%25BE%258B.png%3Falt=media%26token=afb8208e-17dc-475f-9f61-acf0bd0ca891&amp;width=400&amp;dpr=3&amp;quality=100&amp;sign=17fc4e7af9f4033010d24045648add7168e149dc6885e9e1a1730033b06fd7f2]] <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br>在这个层次结构中，从上到下，设备之间的访问速度越来越慢，容量越来越大，并且每字节的造价也越来越低。寄存器文件在层次结构中位于最顶层，也就是第0级或者L0，主存在第4存…</p><p>存储器层次结构的主要思想是上一层的存储器作为低一层存储器的高速缓存。因此寄存器文件就是L1的高速缓存，L1是L2的高速缓存..在某些具有分布式文件系统的网络系统中，本地磁盘就是存储在其他系统中磁盘上的数据的高速缓存。正如可以运用不同的高速缓存的知识来提高程序性能一样，程序员同样可以利用对整个存储器层次结构的理解来提高程序性能。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;也就是说，在处理器中和一个较大较慢的设备(例如主存)之间插入要给更小更快的存储设备(例如高缓)的想法已经成为一个普遍的观念。实际上，每个计算机中的存储设备都被组织成了一个存储器层次结构，如图所示&lt;br&gt;![[&lt;a class=&quot;link&quot;   href=&quot;https://h</summary>
      
    
    
    
    <category term="CSAPP" scheme="https://primeluoqiu.github.io/categories/CSAPP/"/>
    
    
  </entry>
  
  <entry>
    <title>CSAPP Chapter1.5 多来点高速缓存嘛</title>
    <link href="https://primeluoqiu.github.io/2024/03/24/CSAPP/%E7%AC%AC%E4%B8%80%E7%AB%A0/1.5%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E8%87%B3%E5%85%B3%E9%87%8D%E8%A6%81/"/>
    <id>https://primeluoqiu.github.io/2024/03/24/CSAPP/%E7%AC%AC%E4%B8%80%E7%AB%A0/1.5%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E8%87%B3%E5%85%B3%E9%87%8D%E8%A6%81/</id>
    <published>2024-03-24T02:51:49.633Z</published>
    <updated>2024-03-24T02:40:19.983Z</updated>
    
    <content type="html"><![CDATA[<p>上述简单的运行过程中，我们不难发现系统花费了大量的时间把信息从一个地方挪到另一个地方。例如hello最初放在磁盘上，当程序加载的时候，被复制到主存，最后从主存上复制到显示设备。复制总是需要随时间的。这些复制就是开销，所以系统设计者的一个主要目标就是使这些复制操作尽可能快的完成。</p><p>根据机械原理，较大的存储设备要比比较小的存储设备运行的慢，而快速设备的造价远高于同类的低速设备，比如说，一个典型系统上的磁盘驱动器可能比主存大1000倍，但是对处理器而言，从磁盘驱动器上读取一个字的时间开销要比从主存中的开销大1000万倍。</p><p>类似得，一个典型的寄存器文件只存储几百byte的信息，而主存里面可以存放几十亿字节。然而，处理器从寄存器文件中读数据比从主存中读取几乎要快100倍，而且随着半导体技术的进步，处理器和主存之间的差距还在增大。加快处理器的运行速度比加快主存的运行速度要容易和便宜得多。针对这种处理器和主存之间的差异，系统设计者就采用了更小更快的存储设备，称为<strong>高速缓存存储器</strong>(cache memory, 简称cache或高速缓存)，作为暂时的集结区域，存放处理器近期可能需要的信息。<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/24/Z51UmPNz.png"                      alt="Pasted image 20240318151011.png"                ><br>这是一个典型系统中的高速缓存存储器，位于CPU上的L1高速缓存的荣富良可以达到数万字节。访问速度几乎和访问寄存器文件一样快。一个容量为数十万到百万字节的更大的L2告诉换曾黁通过一条特殊的总线连接到CPU。</p><p>进程访问L2高速缓存的时间要比访问L1告诉换从的时间长5倍，但是这仍然比访问主存的时间快5-10倍。L1和L2告诉换从使用一种叫做<strong>静态随机访问存储器</strong>的硬件技术实现的。比较新的，处理能力更强大的系统甚至有三级高速缓存：L1、L2、L3.系统可以获得一个很大的存储器，同时访问速度也很快，原因是利用了高速缓存的局部性原理，即<strong>程序具有访问局部区域里的数据和代码的趋势</strong>。通过让高速缓存里存放可能经常访问的数据，大部分的内存操作都能在快速的高速缓存中完成。<br>![[Pasted image 20240318151738.png]]</p><p>本书得出的重要结论之一就是，意识到高速缓存存储器存在的应用程序员能够利用高速缓存将程序的的性能提升一个数量级。</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;上述简单的运行过程中，我们不难发现系统花费了大量的时间把信息从一个地方挪到另一个地方。例如hello最初放在磁盘上，当程序加载的时候，被复制到主存，最后从主存上复制到显示设备。复制总是需要随时间的。这些复制就是开销，所以系统设计者的一个主要目标就是使这些复制操作尽可能快的完</summary>
      
    
    
    
    <category term="CSAPP" scheme="https://primeluoqiu.github.io/categories/CSAPP/"/>
    
    
  </entry>
  
  <entry>
    <title>CSAPP Chapter1.3 处理器是干嘛的</title>
    <link href="https://primeluoqiu.github.io/2024/03/24/CSAPP/%E7%AC%AC%E4%B8%80%E7%AB%A0/1.4%E5%A4%84%E7%90%86%E5%99%A8%E8%AF%BB%E5%B9%B6%E8%A7%A3%E9%87%8A%E5%82%A8%E5%AD%98%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E6%8C%87%E4%BB%A4/"/>
    <id>https://primeluoqiu.github.io/2024/03/24/CSAPP/%E7%AC%AC%E4%B8%80%E7%AB%A0/1.4%E5%A4%84%E7%90%86%E5%99%A8%E8%AF%BB%E5%B9%B6%E8%A7%A3%E9%87%8A%E5%82%A8%E5%AD%98%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E6%8C%87%E4%BB%A4/</id>
    <published>2024-03-24T02:51:49.632Z</published>
    <updated>2024-03-24T02:39:50.330Z</updated>
    
    <content type="html"><![CDATA[<p>在我们创建完hello的可执行文件之后，用shell运行如下</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">linux &gt; ./hello</span><br><span class="line">hello, world</span><br><span class="line">linux &gt;</span><br></pre></td></tr></table></figure></div><p>shell是一个命令行解释器，它输出一个提示符，然后等待一个命令行，执行这个命令。如果命令行第一个单词不是一个内置的指令，那么它就会假设这是一个可执行文件的名字，它将加载并运行这个文件。此例中，加载运行了hello，然后等待程序终止，输出消息，然后终止。然后输出一个提示符，等待下一个输入。</p><h3 id="1-4-1-系统的硬件组成"><a href="#1-4-1-系统的硬件组成" class="headerlink" title="1.4.1 系统的硬件组成"></a>1.4.1 系统的硬件组成</h3><h4 id="1-总线"><a href="#1-总线" class="headerlink" title="1.总线"></a>1.总线</h4><p>也就贯穿整个系统的一组电子管道。携带信息字节并在各个部件间传递。通常总线被设计成传送定长的字节块，也就是字。字中的字节数（即字长）是一个基本的系统参数，各个系统中都不尽相同。现在的的大多数机器字长是4或8字节32&#x2F;64位。</p><h4 id="2-I-O设备"><a href="#2-I-O设备" class="headerlink" title="2.I&#x2F;O设备"></a>2.I&#x2F;O设备</h4><p>这是系统和外部世界的联系通道。示例系统包括四个I&#x2F;O设备：作为用户输入的键盘和鼠标，作为用户输出的显示器，以及用于长期存储数据和程序的磁盘驱动器。最开始的hello就存放在磁盘上。</p><p>每个I&#x2F;O都通过以一个<strong>控制器或适配器</strong>与I&#x2F;O总线相连。控制器和适配器之间的的区别而在于他们的<strong>封装方式</strong>。控制器是I&#x2F;O设备本身或者系统的主印制电路板(主板)上的芯片组。而适配器是一块插在主板插槽上的卡。这些设备的功能都是在I&#x2F;O总线和I&#x2F;O设备之间传递信息·<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/24/CLnPwRdz.png"                      alt="Pasted image 20240315143111.png"                ></p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALU:算数/逻辑单元 PC：程序计数器 USB：通用串行总线</span><br></pre></td></tr></table></figure></div><h4 id="3-主存"><a href="#3-主存" class="headerlink" title="3.主存"></a>3.主存</h4><p><strong>主存</strong>是一个临时存储设备，在处理器执行程序时，用来存放程序和程序处理的数据。从物理上来说，主存是由一组<strong>动态随机存储器(DRAM)</strong> 芯片组成的。从逻辑上来说，存储器是一个线性的字节数组，每个字节都有其唯一的地址(数组索引)，这些地址是从零开始的。一般来说，组成程序的每条机器指令都由不同数量的字节构成。一般来说，组成程序的每条机器指令都有不同数量的字节构成。与C程序变量相对应的数据项大小是根据类型变化的。</p><h4 id="4-处理器"><a href="#4-处理器" class="headerlink" title="4.处理器"></a>4.处理器</h4><p>中央处理单元(CPU),简称<strong>处理器</strong>，是解释(或执行)存储在主存中指令的引擎。处理器的核心是一个大小为一个字的存储设备(或<strong>寄存器</strong>) ，称为<strong>程序计数器&#x2F;指令计数器</strong>(PC)。在任何时刻，PC都指向主存中某条机器语言指令(即含有该条指令的地址)</p><p>从系统通电开始到断电，处理器一直在不断地执行程序计数器指向的指令，再更新程序计数器，使其指向下一条指令。处理器看上去是按照一个非常简单的指令执行模型来操作的，这个模型是由指令集架构(Arm, x86,)决定的。<strong>在这个模型中，指令按照严格的顺序执行，而执行一条指令包含执行一系列的步骤。处理器从程序计数器指向的内存处读取指令，解释指令中的位，执行该指令指示的简单操作，然后更新PC，使其指向下一条指令，而这条指令并不一定和在内存中刚刚执行的指令相邻。</strong></p><p>这样的简单操作并不多，它们围绕着主存、寄存器文件和算数&#x2F;逻辑单元进行。寄存器文件是个小的存储设备，由一些单个字长的寄存器组成，每个寄存器都有唯一的名字。ALU计算新的数据和地址值。下面是一些简单操作的例子，CPU在指令的要求下可能会执行这些操作</p><ul><li>加载：从主存复制一个字节或者一个字到寄存器，以覆盖寄存器原来的内容。</li><li>存储：从寄存器复制一个字节或者一个字到主存的某个位置，以覆盖这个位置上原有的内容</li><li>操作：把两个寄存器的内容复制到ALU，ALU对这两个字做算术运算，并将结果存放到一个寄存器中，以覆盖该寄存器中原来的内容</li><li>跳转：从指令本身中抽取一个字，并将这个字复制到PC中，以覆盖PC中原来的值</li></ul><p>处理器看上去是它的指令集架构的简单实现，但是实际上现代处理器使用了非常复杂的机制来加速程序的执行。因此，我们将处理器的指令集架构和处理器的微体系结构区分开来：指令集架构描述的是每条机器代码指令的效果；而微体系结构描述的是处理器实际上是如何实现的。</p><h3 id="1-4-2运行Hello程序"><a href="#1-4-2运行Hello程序" class="headerlink" title="1.4.2运行Hello程序"></a>1.4.2运行Hello程序</h3><p>目前先暂时省略一些细节。</p><p>起初，shell程序执行它的指令，等待我们输入一个命令。当我们在键盘上输入字符串”.&#x2F;hello”后，shell程序将字符逐一读入寄存器，再把它存放到内存中。如下图所示<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/24/UPG9V8JH.png"                      alt="Pasted image 20240316001811.png"                ></p><p>当我们在键盘上敲回车键之后，shell程序就知道我们已经结束了命令的输入，然后shell执行一系列指令来加载可执行的hello文件，这些指令将hello目标文件中的代码和数据从磁盘复制到主存。数据包括最后会被输出的字符串”hello, world\n”</p><p>利用直接存储器存取(DMA)技术，数据可以不通过处理器而直接从磁盘到达主存。这个步骤如下图所示<br>![[<a class="link"   href="https://hansimov.gitbook.io/~gitbook/image?url=https://4154149387-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%252F-MHt_spaxGgCbp2POnfq%252F-MHzfLHp5XFUFTsUJAKx%252F-MHzfN_gwQJSG2YnC5Gk%252F01-06%2520%25E4%25BB%258E%25E7%25A3%2581%25E7%259B%2598%25E5%258A%25A0%25E8%25BD%25BD%25E5%258F%25AF%25E6%2589%25A7%25E8%25A1%258C%25E6%2596%2587%25E4%25BB%25B6%25E5%2588%25B0%25E4%25B8%25BB%25E5%25AD%2598.png?alt=media&token=9a49507e-f20d-4af8-b277-bebf57cc597f&width=400&dpr=3&quality=100&sign=74b6cf3ac9a458f0c5b3b6cbc5920a9cd3dcc59d6250e0badd63c26859b486f3%5D%5D" >https://hansimov.gitbook.io/~gitbook/image?url=https:%2F%2F4154149387-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-legacy-files%2Fo%2Fassets%252F-MHt_spaxGgCbp2POnfq%252F-MHzfLHp5XFUFTsUJAKx%252F-MHzfN_gwQJSG2YnC5Gk%252F01-06%2520%25E4%25BB%258E%25E7%25A3%2581%25E7%259B%2598%25E5%258A%25A0%25E8%25BD%25BD%25E5%258F%25AF%25E6%2589%25A7%25E8%25A1%258C%25E6%2596%2587%25E4%25BB%25B6%25E5%2588%25B0%25E4%25B8%25BB%25E5%25AD%2598.png%3Falt=media%26token=9a49507e-f20d-4af8-b277-bebf57cc597f&amp;width=400&amp;dpr=3&amp;quality=100&amp;sign=74b6cf3ac9a458f0c5b3b6cbc5920a9cd3dcc59d6250e0badd63c26859b486f3]] <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br>一旦目标文件hello中的代码和数据被加载到主存，处理器就开始执行hello程序的main程序中的机器语言指令。这些指令将”Hello,world\n”字符串中的字节从主存复制到寄存器文件，再从寄存器文件中复制到显示设备，最终显示在屏幕上。步骤如下所示<br>![[<a class="link"   href="https://hansimov.gitbook.io/~gitbook/image?url=https://4154149387-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%252F-MHt_spaxGgCbp2POnfq%252F-MHzfVZwd5iIwJfDkOPj%252F-MHzffvOB90toXVTON5G%252F01-07%2520%25E5%25B0%2586%25E8%25BE%2593%25E5%2587%25BA%25E5%25AD%2597%25E7%25AC%25A6%25E4%25B8%25B2%25E4%25BB%258E%25E5%25AD%2598%25E5%2582%25A8%25E5%2599%25A8%25E5%2586%2599%25E5%2588%25B0%25E6%2598%25BE%25E7%25A4%25BA%25E5%2599%25A8.png?alt=media&token=d0480c36-9640-4159-bc71-8f5db262a6ba&width=400&dpr=3&quality=100&sign=a45f19ed618ab752f842b7f269e3b6411ec8fa6f81166c73190f0156510d0c4a%5D%5D" >https://hansimov.gitbook.io/~gitbook/image?url=https:%2F%2F4154149387-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-legacy-files%2Fo%2Fassets%252F-MHt_spaxGgCbp2POnfq%252F-MHzfVZwd5iIwJfDkOPj%252F-MHzffvOB90toXVTON5G%252F01-07%2520%25E5%25B0%2586%25E8%25BE%2593%25E5%2587%25BA%25E5%25AD%2597%25E7%25AC%25A6%25E4%25B8%25B2%25E4%25BB%258E%25E5%25AD%2598%25E5%2582%25A8%25E5%2599%25A8%25E5%2586%2599%25E5%2588%25B0%25E6%2598%25BE%25E7%25A4%25BA%25E5%2599%25A8.png%3Falt=media%26token=d0480c36-9640-4159-bc71-8f5db262a6ba&amp;width=400&amp;dpr=3&amp;quality=100&amp;sign=a45f19ed618ab752f842b7f269e3b6411ec8fa6f81166c73190f0156510d0c4a]] <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在我们创建完hello的可执行文件之后，用shell运行如下&lt;/p&gt;
&lt;div class=&quot;highlight-container&quot; data-rel=&quot;Plaintext&quot;&gt;&lt;figure class=&quot;iseeu highlight plaintext&quot;&gt;&lt;table</summary>
      
    
    
    
    <category term="CSAPP" scheme="https://primeluoqiu.github.io/categories/CSAPP/"/>
    
    
  </entry>
  
  <entry>
    <title>CSAPP Chapter1.3 了解编译系统如何工作是大有益处的</title>
    <link href="https://primeluoqiu.github.io/2024/03/24/CSAPP/%E7%AC%AC%E4%B8%80%E7%AB%A0/1.3%E4%BA%86%E8%A7%A3%E7%BC%96%E8%AF%91%E7%B3%BB%E7%BB%9F%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E6%98%AF%E5%A4%A7%E6%9C%89%E7%9B%8A%E5%A4%84%E7%9A%84/"/>
    <id>https://primeluoqiu.github.io/2024/03/24/CSAPP/%E7%AC%AC%E4%B8%80%E7%AB%A0/1.3%E4%BA%86%E8%A7%A3%E7%BC%96%E8%AF%91%E7%B3%BB%E7%BB%9F%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E6%98%AF%E5%A4%A7%E6%9C%89%E7%9B%8A%E5%A4%84%E7%9A%84/</id>
    <published>2024-03-24T02:51:49.631Z</published>
    <updated>2024-03-24T02:25:47.980Z</updated>
    
    <content type="html"><![CDATA[<p>益处大致有三点</p><ul><li><strong>优化程序性能</strong>。尽管已经无需为了写出高效代码而了解编译器的内部工作。不过为了在C中做出更好对的编码选择，我们确实需要了解一些机器代码以及编译器将不同的C转化成机器代码的方式。例如在C语言程序中有<code>if-else</code>和<code>switch</code>两种语句。那么这两种哪个更高效呢，while和for之间哪个更有效呢？这些都是可以得到了解的</li><li><strong>理解链接时出现的错误</strong>。根据经验来讲，一些令人困扰的程序错误往往都与链接器操作有关，尤其是试图构建大型的软件系统时。例如链接器报告说无法解析一个引用，这是什么意思？静态变量和全局变量的区别是什么等一系列问题</li><li><strong>避免安全漏洞</strong>。多年来，缓冲区溢出错误时造成大多数网络和Internet服务器上安全漏洞的主要原因。存在这些错误是因为很少有程序员能够理解需要限制从不受信任的源接受数据的数量和格式。 学习安全编程的第一步就是理解数据和控制信息存储在程序栈上的方式会引起的后果。等</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;益处大致有三点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;优化程序性能&lt;/strong&gt;。尽管已经无需为了写出高效代码而了解编译器的内部工作。不过为了在C中做出更好对的编码选择，我们确实需要了解一些机器代码以及编译器将不同的C转化成机器代码的方式。例如在C语言程序中有&lt;co</summary>
      
    
    
    
    <category term="CSAPP" scheme="https://primeluoqiu.github.io/categories/CSAPP/"/>
    
    
  </entry>
  
  <entry>
    <title>CSAPP Chapter1.2 程序被其他程序翻译成不同的格式</title>
    <link href="https://primeluoqiu.github.io/2024/03/24/CSAPP/%E7%AC%AC%E4%B8%80%E7%AB%A0/1.2%E7%A8%8B%E5%BA%8F%E8%A2%AB%E5%85%B6%E4%BB%96%E7%A8%8B%E5%BA%8F%E7%BF%BB%E8%AF%91%E6%88%90%E4%B8%8D%E5%90%8C%E7%9A%84%E6%A0%BC%E5%BC%8F/"/>
    <id>https://primeluoqiu.github.io/2024/03/24/CSAPP/%E7%AC%AC%E4%B8%80%E7%AB%A0/1.2%E7%A8%8B%E5%BA%8F%E8%A2%AB%E5%85%B6%E4%BB%96%E7%A8%8B%E5%BA%8F%E7%BF%BB%E8%AF%91%E6%88%90%E4%B8%8D%E5%90%8C%E7%9A%84%E6%A0%BC%E5%BC%8F/</id>
    <published>2024-03-24T02:51:49.630Z</published>
    <updated>2024-03-24T02:36:29.315Z</updated>
    
    <content type="html"><![CDATA[<p>为了在系统上运行Hello.c程序，每条C语句必须被其他程序转化成一系列的低级机器语言指令。然后这些指令按照一种称为可执行程序的格式打好包，并以二进制磁盘文件的形式存放起来。目标程序也成为可执行目标文件</p><p>高级语言 -&gt; 低级指令 -&gt; 指令打包并以二进制文件存放。</p><p>![[<a class="link"   href="https://hansimov.gitbook.io/~gitbook/image?url=https://4154149387-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%252F-MHt_spaxGgCbp2POnfq%252F-MHzZfEIY91yIzOD0Rce%252F-MHzZpZI-gs8CNcwHIyv%252F01-03%2520compilation%2520systems.png?alt=media&token=91ca688e-1cfc-4ec6-8b99-d52e672bbac7&width=400&dpr=3&quality=100&sign=ad2978e04a286ea0e07b7bbfb5d2a96b78a69a9b23614f1df17e662f4615f344%5D%5D" >https://hansimov.gitbook.io/~gitbook/image?url=https:%2F%2F4154149387-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-legacy-files%2Fo%2Fassets%252F-MHt_spaxGgCbp2POnfq%252F-MHzZfEIY91yIzOD0Rce%252F-MHzZpZI-gs8CNcwHIyv%252F01-03%2520compilation%2520systems.png%3Falt=media%26token=91ca688e-1cfc-4ec6-8b99-d52e672bbac7&amp;width=400&amp;dpr=3&amp;quality=100&amp;sign=ad2978e04a286ea0e07b7bbfb5d2a96b78a69a9b23614f1df17e662f4615f344]] <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><ul><li>预处理阶段，通过以字符#开头的命令，修改原始程序。如<code>#include&lt;iostream&gt;</code>命令就是告诉预处理器读取系统头文件<code>stdio.h</code>的内容，然后直接插入程序文本中。然后得到了另一个C程序，通常以.i作为文件扩展名。</li><li>编译阶段：通过编译器将文本文件翻译成hello.s，也就是汇编语言程序，该程序包含<code>main</code>的定义<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">main:</span><br><span class="line">    subq $8, %rsp</span><br><span class="line">    movl $.LC0, %edi</span><br><span class="line">    call puts</span><br><span class="line">    movl $0, %eax</span><br><span class="line">    addq $8, %rsp</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure></div></li><li>2-7行每条都以一种文本格式描述了一条低级语言指令。(汇编语言为所有不同高级语言的不同编译器提供了通用的输出语言)</li><li>汇编阶段；通过汇编器将hello.s翻译成机器语言指令。把这些指令打包成可重定位目标程序。并保存到hello.o中(这是一个二进制文件)，里面包含的是<code>main</code>的指令代码。</li><li>链接阶段：hello程序调用了printf函数，是标准C库中的一个函数。函数存在于一个名为<code>printf.o</code>的单独的预编译好了的目标文件中，而这个文件必须以某种方式合并到hello.c的程序中，链接器负责合并，结果得到hello文件，是一个可执行文件。可以被加载到内存中，由系统执行。<br>也就是说，一个C程序都是先从预处理阶段开始的，先读取头文件然后插入程序中，然后通过编译器翻译成汇编语言，再通过汇编器翻译成机器语言指令生成hello.o，接下来引入在hello中调用的printf函数，而该函数存在于一个单独编译好的目标文件<code>printf.o</code>中，然后连接器负责合并这两个.o的目标文件，然后最后得出一个可执行文件。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;为了在系统上运行Hello.c程序，每条C语句必须被其他程序转化成一系列的低级机器语言指令。然后这些指令按照一种称为可执行程序的格式打好包，并以二进制磁盘文件的形式存放起来。目标程序也成为可执行目标文件&lt;/p&gt;
&lt;p&gt;高级语言 -&amp;gt; 低级指令 -&amp;gt; 指令打包并以</summary>
      
    
    
    
    <category term="CSAPP" scheme="https://primeluoqiu.github.io/categories/CSAPP/"/>
    
    
  </entry>
  
  <entry>
    <title>CSAPP Chapter1.1 信息就是位+上下文</title>
    <link href="https://primeluoqiu.github.io/2024/03/24/CSAPP/%E7%AC%AC%E4%B8%80%E7%AB%A0/1.1%E4%BF%A1%E6%81%AF%E5%B0%B1%E6%98%AF%E4%BD%8D+%E4%B8%8A%E4%B8%8B%E6%96%87/"/>
    <id>https://primeluoqiu.github.io/2024/03/24/CSAPP/%E7%AC%AC%E4%B8%80%E7%AB%A0/1.1%E4%BF%A1%E6%81%AF%E5%B0%B1%E6%98%AF%E4%BD%8D+%E4%B8%8A%E4%B8%8B%E6%96%87/</id>
    <published>2024-03-24T02:51:49.625Z</published>
    <updated>2024-03-24T02:25:25.510Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一节：信息就是位＋上下文"><a href="#第一节：信息就是位＋上下文" class="headerlink" title="第一节：信息就是位＋上下文"></a>第一节：信息就是位＋上下文</h2><p>我们在创建第一个hello.c的时候，这些文件都是由ASCII码组成的，也就是用一个唯一的单字节大小的值来表示每个字符。而只由ASCII字符构成的文件成为<strong>文本文件</strong>，其他的文件被称为二进制文件。</p><p>这件事说明了一个基本思想：系统中所有的信息都是由一串bit表示的。区分不同数据对象的唯一方法是我们读到这些数据对象时的上下文。例如在不同的上下文中，一个同样的字节序列可能表示一个整数、浮点数、字符串、机器指令。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;第一节：信息就是位＋上下文&quot;&gt;&lt;a href=&quot;#第一节：信息就是位＋上下文&quot; class=&quot;headerlink&quot; title=&quot;第一节：信息就是位＋上下文&quot;&gt;&lt;/a&gt;第一节：信息就是位＋上下文&lt;/h2&gt;&lt;p&gt;我们在创建第一个hello.c的时候，这些文件都是由</summary>
      
    
    
    
    <category term="CSAPP" scheme="https://primeluoqiu.github.io/categories/CSAPP/"/>
    
    
  </entry>
  
  <entry>
    <title>模拟堆</title>
    <link href="https://primeluoqiu.github.io/2024/03/23/Algorithm/duiyouhua/"/>
    <id>https://primeluoqiu.github.io/2024/03/23/Algorithm/duiyouhua/</id>
    <published>2024-03-23T14:13:09.233Z</published>
    <updated>2024-03-23T14:14:47.893Z</updated>
    
    <content type="html"><![CDATA[<h3 id="模拟堆"><a href="#模拟堆" class="headerlink" title="模拟堆"></a>模拟堆</h3><p>接下来看模拟堆，模拟堆比起之前就是多了两个数组，这两个数组属于互为反函数的类型。例如 <code>hp[k] = j</code>那么<code>ph[j] = k</code>，一个是对应着在堆里的下标，另一个对应的是下标对应的值。 那么对应的，在进行交换的时候，就不能只考虑值之间的交换了，就还得考虑数组之间的交换。这个时候，就需要一个全新的函数了</p><p>因为题目中要考虑第k个数，那么就需要两个数组来存储第k个数是什么<br>ph[k]存的是第k个插入的数在堆里的下标是什么,还需要一个hp[k],用来存的是堆的某个点是第几个插入的点。</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap_head</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="built_in">swap</span>(ph[hp[a]], ph[hp[b]]);  </span><br><span class="line">    <span class="built_in">swap</span>(hp[a], hp[b]);  </span><br><span class="line">    <span class="built_in">swap</span>(a, b);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>然后就是把所有的<code>swap</code>函数进行更换为堆里面特有的<code>swap</code>。<br>这个方法不常用，但是djikstra堆优化是常用的，所以要了解一下</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, a, b;</span><br><span class="line"><span class="type">int</span> h[N], cnt, ph[N], hp[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heap_swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">swap</span>(ph[hp[a]], ph[hp[b]]);</span><br><span class="line">    <span class="built_in">swap</span>(hp[a], hp[b]);</span><br><span class="line">    <span class="built_in">swap</span>(h[a], h[b]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = u;</span><br><span class="line">    <span class="keyword">if</span>(u * <span class="number">2</span> &lt;= cnt &amp;&amp; h[u * <span class="number">2</span>] &lt; h[t]) t = u * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(u * <span class="number">2</span> + <span class="number">1</span> &lt;= cnt &amp;&amp; h[u * <span class="number">2</span> + <span class="number">1</span>] &lt; h[t]) t = u * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(u != t)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">heap_swap</span>(u, t);</span><br><span class="line">        <span class="built_in">down</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(u / <span class="number">2</span> &amp;&amp; h[u / <span class="number">2</span>] &gt; h[u])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">heap_swap</span>(u, u / <span class="number">2</span>);</span><br><span class="line">        u &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(n --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> op[<span class="number">10</span>];</span><br><span class="line">        <span class="type">int</span> k, x;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, op);</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(op, <span class="string">&quot;I&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">            cnt ++;</span><br><span class="line">            m ++;</span><br><span class="line">            ph[m] = cnt, hp[cnt] = m;</span><br><span class="line">            h[cnt] = x;</span><br><span class="line">            <span class="built_in">up</span>(cnt);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(op, <span class="string">&quot;PM&quot;</span>)) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, h[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(op, <span class="string">&quot;DM&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">heap_swap</span>(<span class="number">1</span>, cnt);</span><br><span class="line">            cnt --;</span><br><span class="line">            <span class="built_in">down</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(op, <span class="string">&quot;D&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;k);</span><br><span class="line">            k = ph[k];</span><br><span class="line">            <span class="built_in">heap_swap</span>(k, cnt);</span><br><span class="line">            cnt --;</span><br><span class="line">            <span class="built_in">down</span>(k), <span class="built_in">up</span>(k);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;k, &amp;x);</span><br><span class="line">            k = ph[k], h[k] = x;</span><br><span class="line">            <span class="built_in">down</span>(k), <span class="built_in">up</span>(k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;模拟堆&quot;&gt;&lt;a href=&quot;#模拟堆&quot; class=&quot;headerlink&quot; title=&quot;模拟堆&quot;&gt;&lt;/a&gt;模拟堆&lt;/h3&gt;&lt;p&gt;接下来看模拟堆，模拟堆比起之前就是多了两个数组，这两个数组属于互为反函数的类型。例如 &lt;code&gt;hp[k] = j&lt;/code&gt;那</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://primeluoqiu.github.io/categories/Algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>1.6分组延时、丢失和吞吐量</title>
    <link href="https://primeluoqiu.github.io/2024/03/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.6/"/>
    <id>https://primeluoqiu.github.io/2024/03/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.6/</id>
    <published>2024-03-23T06:21:33.296Z</published>
    <updated>2024-03-23T12:46:00.036Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/23/4XZbDEld.jpg"                      alt="17.jpg"                ><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/23/wc80rluy.jpg"                      alt="18.jpg"                ><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/23/mMM91mwr.jpg"                      alt="19.jpg"                ><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/23/o4jbDSvk.jpg"                      alt="20.jpg"                ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;https://img2.imgtp.com</summary>
      
    
    
    
    <category term="计网" scheme="https://primeluoqiu.github.io/categories/%E8%AE%A1%E7%BD%91/"/>
    
    
  </entry>
  
  <entry>
    <title>1.5Internet结构和ISP</title>
    <link href="https://primeluoqiu.github.io/2024/03/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.5/"/>
    <id>https://primeluoqiu.github.io/2024/03/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.5/</id>
    <published>2024-03-23T06:21:32.774Z</published>
    <updated>2024-03-23T06:28:30.826Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/23/Y36VrbMf.jpg"                      alt="13.jpg"                ><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/23/FG8Br175.jpg"                      alt="14.jpg"                ><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/23/ZJyEJEkW.jpg"                      alt="15.jpg"                ><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/23/tjVTjn0e.jpg"                      alt="16.jpg"                ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;https://img2.imgtp.com</summary>
      
    
    
    
    <category term="计网" scheme="https://primeluoqiu.github.io/categories/%E8%AE%A1%E7%BD%91/"/>
    
    
  </entry>
  
  <entry>
    <title>1.4接入网和网络媒体</title>
    <link href="https://primeluoqiu.github.io/2024/03/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.4/"/>
    <id>https://primeluoqiu.github.io/2024/03/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.4/</id>
    <published>2024-03-23T06:21:32.245Z</published>
    <updated>2024-03-23T06:28:32.286Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/23/uWbuUjGi.jpg"                      alt="9.jpg"                ><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/23/N5GvtHel.jpg"                      alt="10.jpg"                ><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/23/lppuK39o.jpg"                      alt="11.jpg"                ><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/23/kfjGSqA1.jpg"                      alt="12.jpg"                ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;https://img2.imgtp.com</summary>
      
    
    
    
    <category term="计网" scheme="https://primeluoqiu.github.io/categories/%E8%AE%A1%E7%BD%91/"/>
    
    
  </entry>
  
  <entry>
    <title>1.3网络核心</title>
    <link href="https://primeluoqiu.github.io/2024/03/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.3/"/>
    <id>https://primeluoqiu.github.io/2024/03/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.3/</id>
    <published>2024-03-23T06:21:31.662Z</published>
    <updated>2024-03-23T06:28:32.926Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/23/3d5Unwa7.jpg"                      alt="5.jpg"                ><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/23/5hqppVMQ.jpg"                      alt="6.jpg"                ><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/23/PaiZxOFi.jpg"                      alt="7.jpg"                ><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/23/QaC6Sdnu.jpg"                      alt="8.jpg"                ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;https://img2.imgtp.com</summary>
      
    
    
    
    <category term="计网" scheme="https://primeluoqiu.github.io/categories/%E8%AE%A1%E7%BD%91/"/>
    
    
  </entry>
  
  <entry>
    <title>1.2网络边缘</title>
    <link href="https://primeluoqiu.github.io/2024/03/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.2/"/>
    <id>https://primeluoqiu.github.io/2024/03/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.2/</id>
    <published>2024-03-23T06:21:30.368Z</published>
    <updated>2024-03-23T06:28:33.782Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/23/t3uhqPrU.jpg"                      alt="3.jpg"                ><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/23/mZeqzUZB.jpg"                      alt="4.jpg"                ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;https://img2.imgtp.com</summary>
      
    
    
    
    <category term="计网" scheme="https://primeluoqiu.github.io/categories/%E8%AE%A1%E7%BD%91/"/>
    
    
  </entry>
  
  <entry>
    <title>1.1什么是Internet</title>
    <link href="https://primeluoqiu.github.io/2024/03/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.1%E4%BB%80%E4%B9%88%E6%98%AFInternet/"/>
    <id>https://primeluoqiu.github.io/2024/03/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.1%E4%BB%80%E4%B9%88%E6%98%AFInternet/</id>
    <published>2024-03-23T06:15:09.395Z</published>
    <updated>2024-03-23T06:28:38.121Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/23/y5YJlSvM.jpg"                      alt="微信图片_20240323140956.jpg"                ><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/23/y5YJlSvM.jpg"                      alt="微信图片_20240323140956.jpg"                ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;https://img2.imgtp.com</summary>
      
    
    
    
    <category term="计网" scheme="https://primeluoqiu.github.io/categories/%E8%AE%A1%E7%BD%91/"/>
    
    
  </entry>
  
  <entry>
    <title>CS61A.Chapter1</title>
    <link href="https://primeluoqiu.github.io/2024/03/23/ClassesFormUCBerkely/CS61A/%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0%E6%9E%84%E9%80%A0%E6%8A%BD%E8%B1%A1/"/>
    <id>https://primeluoqiu.github.io/2024/03/23/ClassesFormUCBerkely/CS61A/%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0%E6%9E%84%E9%80%A0%E6%8A%BD%E8%B1%A1/</id>
    <published>2024-03-22T16:54:16.698Z</published>
    <updated>2024-03-23T12:51:07.757Z</updated>
    
    <content type="html"><![CDATA[<p>之所以计算机科学的巨大生产力能够成为可能，都是因为其建立在一套优雅而强大的基本思想之上。所有计算都始于三点：信息的表示、处理的逻辑、设计抽象来管理逻辑的复杂性，掌握这些基础知识需要我们去精确理解计算机程序的构造和解释。</p><h3 id="1-1-4-第一个例子"><a href="#1-1-4-第一个例子" class="headerlink" title="1.1.4 第一个例子"></a>1.1.4 第一个例子</h3><p>Python内置了一些常见编程功能，例如处理文本，显示图形以及通过互联网进行通信。下面这行Python代码</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> urlib.request <span class="keyword">import</span> urlopen</span><br></pre></td></tr></table></figure></div><p>是一个<code>import</code>语句，它会导入一个用于”访问互联网数据”的功能，该功能特别提供了一个名为<code>urlopen</code>的函数，可以访问URL上的内容</p><h4 id="语句和表达式"><a href="#语句和表达式" class="headerlink" title="语句和表达式"></a>语句和表达式</h4><p>Python代码由表达式和语句组成，从广义上讲，计算机程序由一下指令组成</p><ol><li>计算一些值</li><li>执行一些操作<br>语句通常描述操作，Python解释器每执行一条语句，计算机就会执行相应的操作。另外，表达式通常用于描述计算，当Python计算一个表达式时，它会计算出该式的值。</li></ol><p>下面的赋值语句</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shakespeare = urlopen(<span class="string">&#x27;https://www.composingprograms.com/shakespeare.txt&#x27;</span>)</span><br></pre></td></tr></table></figure></div><p>将名称<code>shakespeare</code>与<code>=</code>后面的表达式的值相连，这个表达式将<code>urlopen</code>函数应用在了一个URL身上。</p><p><strong>函数</strong>: 函数封装了操作数据的逻辑。<code>urlopen</code>就是一个函数，而网址是一个数据，莎士比亚的戏剧是另一个数据。从前者到后者的准换过程可能会很复杂，但我们可以将这种复杂性隐藏在一个函数中，从而能够使用一个简单的表达式来跳过该过程。函数是本章的主题</p><p>另一个赋值语句</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>words = <span class="built_in">set</span>(shakespare.read().decode().split())</span><br></pre></td></tr></table></figure></div><p>将<code>words</code>与莎士比亚戏剧中出现的共33721个单词的集合相连。其命令链调用了<code>read</code>、<code>decode</code>、<code>split</code>，每个函数都会操作一个中间的计算实体：从URL中<code>read</code>(读取)数据，然后将数据<code>decode</code>(解码)为文本，最后将文本<code>split</code>(拆分)为单词放在一个<code>set</code>中。</p><p><strong>对象</strong>:<code>set</code>就是一种对象，支持如计算交际和集合关系(membership)等计算。对象无缝整合了数据以及用于操作该数据的逻辑，并隐藏了二者的复杂性对象是第二章的主题</p><p>最后，这个表达式</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;w <span class="keyword">for</span> w <span class="keyword">in</span> words <span class="keyword">if</span> <span class="built_in">len</span>(W) == <span class="number">6</span> <span class="keyword">and</span> w[::<span class="number">1</span>] <span class="keyword">in</span> words&#125;  </span><br><span class="line">&#123;<span class="string">&#x27;redder&#x27;</span>, <span class="string">&#x27;drawer&#x27;</span>, <span class="string">&#x27;reward&#x27;</span>, <span class="string">&#x27;diaper&#x27;</span>, <span class="string">&#x27;repaid&#x27;</span>&#125;</span><br></pre></td></tr></table></figure></div><p>是一个符合表达式，它的计算结果是反向拼写同时也为单词的莎士比亚单词集合。神秘符号<code>w[::-1]</code>表示枚举单词中的每个字母，其中-1代表反向枚举，当在交互式对话中输入表达式时，Python会在下一行打印值。</p><p><strong>解释器</strong>：符合表达式的求解需要以一个可预测的方式来精确解释代码的过程。实现在这样的过程，用于计算复合表达式的程序就称为解释器。解释器的设计和实现是第三章的主题</p><p>与其他计算机程序相比，编程语言的解释器具有独特的通用性。Python在设计时并不会考虑莎士比亚，但它的高度灵活性使我们能够只用少量的语句和表达式来处理大量的文本。</p><p>最后，这些核心概念都是紧密相关的：函数是对象，对象是函数，解释器是二者的实例。但是，清楚的理解每一个概念及其在组织代码中的作用对于掌握编程艺术至关重要。</p><hr><h3 id="1-1-5-ERROR-Python"><a href="#1-1-5-ERROR-Python" class="headerlink" title="1.1.5 ERROR Python"></a>1.1.5 ERROR Python</h3><p>正在等待命令。即使可能还不了解完整的机会和结构，所以总会有一些失误的情况。因为计算机在极其灵活的同时也十分古板，计算机的特性在<strong>斯坦福的入门课程中被描述为</strong></p><p>当尝试使用Python解释器时，计算机的古板会立即显现出来：即使是最小的拼写和格式更改也会导致预料之外的输出和错误。</p><p>学着解释错误和找到错误的原因被称为调试，关于调试的一些指导原则是：</p><ol><li><p><strong>增量测试</strong>：每个编写良好的程序都可以单独测试的小型模块化组件组成。尽快测试已经编写的所有内容，以尽早发现问题并获得对组件的信心。</p></li><li><p><strong>隔离错误</strong>：语句输出中错误常可归因于特定的模块化组件。所以在诊断问题时，先追踪错误到最小的代码片段，然后再试着修复问题</p></li><li><p><strong>检查假设</strong>：解释器会一字不漏地执行指令——不多也不少。当某些代码的行为与程序员假设的行为不匹配时，它们的输出就是不合预期的。明确假设，然后将调试的工作集中在验证假设上。</p></li><li><p><strong>咨询别人</strong>：你不是一个人！如果你不理解错误信息，请询问朋友、老师或者搜索引擎，如果已经找出了一个错误，但却不知道如何更正，可以请其他人查看。</p></li></ol><p>增量测试、模块化设计、明确的假设和团队合作时贯穿本书的主题，希望它们也贯穿你的计算机科学职业生涯。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;之所以计算机科学的巨大生产力能够成为可能，都是因为其建立在一套优雅而强大的基本思想之上。所有计算都始于三点：信息的表示、处理的逻辑、设计抽象来管理逻辑的复杂性，掌握这些基础知识需要我们去精确理解计算机程序的构造和解释。&lt;/p&gt;
&lt;h3 id=&quot;1-1-4-第一个例子&quot;&gt;&lt;a</summary>
      
    
    
    
    <category term="CS61A" scheme="https://primeluoqiu.github.io/categories/CS61A/"/>
    
    
  </entry>
  
  <entry>
    <title>CS61A.Chapter2</title>
    <link href="https://primeluoqiu.github.io/2024/03/23/ClassesFormUCBerkely/CS61A/1.2%20%E7%BC%96%E7%A8%8B%E8%A6%81%E7%B4%A0/"/>
    <id>https://primeluoqiu.github.io/2024/03/23/ClassesFormUCBerkely/CS61A/1.2%20%E7%BC%96%E7%A8%8B%E8%A6%81%E7%B4%A0/</id>
    <published>2024-03-22T16:54:16.694Z</published>
    <updated>2024-03-22T16:56:21.324Z</updated>
    
    <content type="html"><![CDATA[<p>编程语言不仅是一种指挥计算机执行任务的手段，它还应该成为一种框架，使我们能够在其中组织自己有关计算过程的思想。程序也会在社区之间互相分享，那么程序必须是人类可读，且恰巧能够被机器执行。</p><p>这样，当我们描述一种语言的时候，就需要特别注意该语言所提供的能够将简单思想组合成复杂思想的工具。那么每一种强大的语言都有这样三种机制</p><ul><li>原始表达式和语句：语言所关心的最简单的个体。</li><li>组合方法：由简单元素组合构建复合元素</li><li>抽象方法：命名复合元素，并将其作为单元进行操作。<br>在编程中，我们只会处理两种元素：函数和数据(之后会发现他们之间的区分实际上没那么明显)。不那么正式的说法是：数据是我们想要操作的东西。而函数是操作这些数据的规则的描述。</li></ul><p>因此，任何强大的编程语言都必须能表达基本的数据和函数，并且提供对函数和数据进行组合和抽象的方法。</p><hr><h3 id="1-2-1-表达式"><a href="#1-2-1-表达式" class="headerlink" title="1.2.1 表达式"></a>1.2.1 表达式</h3><p>下面就一点一点了解Python语言。先从一种基本表达式开始，也就是键入的数字，十进制的表达式</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">42</span></span><br><span class="line"><span class="number">42</span></span><br></pre></td></tr></table></figure></div><p>表达式表达的数字可以与数学运算符组成一个复合表达式，解释器将对其进行求值：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>-<span class="number">1</span> - -<span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line">&gt;&gt;&gt;<span class="number">1</span>/<span class="number">2</span> + <span class="number">1</span>/<span class="number">4</span> + <span class="number">1</span>/<span class="number">8</span> + <span class="number">1</span>/<span class="number">16</span> + <span class="number">1</span>/<span class="number">32</span> + <span class="number">1</span>/<span class="number">64</span> + <span class="number">1</span>/<span class="number">128</span></span><br><span class="line"><span class="number">0.9921875</span></span><br></pre></td></tr></table></figure></div><p>这些数学表达式使用的是中缀表示法，指的是运算符出现在操作数之间。Python包含多种形成复合表达式的方法，后面会慢慢介绍</p><hr><h3 id="1-2-2-调用表达式"><a href="#1-2-2-调用表达式" class="headerlink" title="1.2.2 调用表达式"></a>1.2.2 调用表达式</h3><p>最重要的一种复合表达式就是调用表达式，它将函数运用于一些参数上。回想一下高中学过的函数概念：函数就是从一些输入参数到输出值的映射。例如, <code>max</code>函数会输出一个最大的输入值，也就是将多个输入映射到了单个输出上。Python中函数应用的方式与传统数学相同</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">max</span>(<span class="number">7.5</span>, <span class="number">9.5</span>)</span><br><span class="line"><span class="number">9.5</span></span><br></pre></td></tr></table></figure></div><p>这个调用表达式包含子表达式(subexpression):在括号之前是运算符表达式，而括号里面是一个以逗号分隔的操作数表达式的列表<br>![[..&#x2F;..&#x2F;Pasted image 20240322110143.png]]<br>运算符指定了一个函数，在对这个调用表达式进行求值时，我们会说，使用参数7.5和9.5来调用函数<code>max</code>，最后返回9.5</p><p>调用表达式中参数的顺序是很重要的。例如，<code>pow</code>函数的第二个参数是第一个参数的幂</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;编程语言不仅是一种指挥计算机执行任务的手段，它还应该成为一种框架，使我们能够在其中组织自己有关计算过程的思想。程序也会在社区之间互相分享，那么程序必须是人类可读，且恰巧能够被机器执行。&lt;/p&gt;
&lt;p&gt;这样，当我们描述一种语言的时候，就需要特别注意该语言所提供的能够将简单思想</summary>
      
    
    
    
    <category term="CS61A" scheme="https://primeluoqiu.github.io/categories/CS61A/"/>
    
    
  </entry>
  
  <entry>
    <title>acwing -堆排序</title>
    <link href="https://primeluoqiu.github.io/2024/03/21/Algorithm/sort/"/>
    <id>https://primeluoqiu.github.io/2024/03/21/Algorithm/sort/</id>
    <published>2024-03-21T13:54:55.018Z</published>
    <updated>2024-03-21T13:56:15.931Z</updated>
    
    <content type="html"><![CDATA[<p>如何手写一个堆<br>维护一个数据集合<br>支持的基本操作：</p><ol><li>插入一个数</li><li>求集合当中的最小值</li><li>删除最小值</li></ol><p>还有操作可以支持</p><ol><li>删除任意一个元素</li><li>修改任意一个元素</li></ol><p>堆是一个二叉树，完全二叉树，树除了最后一层节点之外，上面的所有节点都是满的。最后一层节点从左到右排列。<br>小根堆有个性质：每个点都小于左右儿子，一个递归定义，根节点就是整个数据结构的最小值。<br>堆的存储：(全新的存储方式):用一个一维数组来存。堆状数据结构几乎都可以用一位数组来存储。</p><p>存储的话，数组的第一个节点是根节点，然后从x开始，x的左儿子是2x, x的右儿子是2x+1<br>有两种操作，分别是<code>up 和 down</code>，五个操作都可以用这两个函数来解决。</p><p><code>down</code>操作实际上就是在这三个数字里面找到最小的数字，然后把最大的数字和最小的数字进行交换，然后把相对来说小的数推上去</p><ol><li>插入一个数：heap [++size] &#x3D; x; up(size);</li><li>求集合当中的最小值:heap[1];</li><li>删除最小值 用堆的最后一个元素来覆盖掉堆顶的元素，然后再把堆顶down一下即可。删除头节点比较困难，尾节点比较简单。 heap[1] &#x3D; heap[size]; size –;down(1); </li><li>删除任意一个元素: heap[k] &#x3D; heap[size]; heap –; down(k); up(k); 分情况讨论，变大就down一遍，变小就up一下，或者直接不管，up，down一边就行。</li><li>修改任意一个元素:heap[k] &#x3D; x; down(k); up(k);<br>下标从1开始</li></ol><p>然后我们来看一道题：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入一个长度为n的整数数列，从小到大输出前m小的数。</span><br></pre></td></tr></table></figure></div><p>通过读题我们可以看出来，在这里我们只需要down这个操作，我们来看一下down这个操作是怎么实现的</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> h[N], cnt; <span class="comment">//存的heap和存了多少元素</span></span><br><span class="line"><span class="comment">//我们只需要把数组建成堆，然后每一次输出堆顶，第一次输出就是第一小的数，然后是第二小的数，然后balabala</span></span><br><span class="line"><span class="comment">//需要第二个操作和第三个操作，然后我们发现只需要实现down就可以了。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> t = u;</span><br><span class="line"><span class="keyword">if</span>(u * <span class="number">2</span> &lt;= cnt &amp;&amp; h[u * <span class="number">2</span>] &lt; h[t]) t = u * <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(u * <span class="number">2</span> + <span class="number">1</span> &lt;= cnt &amp;&amp; h[u * <span class="number">2</span> + <span class="number">1</span>] &lt; h[t]) t = u * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(u != t)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">swap</span>(h[u], h[t]);</span><br><span class="line"><span class="built_in">down</span>(t);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;h[i]);</span><br><span class="line">    cnt = n;</span><br><span class="line"><span class="comment">//正常输入，然后建堆，如果是一个一个往里面插入的话，时间复杂度是(nlogn)的，有一种时间复杂度是O(n)的方法是从1/2开始往下down</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = n / <span class="number">2</span>; i; i --) <span class="built_in">down</span>(i);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">while</span>(m --)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, h[<span class="number">1</span>]);</span><br><span class="line">h[<span class="number">1</span>] = h[cnt];</span><br><span class="line">cnt --;</span><br><span class="line"><span class="built_in">down</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>至于为什么是O(n)的呢？  </p><p>down操作很简单，用t来表示三个点里面的最小值，首先判断一下有没有左儿子。</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> t = u;</span><br><span class="line"><span class="keyword">if</span>(u * <span class="number">2</span> &lt;= size &amp;&amp; h[u * <span class="number">2</span>] &lt; h[t]) t = u * <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(u * <span class="number">2</span> + <span class="number">1</span> &lt;= size &amp;&amp; h[u * <span class="number">2</span> + <span class="number">1</span>] &lt; h[t]) t = u * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(u != t)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">swap</span>(h[u], h[t]);</span><br><span class="line"><span class="built_in">down</span>(t);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;如何手写一个堆&lt;br&gt;维护一个数据集合&lt;br&gt;支持的基本操作：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;插入一个数&lt;/li&gt;
&lt;li&gt;求集合当中的最小值&lt;/li&gt;
&lt;li&gt;删除最小值&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;还有操作可以支持&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;删除任意一个元素&lt;/li&gt;
&lt;l</summary>
      
    
    
    
    <category term="acwing" scheme="https://primeluoqiu.github.io/categories/acwing/"/>
    
    
  </entry>
  
  <entry>
    <title>Lecture 5 - List3</title>
    <link href="https://primeluoqiu.github.io/2024/03/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Lecture5%20-%20List3%20DLList%20And%20Arrays/"/>
    <id>https://primeluoqiu.github.io/2024/03/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Lecture5%20-%20List3%20DLList%20And%20Arrays/</id>
    <published>2024-03-20T14:21:05.839Z</published>
    <updated>2024-03-21T13:56:27.690Z</updated>
    
    <content type="html"><![CDATA[<p>之前说到的<code>SLList</code>还是很不错的，不过目前来看的话它存在了一个新的问题，就是对于<code>addLast</code>函数而言，还是相对来说比较缓慢地，效率也是比较低的。</p><p>就像是最一开始的<code>size</code>函数，那么我们有什么办法可以提高它的效率呢，我们可以在中间人那里再定义一个last函数用来保存最后一个节点的地址，不过这样的话，就会有新的操作效率较慢了</p><p>那便是<code>remove</code>操作，那么如果我们想要删除一个节点的话，那么我们只能首先遍历到节点那里，然后删除这个节点的指针，然后再将<code>last</code>的那个指针指向删除的节点的前一个节点。这听起来实在是太麻烦了，所以这种方法似乎也是不可取的。那么还有什么别的方法吗</p><p>那么，我们就想到能不能就是给每一个节点添加一个当前节点的前置节点的指针呢？答案是可以的</p><p>这种每个节点都有两个链接的列表叫做双向链表</p><p>完成这种方法之后，我们的添加在头部和尾部，删除头部和尾部的方法就会变得十分的快，不过在中间的节点操作相对来说就会比较慢。</p><p>不过这样的链表还是会存在一个 限制有这样一种情况：最后一个节点的next指针有的时候指向最开始的哨兵节点，有的时候指向我们称之的<code>最开始的节点(real node)</code>。那么就有可能需要我们在后面再去写相关的判断语句来判断它是否真的是哨兵节点。</p><p>为了避免这种麻烦的情况，我们尝试让他变得更纯粹一些。</p><pre><code>所以为了完善我们的方法的最自然的方法就是添加第二个哨兵，然后让着第二个哨兵来指向最后一个节点，我们不再是一个指向最后一项的一个指针，而是在开始和末尾两端都添加一个哨兵（因为此时我们已经有了prev和next指针），这样的话，前面就有一个哨兵，后面也有一个哨兵了，那么这样再添加节点或者项目的时候，就只需要将节点滑入这两个哨兵之间就可以了那么其实还有一种办法，这里依旧还是只有一个哨兵，它既是前面的哨兵也是后面的哨兵![[../一些截图（笔记用）/Pasted image 20240226134251.png]]就像这里的，先指向哨兵节点，然后指向3，指向9，最终再回到sentinal.所以这实际上更像一个循环。</code></pre><p>不过即便是这样，还是会有一个限制，就是说在现实世界中不太好使，就是说，如果我们要添加的东西是数字时，它会非常的好用，但是如果我们添加的是字符串或者字符呢？我们又该怎么办，例如</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SLListLauncher</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">SLList</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SLList</span>(<span class="string">&quot;Bone&quot;</span>);</span><br><span class="line">s1.addFirst(<span class="string">&quot;thugs&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>也就是说，我们不能将字符串转化成整数这样的报错。</p><p>我们可以选择重新创建一个全新的<code>SLList</code>类，不过这意味着我们还需要重新写一遍我们的类。这听起来可太麻烦了。</p><p>不过，还有一种方法就是使<code>SLList</code>参数化，我们可以参数化<code>SLList</code>将采用的类型，这应该如何操作呢</p><p>就是我们要在<code>SLList</code>后面添加新的尖括号<code>&lt;&gt;</code>，然后在尖括号里面添加任意的字符串，例如<code>LochNess</code>，这是充当创建<code>SLList</code>时尚未决定的类型的占位符，因此这个时候我们将使用<code>LochNess</code>来代替<code>int</code>项，然后这个时候我们也会将我们创建一个节点的名字改成</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private class StuffNode(LochNess i, StuffNode n) &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>定义是这样的</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SLList</span>&lt;LochNess&gt; &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">StuffNode</span> &#123;</span><br><span class="line"><span class="keyword">public</span> LochNess item;</span><br><span class="line"><span class="keyword">public</span> StuffNode next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>这个时候我们只需要将main函数修改一下即可</p><p>现在想要创建一个<code>SLList</code>的话，需要指定一个类型</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SLList&lt;String&gt; s1 = <span class="keyword">new</span> <span class="title class_">SLList</span>&lt;String&gt;(<span class="string">&quot;bone&quot;</span>); <span class="comment">//定义并实例化</span></span><br></pre></td></tr></table></figure></div><p>然后就正常工作了。</p><p>在我们使用的时候，我们往&lt;&gt;里传什么，对应的函数里的&lt;&gt;也会传什么，所以它基本上是一个类型变量或类型参数</p><p>在更现代的java中，不再需要在实例化方面指定类型，也是行得通的。</p><p>在指定类型的时候，只需要指定一次计科，可以在其他地方多次使用它。使用的时候尖括号内的首字母需要<strong>大写</strong>!!!</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;之前说到的&lt;code&gt;SLList&lt;/code&gt;还是很不错的，不过目前来看的话它存在了一个新的问题，就是对于&lt;code&gt;addLast&lt;/code&gt;函数而言，还是相对来说比较缓慢地，效率也是比较低的。&lt;/p&gt;
&lt;p&gt;就像是最一开始的&lt;code&gt;size&lt;/code&gt;函数，那</summary>
      
    
    
    
    <category term="CS61B" scheme="https://primeluoqiu.github.io/categories/CS61B/"/>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://primeluoqiu.github.io/2024/03/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Lecture4-List%202%20SLLists/"/>
    <id>https://primeluoqiu.github.io/2024/03/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Lecture4-List%202%20SLLists/</id>
    <published>2024-03-20T14:21:05.838Z</published>
    <updated>2024-03-20T14:24:22.475Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Video-1"><a href="#Video-1" class="headerlink" title="Video 1:"></a>Video 1:</h1><h2 id="Class-A-Introducing-the-SLList"><a href="#Class-A-Introducing-the-SLList" class="headerlink" title="Class A:Introducing the SLList"></a>Class A:Introducing the SLList</h2><h3 id="Last-Time-in-61B-Recursive-Implementation-of-a-List"><a href="#Last-Time-in-61B-Recursive-Implementation-of-a-List" class="headerlink" title="Last Time in 61B: Recursive Implementation of a List"></a>Last Time in 61B: Recursive Implementation of a List</h3><hr><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntList</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> first;</span><br><span class="line"><span class="keyword">public</span> IntList rest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">IntList</span><span class="params">(<span class="type">int</span> f, IntList r)</span> &#123;</span><br><span class="line">first = f;</span><br><span class="line">rest = r;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></div><p>While functional, “naked”linked lists like the one above are hard to use.</p><ul><li>Users of this class are probably going to need to know references very well, and be able to think recursively.Let’s make our users’ lives easier.<br>这些代码对于我们来讲是比较容易看懂的，但是对于用户来讲可能就比较费解，那么我们需要一些其他的方式来重新叙写我们的IntList。对它进行更新换代，以至于让我们的用户理解起来也很方便</li></ul><h3 id="Improvement-1-Rebaranding-and-Culling"><a href="#Improvement-1-Rebaranding-and-Culling" class="headerlink" title="Improvement #1: Rebaranding and Culling"></a>Improvement #1: Rebaranding and Culling</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntNode</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> item;</span><br><span class="line"><span class="keyword">public</span> IntNode next;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">IntNode</span><span class="params">(<span class="type">int</span> i, IntNode n)</span> &#123;</span><br><span class="line">item = i;</span><br><span class="line">next = n;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><code>IntNode</code> is now dumb, has no methods.We will reintroduce functionality in the coming slides.</p><p>Not much of an improvement obviously, but this next weird trick will be more impressive.</p><h2 id="Class-B-Introducing-the-SLList-Bureaucracy"><a href="#Class-B-Introducing-the-SLList-Bureaucracy" class="headerlink" title="Class B:Introducing the SLList Bureaucracy"></a>Class B:Introducing the SLList Bureaucracy</h2><p>这个也提供了一些小方面的改善。<br>下一步，我们创建另一个类，命名为<code>SLList</code>，这个类表示是一个整数列表，隐藏了内部是单纯的数字的真相。这个列表的工作原理是我们已经有一个IntList类</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Lecture4;  </span><br><span class="line"><span class="comment">/* An SLList is a list of integers, which hides the terrible truth * of thr nakedness within. */</span>  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SLList</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> IntNode first;  </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SLList</span><span class="params">(<span class="type">int</span> x)</span> &#123;  </span><br><span class="line">       first = <span class="keyword">new</span> <span class="title class_">IntNode</span>(x, <span class="literal">null</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">       <span class="comment">/*Create a list of one integer, namely 10*/</span>  </span><br><span class="line">       <span class="type">SLList</span> <span class="variable">L</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SLList</span>(<span class="number">10</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>那么我们为什么要做这种看起来似乎没什么意义的事情呢？<br>这是一个线索，如果考虑一下某个程序员如何创建列表，那么他实际上不必指定<code>null</code>，只需要添加一个数字即可。<br>在之前，当我们想要创建一个列表，我们需要</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">IntNode</span> <span class="variable">X</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IntNode</span>(<span class="number">10</span>, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure></div><p>而现在我们只需要</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SLList</span> <span class="variable">Y</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SLList</span>(<span class="number">10</span>);</span><br></pre></td></tr></table></figure></div><p>SLList is easier to instantiate(no need to specify null), but wait, there’s more.</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SLList</span> &#123;</span><br><span class="line"><span class="keyword">public</span> IntNode first;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">SLList</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">front = <span class="keyword">new</span> <span class="title class_">IntNode</span>(x, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>Next: Let’s add addFirst and getFirst method to SLList.</p><h2 id="Class-C-Introducing-the-SLList-Methods"><a href="#Class-C-Introducing-the-SLList-Methods" class="headerlink" title="Class C: Introducing the SLList Methods"></a>Class C: Introducing the SLList Methods</h2><p>在我们拿走了<code>IntNode</code>能做的所有事情之后，我们将会在<code>SLList</code>中还原他，接下来是我们准备还原的一部分<code>addFirst</code> <code>getFirst</code><br>当我们想要完成第一个函数的<code>addFirst</code>的时候，我们可以从之前的<code>IntList</code>当中寻找灵感，在这里我们创建一个新的点的时候<br>![[..&#x2F;..&#x2F;Pasted image 20240126093348.png]]<br>用到的是<code>L = new IntList</code>，那么我们在这里也是</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Add x to the front of the list.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(<span class="type">int</span> x)</span> &#123;  </span><br><span class="line">    first = <span class="keyword">new</span> <span class="title class_">IntNode</span>(x, <span class="literal">null</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>至于<code>getFirst</code>的话，相对来说我们只需要返回第一个的<code>item</code>，相对来说会简单很多</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Returns the first item in the list</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getFirst</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> first.item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="SLLists-vs-IntLists"><a href="#SLLists-vs-IntLists" class="headerlink" title="SLLists vs. IntLists"></a>SLLists vs. IntLists</h2><p>对比一下之前写的和最近写的</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SLList</span> <span class="variable">L</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SLList</span>(<span class="number">15</span>);</span><br><span class="line">L.addFirst(<span class="number">10</span>);</span><br><span class="line">L.addFirst(<span class="number">5</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> L.getFirst();</span><br><span class="line"></span><br><span class="line"><span class="type">IntList</span> <span class="variable">L</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IntList</span>(<span class="number">15</span>, <span class="literal">null</span>);</span><br><span class="line">L = <span class="keyword">new</span> <span class="title class_">IntList</span>(L, <span class="number">10</span>);</span><br><span class="line">L = <span class="keyword">new</span> <span class="title class_">IntList</span>(L, <span class="number">5</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> L.first;</span><br></pre></td></tr></table></figure></div><p>While functional, “naked”linked lists like the <strong>IntList</strong> class are hard to use.</p><ul><li>Users of <strong>IntList</strong> are need to know Java references well, and be able to think recursively.</li><li><strong>SLList</strong> is much simpler to use. Simply use the provided methods.</li><li>Why not just add an addFirst method to the <strong>IntList</strong> class? Turn out there is no efficent way to do this. See exercise in LectureCode repository.</li></ul><h1 id="Video-2-Access-Control-and-Nested-Classes"><a href="#Video-2-Access-Control-and-Nested-Classes" class="headerlink" title="Video 2: Access Control and Nested Classes"></a>Video 2: Access Control and Nested Classes</h1><p>我们不难发现，<code>SLList</code>是很好用的，想要添加，删除，或者获取内容的话，最好使用该类提供的方法，不过，根据java的工作效益，可以尝试做一些奇怪的事情。</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SLList</span> &#123;</span><br><span class="line"><span class="keyword">public</span> IntNode first;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">SLList</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">first = <span class="keyword">new</span> <span class="title class_">IntNode</span>(x, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">first = <span class="keyword">new</span> <span class="title class_">IntNode</span>(x, first);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>Users of our classes might be tempted to try to manipulate our secret IntNode directly in uncouth ways!</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SLList</span> <span class="variable">L</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SLList</span>(<span class="number">15</span>);</span><br><span class="line">L.addFirst(<span class="number">10</span>);</span><br><span class="line">L.first.next.next = L.first.next;</span><br></pre></td></tr></table></figure></div><p>显然，这是不被允许的。可以猜一下会发生什么<br>![[..&#x2F;..&#x2F;Pasted image 20240127092904.png]]<br>![[..&#x2F;..&#x2F;Pasted image 20240127092922.png]]<br>它最终会指向自身，我们最终毁掉了这个列表。<br>很显然，我们并不想被类似这样的调用其他方法来毁掉我们的列表，因此我们可以在我们的程序之前添加注释，类似</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Don&#x27;t mess up my programmer*/</span></span><br></pre></td></tr></table></figure></div><p>但是这很显然没有下述方式来的更加畅快</p><h2 id="Access-Control"><a href="#Access-Control" class="headerlink" title="Access Control"></a>Access Control</h2><hr><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SLList</span> &#123;</span><br><span class="line"><span class="keyword">public</span> IntNode first;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">SLList</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">first = <span class="keyword">new</span> <span class="title class_">IntNode</span>(x, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">first = <span class="keyword">new</span> <span class="title class_">IntNode</span>(x, first);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>We can prevent programmers from making such mistakes with the <strong>private</strong> keyword.<br>我们可以给类的成员声明为<code>private</code>而不是声明为<code>public</code>例如</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> IntNode first;</span><br></pre></td></tr></table></figure></div><p>现在，好处是，这不仅是自行记录的，而且还有编译器强制执行，那么在别的类中访问这个变量就会报错<br>因此<code>private</code>关键字的作用是防止其他类中的代码使用该类的成员(包括变量，方法…)<br>不过，java中有一个有趣的功能称为反射。允许绕过这些修饰符，不过很少使用。</p><hr><h2 id="Why-Restrict-Access"><a href="#Why-Restrict-Access" class="headerlink" title="Why Restrict Access?"></a>Why Restrict Access?</h2><p>Hide implementation details from users of your class.</p><ul><li>Less for user of class to understand.</li><li>Safe for you to change private methods.(implementation).<br>E.g:<br>Car analogy:</li><li>Public: Pedals, Steering Wheel Private:Fuel line, Rotary valve.</li><li>Despite the term ‘access control’:<ul><li>Nothing to do with protection against hackers, spies, and other evil entities.<br>至于为什么要限制通过呢，也就是说为什么要用<code>private</code>，一个方面是为了对使用你的类的人隐藏实施细节，他们不需要了解这个原理是什么，他们有对应的输入和输出即可。其次，对你来讲去修改这种私有方法是很安全的。<br>例如在一个车的系统当中，公共的部分有例如踏板，轮胎这些，而私有的例如燃油管线（现在有纯电车）。<br>不过，当有人获取到你的源码之后，这些所谓的安全也就不存在了。</li></ul></li></ul><p>总结一下，私有就是你可以随便处置但是用户不可以，公共就是都可以访问你的方法等一系列东西。</p><h2 id="Improvement-4-Nested-Classes"><a href="#Improvement-4-Nested-Classes" class="headerlink" title="Improvement 4: Nested Classes"></a>Improvement 4: Nested Classes</h2><p>Can combine two classes into one file pretty simply.</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SLList</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntNode</span> &#123; <span class="comment">//Nested class definition</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> item;</span><br><span class="line"><span class="keyword">public</span> IntNode next;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">IntNode</span><span class="params">(<span class="type">int</span> i, IntNode n)</span> &#123;</span><br><span class="line">item = i;</span><br><span class="line">next = n;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="comment">// Could have made IntNode a private nested class if we wanted.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> IntNode first; <span class="comment">//Instance variables, constructors, and methods of SLList typical go below nested class definition.</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">SLList</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">first = <span class="keyword">new</span> <span class="title class_">IntNode</span>(x, <span class="literal">null</span>);</span><br><span class="line">&#125;...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>一个嵌套的类定义，那么，嵌套的类有什么好处呢？</p><h2 id="Why-Nested-Classes"><a href="#Why-Nested-Classes" class="headerlink" title="Why Nested Classes?"></a>Why Nested Classes?</h2><p>Nested Classes are useful when a class doesn’t stand on its own and is obvious subordinate(从属，下属) to another class.</p><ul><li>Make the nested(嵌套的) class private if other classes should never use the nested class.</li></ul><p>In my opinion, probably makes sense to make IntNode a nested private class.</p><ul><li>Hard to imagine other classes having a need to manipulate IntNodes</li></ul><h2 id="Static-Nested-Classes"><a href="#Static-Nested-Classes" class="headerlink" title="Static Nested Classes"></a>Static Nested Classes</h2><hr><p>If the nested class never uses any instance variables or methods of the outer class, declare it static</p><ul><li>Static classes cannot access outer class’s instance variables or methods.</li><li>Results in a minor savings of memory. See book for more details.<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SLList</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">IntNode</span> &#123; <span class="comment">//we can declare IntNode static, since it never use any of SLList&#x27;s instance variables or methods.</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> item;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> IntNode next;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">IntNode</span><span class="params">(<span class="type">int</span> i, IntNode n)</span></span><br><span class="line">&#123;</span><br><span class="line">item = i;</span><br><span class="line">next = n;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>Unimportant note:For private nested classes, access modifiers are irrelevant.<br>如果嵌套类从不需要查找，那么可以添加<code>staitc</code>关键字。</li></ul><h1 id="Video3-addLast-and-size"><a href="#Video3-addLast-and-size" class="headerlink" title="Video3: addLast and size"></a>Video3: addLast and size</h1><h2 id="Adding-more-SLList-Functionality"><a href="#Adding-more-SLList-Functionality" class="headerlink" title="Adding more SLList Functionality"></a>Adding more SLList Functionality</h2><hr><p>To motivate our remaining improvements, and to give more functionality to our SLList class, let’s add:</p><ul><li>.addLast(int x)</li><li>.size()<br>Recommendation: Try writing them yourself before watching how I do it.<br>添加了两个其他的方法。</li></ul><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(<span class="type">int</span> x)</span> &#123;  </span><br><span class="line">    <span class="type">IntNode</span> <span class="variable">p</span> <span class="operator">=</span> first;  </span><br><span class="line">    <span class="comment">/*Move p until it reaches the end of the list. */</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">while</span>(p.next != <span class="literal">null</span>) &#123;  </span><br><span class="line">       p = p.next;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    p.next = <span class="keyword">new</span> <span class="title class_">IntNode</span>(x, <span class="literal">null</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>当想要尝试<code>.size()</code>的时候，我们发现试图搞清楚基本情况是比较困难的。如果使用递归的话情况也是很奇怪，如果想要用递归来做的话，那么就无从下手。<br>原因是SLList这个数据结构本身就不是递归的，它没有SLList指针。<br>因此只能采用相对来说通用性更强一些的策略了、<br>    通常会创建一个私有的静态帮助器方法，它会采用一个特定的节点来帮助我们解决这个问题。所以现在的话，这就是一个非常清晰的递归数据结构<br>    那么这样的话</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">(IntNode p)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span>(p.next == <span class="literal">null</span>)  </span><br><span class="line">       <span class="keyword">return</span> <span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + size(p.next);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> size(first);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h1 id="Video-4-Caching"><a href="#Video-4-Caching" class="headerlink" title="Video 4: Caching"></a>Video 4: Caching</h1><p>假设有一个长度为1000的SLList，我们遍历一遍获得它的长度的时间是两秒，那么如果有一个长度为1,000,000的链表的时候，时间就是2,000秒，那么这个函数实际上是效率很低的，那么我们应该用什么方式来提高它的效率呢？</p><p>我们可以选择在类的内部定义一个私有的成员变量size，然后在类似<code>addFirst, addLast</code>这里对<code>size += 1</code>，然后在定义一个链表的时候让<code>size = 1</code>，这样在写<code>size</code>函数的时候直接<code>return size</code>即可。</p><p>不过其实，这样和遍历一个链表的所花费的空间或者说时间还是一样的，只不过是把一个很大的任务分散化了，</p><p>也就是说，当我们每操作一次链表，size的值就会被更新一下。</p><p>那么还有没有别的办法呢</p><p>当然肯定是有的。<br>就是利用我们最开始引入的那个中间人，也就是<code>first</code>节点，在这里我们可以用他来存储有关整个列表的元信息的自然位置</p><pre><code>之前说过`SLList`有一个很好的优势，就是每当想要操作数据或者查看数据的时候，都必须经过这个中间人，这个中间人为我们提供了非常简单易懂的办法来保证安全，避免我们以各种方式搬起石头砸自己的脚。现在`SLList`结构拥有这个中间人的另一个好处是，它可以作为存储有关整个列表元信息的自然位置。例如，我们可以在这里存储列表的大小，这在技术上是多余的，我们可以在没有这个变量的情况下计算大小，但它会加快大小的计算速度，因为我们只需要返回这个大小的值，我们也可以在这里存放其他东西，就像可以存储曾经放入其中的最大值、最小值等，这些也可以正常工作。相比之下，使用裸递归列表就不那么容易了，指图片中的上者，原则上可以执行诸如缓存每个节点内部的大小之类的操作。但即便如此，这也意味着每当我们更改列表中的某些内容时，都必须更新一堆大大小小的变量，例如如果有一种允许这样做的语言，我们还可以以某种方式在此处绑定一个变量来跟踪整个事物的大小。但是在Java中，没有天然的工具（函数）可以做到这一点。因此，实际上，我们最终要做的就是拥有多个必须保持一致的变量，在这里，这种面向对象的编程方法意味着我们让对象来控制一切，我们告诉对象，你的工作不仅是王城所有这些任务，还要为我跟踪尺寸，这样，这就是组织代码的自然方式。也就是说，`intList`可以做`SLList`可以做的所有的事情，但是`SLList`在几乎所有方面都是一种更自然的方法</code></pre><h1 id="Video-5-The-Empty-List"><a href="#Video-5-The-Empty-List" class="headerlink" title="Video 5 The Empty List"></a>Video 5 The Empty List</h1><p>那么<code>SLList</code>这么好用，他还可以允许我们自己代表空列表，也就是说创建列表的时候可以很自然的实例化一个空列表，那么我们来修改一下我们的代码</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Create an empty SLList*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">SLList</span><span class="params">()</span>&#123;</span><br><span class="line">size = <span class="number">0</span>;</span><br><span class="line">first = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>源码此时是这样的</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Lecture4;  </span><br><span class="line"><span class="comment">/* An SLList is a list of integers, which hides the terrible truth * of thr nakedness within. */</span>  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> Lecture3.IntList;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SLList</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> IntNode first;  </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SLList</span><span class="params">()</span> &#123;  </span><br><span class="line">       first = <span class="literal">null</span>;  </span><br><span class="line">       size = <span class="number">0</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">/*Creates an empty SLList*/</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SLList</span><span class="params">(<span class="type">int</span> x)</span> &#123;  </span><br><span class="line">       first = <span class="keyword">new</span> <span class="title class_">IntNode</span>(x, <span class="literal">null</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Adds x to the front of the list.  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(<span class="type">int</span> x)</span> &#123;  </span><br><span class="line">       first = <span class="keyword">new</span> <span class="title class_">IntNode</span>(x, first); size += <span class="number">1</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Returns the first item in the list.  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getFirst</span><span class="params">()</span> &#123;  </span><br><span class="line">       <span class="keyword">return</span> first.item;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//Adds x to the last of the list.  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(<span class="type">int</span> x)</span> &#123;  </span><br><span class="line">       <span class="type">IntNode</span> <span class="variable">p</span> <span class="operator">=</span> first;  </span><br><span class="line">       <span class="comment">/*Move p until it reaches the end of the list. */</span>  </span><br><span class="line">  </span><br><span class="line">       <span class="keyword">while</span>(p.next != <span class="literal">null</span>) &#123;  </span><br><span class="line">          p = p.next;  </span><br><span class="line">       &#125;  </span><br><span class="line">  </span><br><span class="line">       p.next = <span class="keyword">new</span> <span class="title class_">IntNode</span>(x, <span class="literal">null</span>);  </span><br><span class="line">       size += <span class="number">1</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">/*Returns the sizes of the list from IntNode p*/</span>  </span><br><span class="line">    <span class="comment">/*private static int size(IntNode p) &#123;       if(p.next == null)          return 1;       return 1 + size(p.next);    &#125;  </span></span><br><span class="line"><span class="comment">    public int size() &#123;       return size(first);    &#125;*/</span>    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">       <span class="comment">/*Create a list of one integer, namely 10*/</span>  </span><br><span class="line">       <span class="type">SLList</span> <span class="variable">L</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SLList</span>();  </span><br><span class="line">       L.addFirst(<span class="number">10</span>);  </span><br><span class="line">       L.addFirst(<span class="number">5</span>);  </span><br><span class="line">       L.addLast(<span class="number">20</span>);  </span><br><span class="line">  </span><br><span class="line">       System.out.println(L.size);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>结果自然而然的就是3<br>但是实际上这个代码会存在一个小小的bug<br>就是，如果我们不是先从头插入的话，就会报错，例如我们第一步先用<code>addLast</code>的话就会报错<br>![[..&#x2F;一些截图（笔记用）&#x2F;Pasted image 20240222155831.png]]<br>是因为我们将一个指针指向了空指针，然而空指针的下一位是空的，就会报错。<br>那么我们应该如何处理这个问题呢？<br>有一个方法就是在<code>addLast</code>中添加一个判断语句，即</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">size += <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(first == <span class="literal">null</span>) &#123;</span><br><span class="line">first = <span class="keyword">new</span> <span class="title class_">IntNode</span>(x, first);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>这样再看的话，我们的程序目前工作就正常了<br>![[..&#x2F;一些截图（笔记用）&#x2F;Pasted image 20240222160836.png]]</p><h1 id="Video-6-Sentinel-Nodes"><a href="#Video-6-Sentinel-Nodes" class="headerlink" title="Video 6: Sentinel Nodes"></a>Video 6: Sentinel Nodes</h1><p>在我们了解到上述问题之后，其实还有一种解决的方式，这种方式未来会在我们在构筑大型项目上的时候有所优势。就是创建一个哨兵节点，然后哨兵节点来传递到第一个节点、第二个节点…这些，然后我们用一个指针来讲创建的列表指向我们的哨兵节点，这样的话无论列表是不是空的都会有一个节点在那里。不过这样的话，我们就需要对基本上所有的函数进行修改了。</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Lecture4;  </span><br><span class="line"><span class="comment">/* An SLList is a list of integers, which hides the terrible truth * of thr nakedness within. */</span>  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> Lecture3.IntList;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SLList</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">IntNode</span> &#123;  </span><br><span class="line">       <span class="keyword">public</span> <span class="type">int</span> item;  </span><br><span class="line">       <span class="keyword">public</span> IntNode next;  </span><br><span class="line">  </span><br><span class="line">       <span class="keyword">public</span> <span class="title function_">IntNode</span><span class="params">(<span class="type">int</span> i, IntNode n)</span> &#123;  </span><br><span class="line">          item = i;  </span><br><span class="line">          next = n;  </span><br><span class="line">       &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;  </span><br><span class="line">    <span class="comment">/*The first item (if it exists) is at sentinel.next*/</span>  </span><br><span class="line">    <span class="keyword">private</span> IntNode sentinel;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SLList</span><span class="params">()</span> &#123;  </span><br><span class="line">       sentinel = <span class="keyword">new</span> <span class="title class_">IntNode</span>(<span class="number">66</span>, <span class="literal">null</span>);  </span><br><span class="line">       size = <span class="number">0</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">/*Creates an empty SLList*/</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SLList</span><span class="params">(<span class="type">int</span> x)</span> &#123;  </span><br><span class="line">       sentinel = <span class="keyword">new</span> <span class="title class_">IntNode</span>(<span class="number">66</span>, <span class="literal">null</span>);  </span><br><span class="line">       sentinel.next = <span class="keyword">new</span> <span class="title class_">IntNode</span>(x, <span class="literal">null</span>);  </span><br><span class="line">       size = <span class="number">1</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Adds x to the front of the list.  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(<span class="type">int</span> x)</span> &#123;  </span><br><span class="line">       sentinel.next = <span class="keyword">new</span> <span class="title class_">IntNode</span>(x, sentinel.next);  </span><br><span class="line">       size += <span class="number">1</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Returns the first item in the list.  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getFirst</span><span class="params">()</span> &#123;  </span><br><span class="line">       <span class="keyword">return</span> sentinel.next.item;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//Adds x to the last of the list.  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(<span class="type">int</span> x)</span> &#123;  </span><br><span class="line">  </span><br><span class="line">       size += <span class="number">1</span>;  </span><br><span class="line">  </span><br><span class="line">       <span class="type">IntNode</span> <span class="variable">p</span> <span class="operator">=</span> sentinel;  </span><br><span class="line">       <span class="comment">/*Move p until it reaches the end of the list. */</span>  </span><br><span class="line">  </span><br><span class="line">       <span class="keyword">while</span>(p.next != <span class="literal">null</span>) &#123;  </span><br><span class="line">          p = p.next;  </span><br><span class="line">       &#125;  </span><br><span class="line">  </span><br><span class="line">       p.next = <span class="keyword">new</span> <span class="title class_">IntNode</span>(x, <span class="literal">null</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">/*Returns the sizes of the list from IntNode p*/</span>  </span><br><span class="line">    <span class="comment">/*private static int size(IntNode p) &#123;       if(p.next == null)          return 1;       return 1 + size(p.next);    &#125;  </span></span><br><span class="line"><span class="comment">    public int size() &#123;       return size(first);    &#125;*/</span>    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">       <span class="comment">/*Create a list of one integer, namely 10*/</span>  </span><br><span class="line">       <span class="type">SLList</span> <span class="variable">L</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SLList</span>();  </span><br><span class="line">       L.addFirst(<span class="number">10</span>);  </span><br><span class="line">       L.addFirst(<span class="number">5</span>);  </span><br><span class="line">       L.addLast(<span class="number">20</span>);  </span><br><span class="line">  </span><br><span class="line">       System.out.println(L.size);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>改完之后就是大致这样的</p><p>那么哨兵节点实际上就是一个虚拟的节点，一个忠实的伙伴。鉴于第一个不再指向第一项，那么我们重命名它为哨兵代码</p><p>当然，哨兵对于我们便携的所有代码来说它永远不会为空，并且它总是指向哨兵节点，哨兵节点的值可以随机，我在这里选择了66.当我们编写带么和检查每个构造函数和方法时，我们必须确保所有内容都与我们的哨兵节点兼容。理想情况下，一开始就这样做的话这样就不会感觉那么随意。我们不会一次性做出一堆微小的改变</p><h1 id="Video-7-Invariants"><a href="#Video-7-Invariants" class="headerlink" title="Video 7: Invariants"></a>Video 7: Invariants</h1><p>我们可以使用术语<code>不变性</code>来概括这种保持简单的想法。因此不变量只是一个在代码运行时保证为真的条件。<br>所以它列出了所有可以信赖的事实。因此，带有哨兵节点的<code>SLList</code><br>那么它总是具有一些不变量，例如哨兵变量——哨兵应用它总是指向一个哨兵节点，这是我们所拥有的东西，并且保证是真实的<br>另一个是列表中的第一个节点(如果存在的话)，那么它始终位于<code>sentinel.next</code>，事实上，这在代码中是作为注释明确写出得一个不变量。</p><p>因此，不变量的好处是它可以让我们更容易地推理代码<br>它可能让我们避免出错</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Video-1&quot;&gt;&lt;a href=&quot;#Video-1&quot; class=&quot;headerlink&quot; title=&quot;Video 1:&quot;&gt;&lt;/a&gt;Video 1:&lt;/h1&gt;&lt;h2 id=&quot;Class-A-Introducing-the-SLList&quot;&gt;&lt;a href=&quot;#C</summary>
      
    
    
    
    <category term="CS61B" scheme="https://primeluoqiu.github.io/categories/CS61B/"/>
    
    
  </entry>
  
</feed>
