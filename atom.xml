<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>秋过冬漫长</title>
  
  <subtitle>没有比脚更长的路,走过去就好了</subtitle>
  <link href="https://primeluoqiu.github.io/atom.xml" rel="self"/>
  
  <link href="https://primeluoqiu.github.io/"/>
  <updated>2024-03-26T02:37:09.281Z</updated>
  <id>https://primeluoqiu.github.io/</id>
  
  <author>
    <name>LuoQiu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>1.7 协议层次和服务模型</title>
    <link href="https://primeluoqiu.github.io/2024/03/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.7/"/>
    <id>https://primeluoqiu.github.io/2024/03/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.7/</id>
    <published>2024-03-25T14:08:13.610Z</published>
    <updated>2024-03-26T02:37:09.281Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/25/N72p3fKJ.jpg"                      alt="21.jpg"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/25/Wi1mIyuc.jpg"                      alt="22.jpg"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/25/sSH1q9SA.jpg"                      alt="23.jpg"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/25/sSH1q9SA.jpg"                      alt="24.jpg"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/26/1i5XQqWi.jpg"                      alt="25.jpg"                ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;https://img2.imgtp.com</summary>
      
    
    
    
    <category term="计算机网络" scheme="https://primeluoqiu.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>计网第二个实验</title>
    <link href="https://primeluoqiu.github.io/2024/03/25/SchoolHomework/%E8%AE%A1%E7%BD%91/Experiment2/"/>
    <id>https://primeluoqiu.github.io/2024/03/25/SchoolHomework/%E8%AE%A1%E7%BD%91/Experiment2/</id>
    <published>2024-03-25T05:46:43.090Z</published>
    <updated>2024-03-25T05:51:05.404Z</updated>
    
    <content type="html"><![CDATA[<p>五、实验步骤                                      </p><p>1.数据规划（课程目标1）</p><p>表1-交换机VLAN划分及端口</p><table><thead><tr><th>设备名</th><th>VLAN编号</th><th>VLAN名称</th><th>端口范围</th><th>连接计算机</th></tr></thead><tbody><tr><td>LSW1</td><td>vlan 10</td><td>技术部</td><td>E 0&#x2F;0&#x2F;1 - E 0&#x2F;0&#x2F;2</td><td>PC1, PC3</td></tr><tr><td>LSW2</td><td>vlan 20</td><td>财务部</td><td>E 0&#x2F;0&#x2F;1 - E 0&#x2F;0&#x2F;2</td><td>PC2, PC4</td></tr></tbody></table><p>表2-PC计算机IP地址及端口信息</p><table><thead><tr><th>设备名</th><th>端口</th><th>IP地址信息</th><th>网关</th></tr></thead><tbody><tr><td>PC1</td><td>E 0&#x2F;0&#x2F;1</td><td>10.10.1.1</td><td>255.255.255.0</td></tr><tr><td>PC2</td><td>E 0&#x2F;0&#x2F;2</td><td>10.10.1.2</td><td>255.255.255.0</td></tr><tr><td>PC3</td><td>E 0&#x2F;0&#x2F;3</td><td>10.10.1.3</td><td>255.255.255.0</td></tr><tr><td>PC4</td><td>E 0&#x2F;0&#x2F;4</td><td>10.10.1.4</td><td>255.255.255.0</td></tr></tbody></table><p> 2.启动有eNSP模拟器，按实验要求和规划，搭建网络拓扑。（课程目标3）<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/25/trp0rx6s.png"                      alt="Pasted image 20240325105802.png"                ><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/25/zXYjCsX3.png"                      alt="Pasted image 20240325105819.png"                ><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/25/BT39huMp.png"                      alt="Pasted image 20240325105918.png"                ></p><p><strong>上图IP地址应为10.10.1.3，当时打错了，后面有纠正</strong></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/25/YWoj26hw.png"                      alt="Pasted image 20240325105929.png"                ></p><p>3.设备配置。（课程目标3）<br>本次配置比起实验一来说，就是多了对于两个交换机的控制，其余的配置都是一样的，当我们配置完每台PC的IP之后，我们就可以进入交换机进行配置了。<br>首先我们进入LSW(交换机1)，然后我们首先关闭之后可能会出现的提示信息</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">undo info-center enable</span><br></pre></td></tr></table></figure></div><p>接下来，我们首先配置第一个交换机所连接的两台PC和对应连接的一台交换机的端口。<br>操作还是和之前一样的操作</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sys</span><br><span class="line">vlan batch 10 20</span><br></pre></td></tr></table></figure></div><p>首先进入sys<br>然后创建两个vlan 10和20</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface G 0/0/1 //G是一种端口的名称，指千兆以太网端口，而上个实验的E指的是普通以太网端口</span><br><span class="line">port link-type access</span><br><span class="line">port default vlan 10</span><br></pre></td></tr></table></figure></div><p>这是第一台PC的配置</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface G 0/0/2</span><br><span class="line">port link-type access</span><br><span class="line">port default vlan 20</span><br></pre></td></tr></table></figure></div><p>这是第二台PC的配置<br>接下来是本实验的核心内容，就是配置24端口的两台交换机，使得他们可以通过vlan10 和 vlan20这两个线路。这样的话就可以连接起来这两台交换机了。</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface G 0/0/24</span><br><span class="line">port link-type trunk</span><br><span class="line">port trunk allow-pass vlan 10 20</span><br></pre></td></tr></table></figure></div><p>这样的话，这个交换机和交换机之间的线缆就可以通过10和20的接口了。<br>剩下的就是配置第二台交换机的配置，方法和上述方法一样，重复一下即可。</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">undo info-center enable</span><br><span class="line">sys</span><br><span class="line">vlan batch 10 20</span><br><span class="line">interface G 0/0/1 //G是一种端口的名称，指千兆以太网端口，而上个实验的E指的是普通以太网端口</span><br><span class="line">port link-type access</span><br><span class="line">port default vlan 10</span><br><span class="line">interface G 0/0/2</span><br><span class="line">port link-type access</span><br><span class="line">port default vlan 20</span><br><span class="line">interface G 0/0/24</span><br><span class="line">port link-type trunk</span><br><span class="line">port trunk allow-pass vlan 10 20</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/25/Wax8a7rI.png"                      alt="Pasted image 20240325114246.png"                ><br>我们不难看出vlan10和20这两个线路均有24接口通过。那么实验就完成了，接下来验证实验就可以了。</p><p>4.验证。（课程目标3）<br>PC2验证<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/25/nGHjP7zq.png"                      alt="Pasted image 20240325114548.png"                ><br>PC1配置<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/25/5fgk27XM.png"                      alt="Pasted image 20240325114813.png"                ><br>由图可知，pc1可以连3，2可以连4，这样的话我们的实验目的也就完成了</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/25/Eg8vjkjM.png"                      alt="Pasted image 20240325114956.png"                ><br>拓扑图如上。<br>六、实验心得或存在的问题（课程目标1)<br>本次实验学到了有关不同楼层的两台交换机之间应该如何配置，以至于达到楼层之间的互联而不与同楼层之间的互联。<br>本次实验还学习到了有关<code>link-type trunk</code>以及trunk接口是用于交换机之间连接的端口，trunk口可以1加入多个vlan，以及接收和发送多个Vlan的Tagged帧。<br>还了解到了G口是千兆以太网口，E口是以太网口的知识点。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;五、实验步骤                                      &lt;/p&gt;
&lt;p&gt;1.数据规划（课程目标1）&lt;/p&gt;
&lt;p&gt;表1-交换机VLAN划分及端口&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;设备名&lt;/th&gt;
&lt;th&gt;VLAN编号</summary>
      
    
    
    
    <category term="计网" scheme="https://primeluoqiu.github.io/categories/%E8%AE%A1%E7%BD%91/"/>
    
    
  </entry>
  
  <entry>
    <title>Week4 and Daily Schedule</title>
    <link href="https://primeluoqiu.github.io/2024/03/24/%E6%AF%8F%E5%91%A8%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/Week4/"/>
    <id>https://primeluoqiu.github.io/2024/03/24/%E6%AF%8F%E5%91%A8%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/Week4/</id>
    <published>2024-03-24T13:23:47.317Z</published>
    <updated>2024-03-24T13:40:46.850Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Daily-Schedule"><a href="#Daily-Schedule" class="headerlink" title="Daily Schedule"></a>Daily Schedule</h1><h2 id="Total-Schedule"><a href="#Total-Schedule" class="headerlink" title="Total Schedule"></a>Total Schedule</h2><ol><li>《计算机网络》-郑铨老师的 1.7-2.2</li><li>CS61B Week 7- 10</li><li>CS61A 看完第二章</li><li>CSAPP 看完第二章</li><li>CS61C 前两周内容</li></ol><p>每天任务的话，先看周一吧，周一相对来说课不算多，下午有一节毛概，毛概课的话得补半节课的数电笔记和作业</p><h3 id="Monday"><a href="#Monday" class="headerlink" title="Monday"></a>Monday</h3><p>《计算机网络》 1.7</p><p>CS61A</p><p>CS61B</p><p>CSAPP</p><p>还得看点算法，要不都快要蓝桥杯考试了，顶不住了</p><p>目前先准备这些，看明天的收效，希望明天早上可以起得来然后走两圈锻炼锻炼。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Daily-Schedule&quot;&gt;&lt;a href=&quot;#Daily-Schedule&quot; class=&quot;headerlink&quot; title=&quot;Daily Schedule&quot;&gt;&lt;/a&gt;Daily Schedule&lt;/h1&gt;&lt;h2 id=&quot;Total-Schedule&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="大二下" scheme="https://primeluoqiu.github.io/categories/%E5%A4%A7%E4%BA%8C%E4%B8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>第三周总结</title>
    <link href="https://primeluoqiu.github.io/2024/03/24/%E6%AF%8F%E5%91%A8%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/%E7%AC%AC%E4%B8%89%E5%91%A8%E6%80%BB%E7%BB%93/"/>
    <id>https://primeluoqiu.github.io/2024/03/24/%E6%AF%8F%E5%91%A8%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/%E7%AC%AC%E4%B8%89%E5%91%A8%E6%80%BB%E7%BB%93/</id>
    <published>2024-03-24T13:07:37.059Z</published>
    <updated>2024-03-24T13:34:07.396Z</updated>
    
    <content type="html"><![CDATA[<p>本周学习任务完成情况：</p><ol><li>郑铨《计算机网络》:已看完1.6，还差一节视频</li><li>CS61B 目标未完成，达成率 0</li><li>CS61A 仅仅看了1.4之前的，还差一章</li><li>CSAPP：差一节的知识点和两节的对于知识点的总结</li><li>CS61C：甚至还没看课</li></ol><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>怎么说呢，本周的事情相对来说比较多，很多时候为了处理一些事情不得不去花费一晌的时间。究其根本的话还是因为考虑的事情太多太繁杂，像极了酷安的那张经典图片，某物在拥有前，拥有时，以及拥有后的心情状态。</p><p>其实有的时候也是，覆水难收是肯定的事情，硬要做一些可能看起来不是那么的合常理的事情的时候，往往就会产生很多负面的因素，谁能想到收到的手机会是一个被拿去抵债的手机呢。不过其实经此一事的话，二手的市场还真的水深，得亏是那个老哥很好说话，再加上我的态度也是非常的到位，以至于目前来说似乎并没有产生什么不和平的因素。就感觉也还好。本周这种事情占得时间还是蛮多的。课程的任务量其实也还好，就是笔记和每周的作业。感觉也还OK，起码目前基本上emm也算是个应付的态势吧</p><p>有的时候还是心不静，心乱的话效率也不会很高。每次学习的时候也不妨像他们一样手机扣一下，然后就在一边放着。电脑端挂个微信就行，不过似乎我好像也不会被别人找的样子hhh</p><p>这两周的锻炼还算是有所成效，减重了一些，但不多，想要减重还是得每天坚持锻炼，然后规律作息、规律作息、规律作息，重要的事情说三遍hhh，早上倒也还是能起得来，就是太困了，归根结底还是晚上睡的太晚，十二点半左右能睡的话第二天的精神状态想必就会好很多了。早上起来之后的感觉也不会太困。</p><p>啧，其实有的时候也在想，如果我要不是天天学习，或者说如果我真的把这大学四年荒废过去会怎么样，虽然我妈对我的要求确实不高，也就是混口饭吃的程度。不过再怎么说都是要勤奋的，无论是在后面的学习上，还是之后的找工作上。去哪里，找什么样的工作，这些虽然都是后话，但是也是在茫然之中会考虑到的一些事情。</p><p>时间…时间…</p><p>还有多久呢…</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本周学习任务完成情况：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;郑铨《计算机网络》:已看完1.6，还差一节视频&lt;/li&gt;
&lt;li&gt;CS61B 目标未完成，达成率 0&lt;/li&gt;
&lt;li&gt;CS61A 仅仅看了1.4之前的，还差一章&lt;/li&gt;
&lt;li&gt;CSAPP：差一节的知识点和两节的对于知识</summary>
      
    
    
    
    <category term="大二下" scheme="https://primeluoqiu.github.io/categories/%E5%A4%A7%E4%BA%8C%E4%B8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://primeluoqiu.github.io/2024/03/24/CSAPP/%E7%AC%AC%E4%B8%80%E7%AB%A0/1.8%20%E7%B3%BB%E7%BB%9F%E4%B9%8B%E9%97%B4%E5%88%A9%E7%94%A8%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"/>
    <id>https://primeluoqiu.github.io/2024/03/24/CSAPP/%E7%AC%AC%E4%B8%80%E7%AB%A0/1.8%20%E7%B3%BB%E7%BB%9F%E4%B9%8B%E9%97%B4%E5%88%A9%E7%94%A8%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/</id>
    <published>2024-03-24T02:51:49.636Z</published>
    <updated>2024-03-23T15:40:20.220Z</updated>
    
    <content type="html"><![CDATA[<p>实际上，现代系统经常通过网络和其他系统连接到一起，从一个单独的系统来看，网络可视为一个I&#x2F;O设备。当系统从主存复制一串字节到网络适配器时，数据流经网络到达另一台机器。相似地，系统可以读取其他机器发来的数据，并把数据复制到自己的主存。<br>![[Pasted image 20240323233843.png]]<br>随着Internet全球网络的出现，从一台主机复制信息到另一台主机已经成为计算机系统最重要的用途之一</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;实际上，现代系统经常通过网络和其他系统连接到一起，从一个单独的系统来看，网络可视为一个I&amp;#x2F;O设备。当系统从主存复制一串字节到网络适配器时，数据流经网络到达另一台机器。相似地，系统可以读取其他机器发来的数据，并把数据复制到自己的主存。&lt;br&gt;![[Pasted im</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>CSAPP Chapter1.7 硬件被谁管理啊</title>
    <link href="https://primeluoqiu.github.io/2024/03/24/CSAPP/%E7%AC%AC%E4%B8%80%E7%AB%A0/1.7%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E7%A1%AC%E4%BB%B6/"/>
    <id>https://primeluoqiu.github.io/2024/03/24/CSAPP/%E7%AC%AC%E4%B8%80%E7%AB%A0/1.7%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E7%A1%AC%E4%BB%B6/</id>
    <published>2024-03-24T02:51:49.635Z</published>
    <updated>2024-03-24T02:43:36.991Z</updated>
    
    <content type="html"><![CDATA[<p>从hello的例子可以可以看出来，当shell加载运行包括最后输出的时候，shell和hello都没有直接对硬件进行访问(包括键盘，显示器，主存或者磁盘)。取而代之的是，他们依靠操作系统提供的服务。我们可以把操作系统看成是应用程序和硬件之间插入的一层软件。所有应用程序对硬件的操作尝试都必须通过操作系统<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/24/XDgvCQG1.png"                      alt="Pasted image 20240320002837.png"                ><br>操作系统有两个基本功能，</p><ol><li>防止硬件被失控的应用程序滥用</li><li>向应用程序提供简单一致的机制来控制复杂而又通常大不相同的低级硬件设备。</li></ol><p>操作系统通过几个基本的抽象概念(<strong>进程</strong>、<strong>虚拟内存</strong>和<strong>文件</strong>)来实现这两个功能，如下图所示，文件是对I&#x2F;O设备的抽象表示，虚拟内存是对主存和磁盘I&#x2F;O设备的抽象表示，进程则是对处理器、主存和I&#x2F;O设备的抽象表示<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/24/cavhFdDj.png"                      alt="Pasted image 20240320003206.png"                ></p><h4 id="1-7-1-进程"><a href="#1-7-1-进程" class="headerlink" title="1.7.1 进程"></a>1.7.1 进程</h4><p>像hello这样的程序在现代系统上运行时，操作系统会提供一种假象，就像系统上只有这个程序在运行。程序看上去是独占地只用处理器、主存和I&#x2F;O设备。处理器看上去就像在不间断的一条接一条地执行程序中的指令，即该程序的代码和数据是系统内存中唯一的对象。这些假象是通过进程的概念来实现的，进程是计算机科学中最重要和最成功的概念之一。</p><p><strong>进程</strong>是操作系统对一个正在运行的程序的一种抽象。在一个系统上可以同时运行多个进程，而每个进程都好像在独占的使用硬件。而<strong>并发运行</strong>，则是说一个进程的指令和另一个进程的指令是交错执行的。在大多数系统中，需要运行的进程数是多于可以运行它们的CPU个数的。传统系统在一个时刻只能执行一个程序，而先进的<strong>多核</strong>处理器同时能够执行多个程序。无论是在单核还是多核系统中，一个CPU看上去都像是在并发地执行多个进程，这是通过处理器在进程间切换来实现的。操作系统实现这种操作执行的机制称为<strong>上下文交换</strong>。为了简化讨论，我们只考虑包含一个CPU的<strong>单处理器系统</strong>的情况。后面还会讨论</p><p>操作系统保持跟踪进程运行所需的所有状态信息。这种状态，也就是<strong>上下文</strong>，包括许多信息，比如PC和寄存器文件的当前值，以及主存的内容。在任何一个时刻，单处理器系统都只能执行一个进程的代码。当操作系统决定要把控制权从当前进程转移到某个新进程时，就会进行上下文切换，即保存当前进程的上下文、恢复新进程的上下文，然后将控制权传递到新进程。新进程就会从它上次停止的地方开始。那么hello程序运行场景的基本理念看下面。<br>![[<a class="link"   href="https://hansimov.gitbook.io/~gitbook/image?url=https://4154149387-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%252F-MHt_spaxGgCbp2POnfq%252F-MHzietxOnE2XCBTZHJ7%252F-MHziqrI26zhGJA9_NLL%252F01-12%2520%25E8%25BF%259B%25E7%25A8%258B%25E7%259A%2584%25E4%25B8%258A%25E4%25B8%258B%25E6%2596%2587%25E5%2588%2587%25E6%258D%25A2.png?alt=media&token=5df4420b-e3c7-46ca-8192-ba207aa49f15&width=400&dpr=3&quality=100&sign=7323c7a530eb087f04ecfa52db5f03b77529e0c73a5744a490b2389fecb6b30ehttps://hansimov.gitbook.io/~gitbook/image?url=https://4154149387-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%252F-MHt_spaxGgCbp2POnfq%252F-MHzietxOnE2XCBTZHJ7%252F-MHziqrI26zhGJA9_NLL%252F01-12%2520%25E8%25BF%259B%25E7%25A8%258B%25E7%259A%2584%25E4%25B8%258A%25E4%25B8%258B%25E6%2596%2587%25E5%2588%2587%25E6%258D%25A2.png?alt=media&token=5df4420b-e3c7-46ca-8192-ba207aa49f15&width=400&dpr=3&quality=100&sign=7323c7a530eb087f04ecfa52db5f03b77529e0c73a5744a490b2389fecb6b30e%5D%5D" >https://hansimov.gitbook.io/~gitbook/image?url=https:%2F%2F4154149387-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-legacy-files%2Fo%2Fassets%252F-MHt_spaxGgCbp2POnfq%252F-MHzietxOnE2XCBTZHJ7%252F-MHziqrI26zhGJA9_NLL%252F01-12%2520%25E8%25BF%259B%25E7%25A8%258B%25E7%259A%2584%25E4%25B8%258A%25E4%25B8%258B%25E6%2596%2587%25E5%2588%2587%25E6%258D%25A2.png%3Falt=media%26token=5df4420b-e3c7-46ca-8192-ba207aa49f15&amp;width=400&amp;dpr=3&amp;quality=100&amp;sign=7323c7a530eb087f04ecfa52db5f03b77529e0c73a5744a490b2389fecb6b30ehttps://hansimov.gitbook.io/~gitbook/image?url=https:%2F%2F4154149387-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-legacy-files%2Fo%2Fassets%252F-MHt_spaxGgCbp2POnfq%252F-MHzietxOnE2XCBTZHJ7%252F-MHziqrI26zhGJA9_NLL%252F01-12%2520%25E8%25BF%259B%25E7%25A8%258B%25E7%259A%2584%25E4%25B8%258A%25E4%25B8%258B%25E6%2596%2587%25E5%2588%2587%25E6%258D%25A2.png%3Falt=media%26token=5df4420b-e3c7-46ca-8192-ba207aa49f15&amp;width=400&amp;dpr=3&amp;quality=100&amp;sign=7323c7a530eb087f04ecfa52db5f03b77529e0c73a5744a490b2389fecb6b30e]] <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br>实例当中有两个并发的进程：shell和hello。最开始，只有shell进程在运行，也就是等待命令行上的输入。当我们让他运行hello程序时，shell通过一个专门的函数，也就是系统调用，来执行我们的请求，系统调用会将控制权传递给操作系统。操作系统保存shell进程的上下文，创建一个新的hello进程及其上下文，并将控制权传回给它，shell进程会继续等待下一个命令行输入。</p><p>如图所示，从一个进程到另一个进程的转换是由操作系统<strong>内核(kernel)</strong> 管理的。内核是操作系统代码常驻主存的部分。当应用程序需要操作系统的某些操作时，比如读写文件，它就执行一条特殊的<strong>系统调用(system call)</strong> 指令，将控制权传递给内核。然后内核执行被请求的操作并返回应用程序。注意，内核不是一个独立的进程。相反，它是系统管理全部进程所用代码和数据结构的集合。</p><p>实现进程这个抽象概念需要低级硬件和操作系统软件之间的紧密合作。</p><h4 id="1-7-2-线程"><a href="#1-7-2-线程" class="headerlink" title="1.7.2 线程"></a>1.7.2 线程</h4><p>尽管通常我们认为一个进程只有单一的控制流，但是在现在系统中，一个进程实际上可以由多个称为<strong>线程</strong>的执行单元组成，每个线程都运行在进程的上下文中，并共享的代码和全局数据。由于网络服务器中对并行处理的需求，线程称为越来越重要的编程模型，因为多线程之间比多进程之间更容易共享数据，也因为线程一般来说都比进程更高效。当有多处理器可用的时候，多线程也是一种使得程序可以运行得更快的方法，我们将在后面讨论</p><h4 id="1-7-3-虚拟内存"><a href="#1-7-3-虚拟内存" class="headerlink" title="1.7.3 虚拟内存"></a>1.7.3 虚拟内存</h4><p>虚拟内存是一个抽象概念，它为每一个进程提供了一个假象，即每个进程都在独占地使用主存。每个进程看到的内存都是一致的，称为虚拟地址空间。下图所示的Linux进程的虚拟地址空间(其他Unix系统的设计也与此类似)。在Linux中，地址空间最上面的区域是保留给操作系统中的代码和数据的，这对所有进程来说都一样。地址空间的底部区域存放用户进程定义的代码和数据。图中的地址是从下往上增大的。<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/24/s6u5UnTl.png"                      alt="Pasted image 20240322170742.png"                ><br>每个进程看到的虚拟地址空间由大量准确定义的区构成，每个区都有专门的功能。先做简单的了解，逐步向上介绍</p><ul><li><strong>程序代码和数据</strong>：对所有的进程来说，代码是从同一固定地址开始，紧接着的是C全局变量相对应的数据位置。代码和数据区是直接按照可执行目标文件的内容初始化的，在示例中就是可执行文件hello。</li><li><strong>堆</strong>：代码和数据区后紧随的是运行时堆。代码和数据区在进程一开始运行时就被指定了大小，与此不同，当调用像malloc和free这样的C标准库函数的时候，堆可以在运行时动态地扩展和收缩。</li><li><strong>共享库</strong>：大约在地址空间的中间部分是一块用来存放像C标准库和数学库这样的共享库的代码和数据的区域。共享库的概念非常强大，也相当难懂。</li><li><strong>栈</strong>：位于用户虚拟地址空间顶部的是<strong>用户栈</strong>，编译器用它来实现函数调用。和堆一样，用户栈在程序执行期间可以动态地扩展和收缩。特别的，每次我们调用一个函数时，栈就会增长；从一个函数返回时，栈就会收缩。</li><li><strong>内核虚拟内存</strong>：地址空间顶部的区域是为内核保留的。不允许应用程序读写这个区域的内容或者直接调用内核代码定义的函数。相反，它们必须调用内核来执行这些操作。</li></ul><p>虚拟内存的运作需要硬件和操作系统软件之间精密复杂的交互，包括对处理器生成的每个地址的硬件翻译。基本思想是把一个进程虚拟内存存储在磁盘上，然后用主存作为磁盘的高速缓存。</p><h4 id="1-7-4-文件"><a href="#1-7-4-文件" class="headerlink" title="1.7.4 文件"></a>1.7.4 文件</h4><p><strong>文件</strong>就是字节序列，仅此而已。每个I&#x2F;O设备，包括磁盘、键盘、显示器甚至网络，都可以看成是文件。系统中的所有输入输出都是通过使用一小组称为Unix I&#x2F;O的系统调用读写文件来实现的。</p><p>文件这个简单而精致的概念是十分强大的，因为它向应用程序提供了一个统一的视图，来看待系统中可能含有的所有各式各样的I&#x2F;O设备。例如，处理磁盘文件内容的应用程序员可以非常幸福，因为他们无需了解具体的磁盘技术。进一步说，同一个程序可以在使用不同磁盘技术的不同系统上运行。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;从hello的例子可以可以看出来，当shell加载运行包括最后输出的时候，shell和hello都没有直接对硬件进行访问(包括键盘，显示器，主存或者磁盘)。取而代之的是，他们依靠操作系统提供的服务。我们可以把操作系统看成是应用程序和硬件之间插入的一层软件。所有应用程序对硬件</summary>
      
    
    
    
    <category term="CSAPP" scheme="https://primeluoqiu.github.io/categories/CSAPP/"/>
    
    
  </entry>
  
  <entry>
    <title>CSAPP Chapter1.6 存储设备形成也是有结构的</title>
    <link href="https://primeluoqiu.github.io/2024/03/24/CSAPP/%E7%AC%AC%E4%B8%80%E7%AB%A0/1.6%E5%AD%98%E5%82%A8%E8%AE%BE%E5%A4%87%E5%BD%A2%E6%88%90%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/"/>
    <id>https://primeluoqiu.github.io/2024/03/24/CSAPP/%E7%AC%AC%E4%B8%80%E7%AB%A0/1.6%E5%AD%98%E5%82%A8%E8%AE%BE%E5%A4%87%E5%BD%A2%E6%88%90%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/</id>
    <published>2024-03-24T02:51:49.634Z</published>
    <updated>2024-03-24T02:40:48.774Z</updated>
    
    <content type="html"><![CDATA[<p>也就是说，在处理器中和一个较大较慢的设备(例如主存)之间插入要给更小更快的存储设备(例如高缓)的想法已经成为一个普遍的观念。实际上，每个计算机中的存储设备都被组织成了一个存储器层次结构，如图所示<br>![[<a class="link"   href="https://hansimov.gitbook.io/~gitbook/image?url=https://4154149387-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%252F-MHt_spaxGgCbp2POnfq%252F-MHzhX2vrq6mFP3tN9EU%252F-MHzi1Edm9hUsnQdAkkL%252F01-09%2520%25E4%25B8%2580%25E4%25B8%25AA%25E5%25AD%2598%25E5%2582%25A8%25E5%2599%25A8%25E5%25B1%2582%25E6%25AC%25A1%25E7%25BB%2593%25E6%259E%2584%25E7%259A%2584%25E7%25A4%25BA%25E4%25BE%258B.png?alt=media&token=afb8208e-17dc-475f-9f61-acf0bd0ca891&width=400&dpr=3&quality=100&sign=17fc4e7af9f4033010d24045648add7168e149dc6885e9e1a1730033b06fd7f2%5D%5D" >https://hansimov.gitbook.io/~gitbook/image?url=https:%2F%2F4154149387-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-legacy-files%2Fo%2Fassets%252F-MHt_spaxGgCbp2POnfq%252F-MHzhX2vrq6mFP3tN9EU%252F-MHzi1Edm9hUsnQdAkkL%252F01-09%2520%25E4%25B8%2580%25E4%25B8%25AA%25E5%25AD%2598%25E5%2582%25A8%25E5%2599%25A8%25E5%25B1%2582%25E6%25AC%25A1%25E7%25BB%2593%25E6%259E%2584%25E7%259A%2584%25E7%25A4%25BA%25E4%25BE%258B.png%3Falt=media%26token=afb8208e-17dc-475f-9f61-acf0bd0ca891&amp;width=400&amp;dpr=3&amp;quality=100&amp;sign=17fc4e7af9f4033010d24045648add7168e149dc6885e9e1a1730033b06fd7f2]] <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br>在这个层次结构中，从上到下，设备之间的访问速度越来越慢，容量越来越大，并且每字节的造价也越来越低。寄存器文件在层次结构中位于最顶层，也就是第0级或者L0，主存在第4存…</p><p>存储器层次结构的主要思想是上一层的存储器作为低一层存储器的高速缓存。因此寄存器文件就是L1的高速缓存，L1是L2的高速缓存..在某些具有分布式文件系统的网络系统中，本地磁盘就是存储在其他系统中磁盘上的数据的高速缓存。正如可以运用不同的高速缓存的知识来提高程序性能一样，程序员同样可以利用对整个存储器层次结构的理解来提高程序性能。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;也就是说，在处理器中和一个较大较慢的设备(例如主存)之间插入要给更小更快的存储设备(例如高缓)的想法已经成为一个普遍的观念。实际上，每个计算机中的存储设备都被组织成了一个存储器层次结构，如图所示&lt;br&gt;![[&lt;a class=&quot;link&quot;   href=&quot;https://h</summary>
      
    
    
    
    <category term="CSAPP" scheme="https://primeluoqiu.github.io/categories/CSAPP/"/>
    
    
  </entry>
  
  <entry>
    <title>CSAPP Chapter1.5 多来点高速缓存嘛</title>
    <link href="https://primeluoqiu.github.io/2024/03/24/CSAPP/%E7%AC%AC%E4%B8%80%E7%AB%A0/1.5%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E8%87%B3%E5%85%B3%E9%87%8D%E8%A6%81/"/>
    <id>https://primeluoqiu.github.io/2024/03/24/CSAPP/%E7%AC%AC%E4%B8%80%E7%AB%A0/1.5%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E8%87%B3%E5%85%B3%E9%87%8D%E8%A6%81/</id>
    <published>2024-03-24T02:51:49.633Z</published>
    <updated>2024-03-24T02:40:19.983Z</updated>
    
    <content type="html"><![CDATA[<p>上述简单的运行过程中，我们不难发现系统花费了大量的时间把信息从一个地方挪到另一个地方。例如hello最初放在磁盘上，当程序加载的时候，被复制到主存，最后从主存上复制到显示设备。复制总是需要随时间的。这些复制就是开销，所以系统设计者的一个主要目标就是使这些复制操作尽可能快的完成。</p><p>根据机械原理，较大的存储设备要比比较小的存储设备运行的慢，而快速设备的造价远高于同类的低速设备，比如说，一个典型系统上的磁盘驱动器可能比主存大1000倍，但是对处理器而言，从磁盘驱动器上读取一个字的时间开销要比从主存中的开销大1000万倍。</p><p>类似得，一个典型的寄存器文件只存储几百byte的信息，而主存里面可以存放几十亿字节。然而，处理器从寄存器文件中读数据比从主存中读取几乎要快100倍，而且随着半导体技术的进步，处理器和主存之间的差距还在增大。加快处理器的运行速度比加快主存的运行速度要容易和便宜得多。针对这种处理器和主存之间的差异，系统设计者就采用了更小更快的存储设备，称为<strong>高速缓存存储器</strong>(cache memory, 简称cache或高速缓存)，作为暂时的集结区域，存放处理器近期可能需要的信息。<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/24/Z51UmPNz.png"                      alt="Pasted image 20240318151011.png"                ><br>这是一个典型系统中的高速缓存存储器，位于CPU上的L1高速缓存的荣富良可以达到数万字节。访问速度几乎和访问寄存器文件一样快。一个容量为数十万到百万字节的更大的L2告诉换曾黁通过一条特殊的总线连接到CPU。</p><p>进程访问L2高速缓存的时间要比访问L1告诉换从的时间长5倍，但是这仍然比访问主存的时间快5-10倍。L1和L2告诉换从使用一种叫做<strong>静态随机访问存储器</strong>的硬件技术实现的。比较新的，处理能力更强大的系统甚至有三级高速缓存：L1、L2、L3.系统可以获得一个很大的存储器，同时访问速度也很快，原因是利用了高速缓存的局部性原理，即<strong>程序具有访问局部区域里的数据和代码的趋势</strong>。通过让高速缓存里存放可能经常访问的数据，大部分的内存操作都能在快速的高速缓存中完成。<br>![[Pasted image 20240318151738.png]]</p><p>本书得出的重要结论之一就是，意识到高速缓存存储器存在的应用程序员能够利用高速缓存将程序的的性能提升一个数量级。</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;上述简单的运行过程中，我们不难发现系统花费了大量的时间把信息从一个地方挪到另一个地方。例如hello最初放在磁盘上，当程序加载的时候，被复制到主存，最后从主存上复制到显示设备。复制总是需要随时间的。这些复制就是开销，所以系统设计者的一个主要目标就是使这些复制操作尽可能快的完</summary>
      
    
    
    
    <category term="CSAPP" scheme="https://primeluoqiu.github.io/categories/CSAPP/"/>
    
    
  </entry>
  
  <entry>
    <title>CSAPP Chapter1.3 处理器是干嘛的</title>
    <link href="https://primeluoqiu.github.io/2024/03/24/CSAPP/%E7%AC%AC%E4%B8%80%E7%AB%A0/1.4%E5%A4%84%E7%90%86%E5%99%A8%E8%AF%BB%E5%B9%B6%E8%A7%A3%E9%87%8A%E5%82%A8%E5%AD%98%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E6%8C%87%E4%BB%A4/"/>
    <id>https://primeluoqiu.github.io/2024/03/24/CSAPP/%E7%AC%AC%E4%B8%80%E7%AB%A0/1.4%E5%A4%84%E7%90%86%E5%99%A8%E8%AF%BB%E5%B9%B6%E8%A7%A3%E9%87%8A%E5%82%A8%E5%AD%98%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E6%8C%87%E4%BB%A4/</id>
    <published>2024-03-24T02:51:49.632Z</published>
    <updated>2024-03-24T02:39:50.330Z</updated>
    
    <content type="html"><![CDATA[<p>在我们创建完hello的可执行文件之后，用shell运行如下</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">linux &gt; ./hello</span><br><span class="line">hello, world</span><br><span class="line">linux &gt;</span><br></pre></td></tr></table></figure></div><p>shell是一个命令行解释器，它输出一个提示符，然后等待一个命令行，执行这个命令。如果命令行第一个单词不是一个内置的指令，那么它就会假设这是一个可执行文件的名字，它将加载并运行这个文件。此例中，加载运行了hello，然后等待程序终止，输出消息，然后终止。然后输出一个提示符，等待下一个输入。</p><h3 id="1-4-1-系统的硬件组成"><a href="#1-4-1-系统的硬件组成" class="headerlink" title="1.4.1 系统的硬件组成"></a>1.4.1 系统的硬件组成</h3><h4 id="1-总线"><a href="#1-总线" class="headerlink" title="1.总线"></a>1.总线</h4><p>也就贯穿整个系统的一组电子管道。携带信息字节并在各个部件间传递。通常总线被设计成传送定长的字节块，也就是字。字中的字节数（即字长）是一个基本的系统参数，各个系统中都不尽相同。现在的的大多数机器字长是4或8字节32&#x2F;64位。</p><h4 id="2-I-O设备"><a href="#2-I-O设备" class="headerlink" title="2.I&#x2F;O设备"></a>2.I&#x2F;O设备</h4><p>这是系统和外部世界的联系通道。示例系统包括四个I&#x2F;O设备：作为用户输入的键盘和鼠标，作为用户输出的显示器，以及用于长期存储数据和程序的磁盘驱动器。最开始的hello就存放在磁盘上。</p><p>每个I&#x2F;O都通过以一个<strong>控制器或适配器</strong>与I&#x2F;O总线相连。控制器和适配器之间的的区别而在于他们的<strong>封装方式</strong>。控制器是I&#x2F;O设备本身或者系统的主印制电路板(主板)上的芯片组。而适配器是一块插在主板插槽上的卡。这些设备的功能都是在I&#x2F;O总线和I&#x2F;O设备之间传递信息·<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/24/CLnPwRdz.png"                      alt="Pasted image 20240315143111.png"                ></p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALU:算数/逻辑单元 PC：程序计数器 USB：通用串行总线</span><br></pre></td></tr></table></figure></div><h4 id="3-主存"><a href="#3-主存" class="headerlink" title="3.主存"></a>3.主存</h4><p><strong>主存</strong>是一个临时存储设备，在处理器执行程序时，用来存放程序和程序处理的数据。从物理上来说，主存是由一组<strong>动态随机存储器(DRAM)</strong> 芯片组成的。从逻辑上来说，存储器是一个线性的字节数组，每个字节都有其唯一的地址(数组索引)，这些地址是从零开始的。一般来说，组成程序的每条机器指令都由不同数量的字节构成。一般来说，组成程序的每条机器指令都有不同数量的字节构成。与C程序变量相对应的数据项大小是根据类型变化的。</p><h4 id="4-处理器"><a href="#4-处理器" class="headerlink" title="4.处理器"></a>4.处理器</h4><p>中央处理单元(CPU),简称<strong>处理器</strong>，是解释(或执行)存储在主存中指令的引擎。处理器的核心是一个大小为一个字的存储设备(或<strong>寄存器</strong>) ，称为<strong>程序计数器&#x2F;指令计数器</strong>(PC)。在任何时刻，PC都指向主存中某条机器语言指令(即含有该条指令的地址)</p><p>从系统通电开始到断电，处理器一直在不断地执行程序计数器指向的指令，再更新程序计数器，使其指向下一条指令。处理器看上去是按照一个非常简单的指令执行模型来操作的，这个模型是由指令集架构(Arm, x86,)决定的。<strong>在这个模型中，指令按照严格的顺序执行，而执行一条指令包含执行一系列的步骤。处理器从程序计数器指向的内存处读取指令，解释指令中的位，执行该指令指示的简单操作，然后更新PC，使其指向下一条指令，而这条指令并不一定和在内存中刚刚执行的指令相邻。</strong></p><p>这样的简单操作并不多，它们围绕着主存、寄存器文件和算数&#x2F;逻辑单元进行。寄存器文件是个小的存储设备，由一些单个字长的寄存器组成，每个寄存器都有唯一的名字。ALU计算新的数据和地址值。下面是一些简单操作的例子，CPU在指令的要求下可能会执行这些操作</p><ul><li>加载：从主存复制一个字节或者一个字到寄存器，以覆盖寄存器原来的内容。</li><li>存储：从寄存器复制一个字节或者一个字到主存的某个位置，以覆盖这个位置上原有的内容</li><li>操作：把两个寄存器的内容复制到ALU，ALU对这两个字做算术运算，并将结果存放到一个寄存器中，以覆盖该寄存器中原来的内容</li><li>跳转：从指令本身中抽取一个字，并将这个字复制到PC中，以覆盖PC中原来的值</li></ul><p>处理器看上去是它的指令集架构的简单实现，但是实际上现代处理器使用了非常复杂的机制来加速程序的执行。因此，我们将处理器的指令集架构和处理器的微体系结构区分开来：指令集架构描述的是每条机器代码指令的效果；而微体系结构描述的是处理器实际上是如何实现的。</p><h3 id="1-4-2运行Hello程序"><a href="#1-4-2运行Hello程序" class="headerlink" title="1.4.2运行Hello程序"></a>1.4.2运行Hello程序</h3><p>目前先暂时省略一些细节。</p><p>起初，shell程序执行它的指令，等待我们输入一个命令。当我们在键盘上输入字符串”.&#x2F;hello”后，shell程序将字符逐一读入寄存器，再把它存放到内存中。如下图所示<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/24/UPG9V8JH.png"                      alt="Pasted image 20240316001811.png"                ></p><p>当我们在键盘上敲回车键之后，shell程序就知道我们已经结束了命令的输入，然后shell执行一系列指令来加载可执行的hello文件，这些指令将hello目标文件中的代码和数据从磁盘复制到主存。数据包括最后会被输出的字符串”hello, world\n”</p><p>利用直接存储器存取(DMA)技术，数据可以不通过处理器而直接从磁盘到达主存。这个步骤如下图所示<br>![[<a class="link"   href="https://hansimov.gitbook.io/~gitbook/image?url=https://4154149387-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%252F-MHt_spaxGgCbp2POnfq%252F-MHzfLHp5XFUFTsUJAKx%252F-MHzfN_gwQJSG2YnC5Gk%252F01-06%2520%25E4%25BB%258E%25E7%25A3%2581%25E7%259B%2598%25E5%258A%25A0%25E8%25BD%25BD%25E5%258F%25AF%25E6%2589%25A7%25E8%25A1%258C%25E6%2596%2587%25E4%25BB%25B6%25E5%2588%25B0%25E4%25B8%25BB%25E5%25AD%2598.png?alt=media&token=9a49507e-f20d-4af8-b277-bebf57cc597f&width=400&dpr=3&quality=100&sign=74b6cf3ac9a458f0c5b3b6cbc5920a9cd3dcc59d6250e0badd63c26859b486f3%5D%5D" >https://hansimov.gitbook.io/~gitbook/image?url=https:%2F%2F4154149387-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-legacy-files%2Fo%2Fassets%252F-MHt_spaxGgCbp2POnfq%252F-MHzfLHp5XFUFTsUJAKx%252F-MHzfN_gwQJSG2YnC5Gk%252F01-06%2520%25E4%25BB%258E%25E7%25A3%2581%25E7%259B%2598%25E5%258A%25A0%25E8%25BD%25BD%25E5%258F%25AF%25E6%2589%25A7%25E8%25A1%258C%25E6%2596%2587%25E4%25BB%25B6%25E5%2588%25B0%25E4%25B8%25BB%25E5%25AD%2598.png%3Falt=media%26token=9a49507e-f20d-4af8-b277-bebf57cc597f&amp;width=400&amp;dpr=3&amp;quality=100&amp;sign=74b6cf3ac9a458f0c5b3b6cbc5920a9cd3dcc59d6250e0badd63c26859b486f3]] <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br>一旦目标文件hello中的代码和数据被加载到主存，处理器就开始执行hello程序的main程序中的机器语言指令。这些指令将”Hello,world\n”字符串中的字节从主存复制到寄存器文件，再从寄存器文件中复制到显示设备，最终显示在屏幕上。步骤如下所示<br>![[<a class="link"   href="https://hansimov.gitbook.io/~gitbook/image?url=https://4154149387-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%252F-MHt_spaxGgCbp2POnfq%252F-MHzfVZwd5iIwJfDkOPj%252F-MHzffvOB90toXVTON5G%252F01-07%2520%25E5%25B0%2586%25E8%25BE%2593%25E5%2587%25BA%25E5%25AD%2597%25E7%25AC%25A6%25E4%25B8%25B2%25E4%25BB%258E%25E5%25AD%2598%25E5%2582%25A8%25E5%2599%25A8%25E5%2586%2599%25E5%2588%25B0%25E6%2598%25BE%25E7%25A4%25BA%25E5%2599%25A8.png?alt=media&token=d0480c36-9640-4159-bc71-8f5db262a6ba&width=400&dpr=3&quality=100&sign=a45f19ed618ab752f842b7f269e3b6411ec8fa6f81166c73190f0156510d0c4a%5D%5D" >https://hansimov.gitbook.io/~gitbook/image?url=https:%2F%2F4154149387-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-legacy-files%2Fo%2Fassets%252F-MHt_spaxGgCbp2POnfq%252F-MHzfVZwd5iIwJfDkOPj%252F-MHzffvOB90toXVTON5G%252F01-07%2520%25E5%25B0%2586%25E8%25BE%2593%25E5%2587%25BA%25E5%25AD%2597%25E7%25AC%25A6%25E4%25B8%25B2%25E4%25BB%258E%25E5%25AD%2598%25E5%2582%25A8%25E5%2599%25A8%25E5%2586%2599%25E5%2588%25B0%25E6%2598%25BE%25E7%25A4%25BA%25E5%2599%25A8.png%3Falt=media%26token=d0480c36-9640-4159-bc71-8f5db262a6ba&amp;width=400&amp;dpr=3&amp;quality=100&amp;sign=a45f19ed618ab752f842b7f269e3b6411ec8fa6f81166c73190f0156510d0c4a]] <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在我们创建完hello的可执行文件之后，用shell运行如下&lt;/p&gt;
&lt;div class=&quot;highlight-container&quot; data-rel=&quot;Plaintext&quot;&gt;&lt;figure class=&quot;iseeu highlight plaintext&quot;&gt;&lt;table</summary>
      
    
    
    
    <category term="CSAPP" scheme="https://primeluoqiu.github.io/categories/CSAPP/"/>
    
    
  </entry>
  
  <entry>
    <title>CSAPP Chapter1.3 了解编译系统如何工作是大有益处的</title>
    <link href="https://primeluoqiu.github.io/2024/03/24/CSAPP/%E7%AC%AC%E4%B8%80%E7%AB%A0/1.3%E4%BA%86%E8%A7%A3%E7%BC%96%E8%AF%91%E7%B3%BB%E7%BB%9F%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E6%98%AF%E5%A4%A7%E6%9C%89%E7%9B%8A%E5%A4%84%E7%9A%84/"/>
    <id>https://primeluoqiu.github.io/2024/03/24/CSAPP/%E7%AC%AC%E4%B8%80%E7%AB%A0/1.3%E4%BA%86%E8%A7%A3%E7%BC%96%E8%AF%91%E7%B3%BB%E7%BB%9F%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E6%98%AF%E5%A4%A7%E6%9C%89%E7%9B%8A%E5%A4%84%E7%9A%84/</id>
    <published>2024-03-24T02:51:49.631Z</published>
    <updated>2024-03-24T02:25:47.980Z</updated>
    
    <content type="html"><![CDATA[<p>益处大致有三点</p><ul><li><strong>优化程序性能</strong>。尽管已经无需为了写出高效代码而了解编译器的内部工作。不过为了在C中做出更好对的编码选择，我们确实需要了解一些机器代码以及编译器将不同的C转化成机器代码的方式。例如在C语言程序中有<code>if-else</code>和<code>switch</code>两种语句。那么这两种哪个更高效呢，while和for之间哪个更有效呢？这些都是可以得到了解的</li><li><strong>理解链接时出现的错误</strong>。根据经验来讲，一些令人困扰的程序错误往往都与链接器操作有关，尤其是试图构建大型的软件系统时。例如链接器报告说无法解析一个引用，这是什么意思？静态变量和全局变量的区别是什么等一系列问题</li><li><strong>避免安全漏洞</strong>。多年来，缓冲区溢出错误时造成大多数网络和Internet服务器上安全漏洞的主要原因。存在这些错误是因为很少有程序员能够理解需要限制从不受信任的源接受数据的数量和格式。 学习安全编程的第一步就是理解数据和控制信息存储在程序栈上的方式会引起的后果。等</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;益处大致有三点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;优化程序性能&lt;/strong&gt;。尽管已经无需为了写出高效代码而了解编译器的内部工作。不过为了在C中做出更好对的编码选择，我们确实需要了解一些机器代码以及编译器将不同的C转化成机器代码的方式。例如在C语言程序中有&lt;co</summary>
      
    
    
    
    <category term="CSAPP" scheme="https://primeluoqiu.github.io/categories/CSAPP/"/>
    
    
  </entry>
  
  <entry>
    <title>CSAPP Chapter1.2 程序被其他程序翻译成不同的格式</title>
    <link href="https://primeluoqiu.github.io/2024/03/24/CSAPP/%E7%AC%AC%E4%B8%80%E7%AB%A0/1.2%E7%A8%8B%E5%BA%8F%E8%A2%AB%E5%85%B6%E4%BB%96%E7%A8%8B%E5%BA%8F%E7%BF%BB%E8%AF%91%E6%88%90%E4%B8%8D%E5%90%8C%E7%9A%84%E6%A0%BC%E5%BC%8F/"/>
    <id>https://primeluoqiu.github.io/2024/03/24/CSAPP/%E7%AC%AC%E4%B8%80%E7%AB%A0/1.2%E7%A8%8B%E5%BA%8F%E8%A2%AB%E5%85%B6%E4%BB%96%E7%A8%8B%E5%BA%8F%E7%BF%BB%E8%AF%91%E6%88%90%E4%B8%8D%E5%90%8C%E7%9A%84%E6%A0%BC%E5%BC%8F/</id>
    <published>2024-03-24T02:51:49.630Z</published>
    <updated>2024-03-24T02:36:29.315Z</updated>
    
    <content type="html"><![CDATA[<p>为了在系统上运行Hello.c程序，每条C语句必须被其他程序转化成一系列的低级机器语言指令。然后这些指令按照一种称为可执行程序的格式打好包，并以二进制磁盘文件的形式存放起来。目标程序也成为可执行目标文件</p><p>高级语言 -&gt; 低级指令 -&gt; 指令打包并以二进制文件存放。</p><p>![[<a class="link"   href="https://hansimov.gitbook.io/~gitbook/image?url=https://4154149387-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%252F-MHt_spaxGgCbp2POnfq%252F-MHzZfEIY91yIzOD0Rce%252F-MHzZpZI-gs8CNcwHIyv%252F01-03%2520compilation%2520systems.png?alt=media&token=91ca688e-1cfc-4ec6-8b99-d52e672bbac7&width=400&dpr=3&quality=100&sign=ad2978e04a286ea0e07b7bbfb5d2a96b78a69a9b23614f1df17e662f4615f344%5D%5D" >https://hansimov.gitbook.io/~gitbook/image?url=https:%2F%2F4154149387-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-legacy-files%2Fo%2Fassets%252F-MHt_spaxGgCbp2POnfq%252F-MHzZfEIY91yIzOD0Rce%252F-MHzZpZI-gs8CNcwHIyv%252F01-03%2520compilation%2520systems.png%3Falt=media%26token=91ca688e-1cfc-4ec6-8b99-d52e672bbac7&amp;width=400&amp;dpr=3&amp;quality=100&amp;sign=ad2978e04a286ea0e07b7bbfb5d2a96b78a69a9b23614f1df17e662f4615f344]] <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><ul><li>预处理阶段，通过以字符#开头的命令，修改原始程序。如<code>#include&lt;iostream&gt;</code>命令就是告诉预处理器读取系统头文件<code>stdio.h</code>的内容，然后直接插入程序文本中。然后得到了另一个C程序，通常以.i作为文件扩展名。</li><li>编译阶段：通过编译器将文本文件翻译成hello.s，也就是汇编语言程序，该程序包含<code>main</code>的定义<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">main:</span><br><span class="line">    subq $8, %rsp</span><br><span class="line">    movl $.LC0, %edi</span><br><span class="line">    call puts</span><br><span class="line">    movl $0, %eax</span><br><span class="line">    addq $8, %rsp</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure></div></li><li>2-7行每条都以一种文本格式描述了一条低级语言指令。(汇编语言为所有不同高级语言的不同编译器提供了通用的输出语言)</li><li>汇编阶段；通过汇编器将hello.s翻译成机器语言指令。把这些指令打包成可重定位目标程序。并保存到hello.o中(这是一个二进制文件)，里面包含的是<code>main</code>的指令代码。</li><li>链接阶段：hello程序调用了printf函数，是标准C库中的一个函数。函数存在于一个名为<code>printf.o</code>的单独的预编译好了的目标文件中，而这个文件必须以某种方式合并到hello.c的程序中，链接器负责合并，结果得到hello文件，是一个可执行文件。可以被加载到内存中，由系统执行。<br>也就是说，一个C程序都是先从预处理阶段开始的，先读取头文件然后插入程序中，然后通过编译器翻译成汇编语言，再通过汇编器翻译成机器语言指令生成hello.o，接下来引入在hello中调用的printf函数，而该函数存在于一个单独编译好的目标文件<code>printf.o</code>中，然后连接器负责合并这两个.o的目标文件，然后最后得出一个可执行文件。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;为了在系统上运行Hello.c程序，每条C语句必须被其他程序转化成一系列的低级机器语言指令。然后这些指令按照一种称为可执行程序的格式打好包，并以二进制磁盘文件的形式存放起来。目标程序也成为可执行目标文件&lt;/p&gt;
&lt;p&gt;高级语言 -&amp;gt; 低级指令 -&amp;gt; 指令打包并以</summary>
      
    
    
    
    <category term="CSAPP" scheme="https://primeluoqiu.github.io/categories/CSAPP/"/>
    
    
  </entry>
  
  <entry>
    <title>CSAPP Chapter1.1 信息就是位+上下文</title>
    <link href="https://primeluoqiu.github.io/2024/03/24/CSAPP/%E7%AC%AC%E4%B8%80%E7%AB%A0/1.1%E4%BF%A1%E6%81%AF%E5%B0%B1%E6%98%AF%E4%BD%8D+%E4%B8%8A%E4%B8%8B%E6%96%87/"/>
    <id>https://primeluoqiu.github.io/2024/03/24/CSAPP/%E7%AC%AC%E4%B8%80%E7%AB%A0/1.1%E4%BF%A1%E6%81%AF%E5%B0%B1%E6%98%AF%E4%BD%8D+%E4%B8%8A%E4%B8%8B%E6%96%87/</id>
    <published>2024-03-24T02:51:49.625Z</published>
    <updated>2024-03-24T02:25:25.510Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一节：信息就是位＋上下文"><a href="#第一节：信息就是位＋上下文" class="headerlink" title="第一节：信息就是位＋上下文"></a>第一节：信息就是位＋上下文</h2><p>我们在创建第一个hello.c的时候，这些文件都是由ASCII码组成的，也就是用一个唯一的单字节大小的值来表示每个字符。而只由ASCII字符构成的文件成为<strong>文本文件</strong>，其他的文件被称为二进制文件。</p><p>这件事说明了一个基本思想：系统中所有的信息都是由一串bit表示的。区分不同数据对象的唯一方法是我们读到这些数据对象时的上下文。例如在不同的上下文中，一个同样的字节序列可能表示一个整数、浮点数、字符串、机器指令。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;第一节：信息就是位＋上下文&quot;&gt;&lt;a href=&quot;#第一节：信息就是位＋上下文&quot; class=&quot;headerlink&quot; title=&quot;第一节：信息就是位＋上下文&quot;&gt;&lt;/a&gt;第一节：信息就是位＋上下文&lt;/h2&gt;&lt;p&gt;我们在创建第一个hello.c的时候，这些文件都是由</summary>
      
    
    
    
    <category term="CSAPP" scheme="https://primeluoqiu.github.io/categories/CSAPP/"/>
    
    
  </entry>
  
  <entry>
    <title>模拟堆</title>
    <link href="https://primeluoqiu.github.io/2024/03/23/Algorithm/duiyouhua/"/>
    <id>https://primeluoqiu.github.io/2024/03/23/Algorithm/duiyouhua/</id>
    <published>2024-03-23T14:13:09.233Z</published>
    <updated>2024-03-23T14:14:47.893Z</updated>
    
    <content type="html"><![CDATA[<h3 id="模拟堆"><a href="#模拟堆" class="headerlink" title="模拟堆"></a>模拟堆</h3><p>接下来看模拟堆，模拟堆比起之前就是多了两个数组，这两个数组属于互为反函数的类型。例如 <code>hp[k] = j</code>那么<code>ph[j] = k</code>，一个是对应着在堆里的下标，另一个对应的是下标对应的值。 那么对应的，在进行交换的时候，就不能只考虑值之间的交换了，就还得考虑数组之间的交换。这个时候，就需要一个全新的函数了</p><p>因为题目中要考虑第k个数，那么就需要两个数组来存储第k个数是什么<br>ph[k]存的是第k个插入的数在堆里的下标是什么,还需要一个hp[k],用来存的是堆的某个点是第几个插入的点。</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap_head</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="built_in">swap</span>(ph[hp[a]], ph[hp[b]]);  </span><br><span class="line">    <span class="built_in">swap</span>(hp[a], hp[b]);  </span><br><span class="line">    <span class="built_in">swap</span>(a, b);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>然后就是把所有的<code>swap</code>函数进行更换为堆里面特有的<code>swap</code>。<br>这个方法不常用，但是djikstra堆优化是常用的，所以要了解一下</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, a, b;</span><br><span class="line"><span class="type">int</span> h[N], cnt, ph[N], hp[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heap_swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">swap</span>(ph[hp[a]], ph[hp[b]]);</span><br><span class="line">    <span class="built_in">swap</span>(hp[a], hp[b]);</span><br><span class="line">    <span class="built_in">swap</span>(h[a], h[b]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = u;</span><br><span class="line">    <span class="keyword">if</span>(u * <span class="number">2</span> &lt;= cnt &amp;&amp; h[u * <span class="number">2</span>] &lt; h[t]) t = u * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(u * <span class="number">2</span> + <span class="number">1</span> &lt;= cnt &amp;&amp; h[u * <span class="number">2</span> + <span class="number">1</span>] &lt; h[t]) t = u * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(u != t)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">heap_swap</span>(u, t);</span><br><span class="line">        <span class="built_in">down</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(u / <span class="number">2</span> &amp;&amp; h[u / <span class="number">2</span>] &gt; h[u])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">heap_swap</span>(u, u / <span class="number">2</span>);</span><br><span class="line">        u &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(n --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> op[<span class="number">10</span>];</span><br><span class="line">        <span class="type">int</span> k, x;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, op);</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(op, <span class="string">&quot;I&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">            cnt ++;</span><br><span class="line">            m ++;</span><br><span class="line">            ph[m] = cnt, hp[cnt] = m;</span><br><span class="line">            h[cnt] = x;</span><br><span class="line">            <span class="built_in">up</span>(cnt);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(op, <span class="string">&quot;PM&quot;</span>)) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, h[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(op, <span class="string">&quot;DM&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">heap_swap</span>(<span class="number">1</span>, cnt);</span><br><span class="line">            cnt --;</span><br><span class="line">            <span class="built_in">down</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(op, <span class="string">&quot;D&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;k);</span><br><span class="line">            k = ph[k];</span><br><span class="line">            <span class="built_in">heap_swap</span>(k, cnt);</span><br><span class="line">            cnt --;</span><br><span class="line">            <span class="built_in">down</span>(k), <span class="built_in">up</span>(k);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;k, &amp;x);</span><br><span class="line">            k = ph[k], h[k] = x;</span><br><span class="line">            <span class="built_in">down</span>(k), <span class="built_in">up</span>(k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;模拟堆&quot;&gt;&lt;a href=&quot;#模拟堆&quot; class=&quot;headerlink&quot; title=&quot;模拟堆&quot;&gt;&lt;/a&gt;模拟堆&lt;/h3&gt;&lt;p&gt;接下来看模拟堆，模拟堆比起之前就是多了两个数组，这两个数组属于互为反函数的类型。例如 &lt;code&gt;hp[k] = j&lt;/code&gt;那</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://primeluoqiu.github.io/categories/Algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>1.6分组延时、丢失和吞吐量</title>
    <link href="https://primeluoqiu.github.io/2024/03/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.6/"/>
    <id>https://primeluoqiu.github.io/2024/03/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.6/</id>
    <published>2024-03-23T06:21:33.296Z</published>
    <updated>2024-03-23T12:46:00.036Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/23/4XZbDEld.jpg"                      alt="17.jpg"                ><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/23/wc80rluy.jpg"                      alt="18.jpg"                ><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/23/mMM91mwr.jpg"                      alt="19.jpg"                ><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/23/o4jbDSvk.jpg"                      alt="20.jpg"                ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;https://img2.imgtp.com</summary>
      
    
    
    
    <category term="计网" scheme="https://primeluoqiu.github.io/categories/%E8%AE%A1%E7%BD%91/"/>
    
    
  </entry>
  
  <entry>
    <title>1.5Internet结构和ISP</title>
    <link href="https://primeluoqiu.github.io/2024/03/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.5/"/>
    <id>https://primeluoqiu.github.io/2024/03/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.5/</id>
    <published>2024-03-23T06:21:32.774Z</published>
    <updated>2024-03-23T06:28:30.826Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/23/Y36VrbMf.jpg"                      alt="13.jpg"                ><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/23/FG8Br175.jpg"                      alt="14.jpg"                ><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/23/ZJyEJEkW.jpg"                      alt="15.jpg"                ><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/23/tjVTjn0e.jpg"                      alt="16.jpg"                ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;https://img2.imgtp.com</summary>
      
    
    
    
    <category term="计网" scheme="https://primeluoqiu.github.io/categories/%E8%AE%A1%E7%BD%91/"/>
    
    
  </entry>
  
  <entry>
    <title>1.4接入网和网络媒体</title>
    <link href="https://primeluoqiu.github.io/2024/03/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.4/"/>
    <id>https://primeluoqiu.github.io/2024/03/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.4/</id>
    <published>2024-03-23T06:21:32.245Z</published>
    <updated>2024-03-23T06:28:32.286Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/23/uWbuUjGi.jpg"                      alt="9.jpg"                ><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/23/N5GvtHel.jpg"                      alt="10.jpg"                ><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/23/lppuK39o.jpg"                      alt="11.jpg"                ><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/23/kfjGSqA1.jpg"                      alt="12.jpg"                ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;https://img2.imgtp.com</summary>
      
    
    
    
    <category term="计网" scheme="https://primeluoqiu.github.io/categories/%E8%AE%A1%E7%BD%91/"/>
    
    
  </entry>
  
  <entry>
    <title>1.3网络核心</title>
    <link href="https://primeluoqiu.github.io/2024/03/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.3/"/>
    <id>https://primeluoqiu.github.io/2024/03/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.3/</id>
    <published>2024-03-23T06:21:31.662Z</published>
    <updated>2024-03-23T06:28:32.926Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/23/3d5Unwa7.jpg"                      alt="5.jpg"                ><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/23/5hqppVMQ.jpg"                      alt="6.jpg"                ><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/23/PaiZxOFi.jpg"                      alt="7.jpg"                ><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/23/QaC6Sdnu.jpg"                      alt="8.jpg"                ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;https://img2.imgtp.com</summary>
      
    
    
    
    <category term="计网" scheme="https://primeluoqiu.github.io/categories/%E8%AE%A1%E7%BD%91/"/>
    
    
  </entry>
  
  <entry>
    <title>1.2网络边缘</title>
    <link href="https://primeluoqiu.github.io/2024/03/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.2/"/>
    <id>https://primeluoqiu.github.io/2024/03/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.2/</id>
    <published>2024-03-23T06:21:30.368Z</published>
    <updated>2024-03-23T06:28:33.782Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/23/t3uhqPrU.jpg"                      alt="3.jpg"                ><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/23/mZeqzUZB.jpg"                      alt="4.jpg"                ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;https://img2.imgtp.com</summary>
      
    
    
    
    <category term="计网" scheme="https://primeluoqiu.github.io/categories/%E8%AE%A1%E7%BD%91/"/>
    
    
  </entry>
  
  <entry>
    <title>1.1什么是Internet</title>
    <link href="https://primeluoqiu.github.io/2024/03/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.1%E4%BB%80%E4%B9%88%E6%98%AFInternet/"/>
    <id>https://primeluoqiu.github.io/2024/03/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.1%E4%BB%80%E4%B9%88%E6%98%AFInternet/</id>
    <published>2024-03-23T06:15:09.395Z</published>
    <updated>2024-03-23T06:28:38.121Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/23/y5YJlSvM.jpg"                      alt="微信图片_20240323140956.jpg"                ><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/23/y5YJlSvM.jpg"                      alt="微信图片_20240323140956.jpg"                ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;https://img2.imgtp.com</summary>
      
    
    
    
    <category term="计网" scheme="https://primeluoqiu.github.io/categories/%E8%AE%A1%E7%BD%91/"/>
    
    
  </entry>
  
  <entry>
    <title>CS61A.Chapter1</title>
    <link href="https://primeluoqiu.github.io/2024/03/23/ClassesFormUCBerkely/CS61A/%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0%E6%9E%84%E9%80%A0%E6%8A%BD%E8%B1%A1/"/>
    <id>https://primeluoqiu.github.io/2024/03/23/ClassesFormUCBerkely/CS61A/%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0%E6%9E%84%E9%80%A0%E6%8A%BD%E8%B1%A1/</id>
    <published>2024-03-22T16:54:16.698Z</published>
    <updated>2024-03-23T12:51:07.757Z</updated>
    
    <content type="html"><![CDATA[<p>之所以计算机科学的巨大生产力能够成为可能，都是因为其建立在一套优雅而强大的基本思想之上。所有计算都始于三点：信息的表示、处理的逻辑、设计抽象来管理逻辑的复杂性，掌握这些基础知识需要我们去精确理解计算机程序的构造和解释。</p><h3 id="1-1-4-第一个例子"><a href="#1-1-4-第一个例子" class="headerlink" title="1.1.4 第一个例子"></a>1.1.4 第一个例子</h3><p>Python内置了一些常见编程功能，例如处理文本，显示图形以及通过互联网进行通信。下面这行Python代码</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> urlib.request <span class="keyword">import</span> urlopen</span><br></pre></td></tr></table></figure></div><p>是一个<code>import</code>语句，它会导入一个用于”访问互联网数据”的功能，该功能特别提供了一个名为<code>urlopen</code>的函数，可以访问URL上的内容</p><h4 id="语句和表达式"><a href="#语句和表达式" class="headerlink" title="语句和表达式"></a>语句和表达式</h4><p>Python代码由表达式和语句组成，从广义上讲，计算机程序由一下指令组成</p><ol><li>计算一些值</li><li>执行一些操作<br>语句通常描述操作，Python解释器每执行一条语句，计算机就会执行相应的操作。另外，表达式通常用于描述计算，当Python计算一个表达式时，它会计算出该式的值。</li></ol><p>下面的赋值语句</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shakespeare = urlopen(<span class="string">&#x27;https://www.composingprograms.com/shakespeare.txt&#x27;</span>)</span><br></pre></td></tr></table></figure></div><p>将名称<code>shakespeare</code>与<code>=</code>后面的表达式的值相连，这个表达式将<code>urlopen</code>函数应用在了一个URL身上。</p><p><strong>函数</strong>: 函数封装了操作数据的逻辑。<code>urlopen</code>就是一个函数，而网址是一个数据，莎士比亚的戏剧是另一个数据。从前者到后者的准换过程可能会很复杂，但我们可以将这种复杂性隐藏在一个函数中，从而能够使用一个简单的表达式来跳过该过程。函数是本章的主题</p><p>另一个赋值语句</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>words = <span class="built_in">set</span>(shakespare.read().decode().split())</span><br></pre></td></tr></table></figure></div><p>将<code>words</code>与莎士比亚戏剧中出现的共33721个单词的集合相连。其命令链调用了<code>read</code>、<code>decode</code>、<code>split</code>，每个函数都会操作一个中间的计算实体：从URL中<code>read</code>(读取)数据，然后将数据<code>decode</code>(解码)为文本，最后将文本<code>split</code>(拆分)为单词放在一个<code>set</code>中。</p><p><strong>对象</strong>:<code>set</code>就是一种对象，支持如计算交际和集合关系(membership)等计算。对象无缝整合了数据以及用于操作该数据的逻辑，并隐藏了二者的复杂性对象是第二章的主题</p><p>最后，这个表达式</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;w <span class="keyword">for</span> w <span class="keyword">in</span> words <span class="keyword">if</span> <span class="built_in">len</span>(W) == <span class="number">6</span> <span class="keyword">and</span> w[::<span class="number">1</span>] <span class="keyword">in</span> words&#125;  </span><br><span class="line">&#123;<span class="string">&#x27;redder&#x27;</span>, <span class="string">&#x27;drawer&#x27;</span>, <span class="string">&#x27;reward&#x27;</span>, <span class="string">&#x27;diaper&#x27;</span>, <span class="string">&#x27;repaid&#x27;</span>&#125;</span><br></pre></td></tr></table></figure></div><p>是一个符合表达式，它的计算结果是反向拼写同时也为单词的莎士比亚单词集合。神秘符号<code>w[::-1]</code>表示枚举单词中的每个字母，其中-1代表反向枚举，当在交互式对话中输入表达式时，Python会在下一行打印值。</p><p><strong>解释器</strong>：符合表达式的求解需要以一个可预测的方式来精确解释代码的过程。实现在这样的过程，用于计算复合表达式的程序就称为解释器。解释器的设计和实现是第三章的主题</p><p>与其他计算机程序相比，编程语言的解释器具有独特的通用性。Python在设计时并不会考虑莎士比亚，但它的高度灵活性使我们能够只用少量的语句和表达式来处理大量的文本。</p><p>最后，这些核心概念都是紧密相关的：函数是对象，对象是函数，解释器是二者的实例。但是，清楚的理解每一个概念及其在组织代码中的作用对于掌握编程艺术至关重要。</p><hr><h3 id="1-1-5-ERROR-Python"><a href="#1-1-5-ERROR-Python" class="headerlink" title="1.1.5 ERROR Python"></a>1.1.5 ERROR Python</h3><p>正在等待命令。即使可能还不了解完整的机会和结构，所以总会有一些失误的情况。因为计算机在极其灵活的同时也十分古板，计算机的特性在<strong>斯坦福的入门课程中被描述为</strong></p><p>当尝试使用Python解释器时，计算机的古板会立即显现出来：即使是最小的拼写和格式更改也会导致预料之外的输出和错误。</p><p>学着解释错误和找到错误的原因被称为调试，关于调试的一些指导原则是：</p><ol><li><p><strong>增量测试</strong>：每个编写良好的程序都可以单独测试的小型模块化组件组成。尽快测试已经编写的所有内容，以尽早发现问题并获得对组件的信心。</p></li><li><p><strong>隔离错误</strong>：语句输出中错误常可归因于特定的模块化组件。所以在诊断问题时，先追踪错误到最小的代码片段，然后再试着修复问题</p></li><li><p><strong>检查假设</strong>：解释器会一字不漏地执行指令——不多也不少。当某些代码的行为与程序员假设的行为不匹配时，它们的输出就是不合预期的。明确假设，然后将调试的工作集中在验证假设上。</p></li><li><p><strong>咨询别人</strong>：你不是一个人！如果你不理解错误信息，请询问朋友、老师或者搜索引擎，如果已经找出了一个错误，但却不知道如何更正，可以请其他人查看。</p></li></ol><p>增量测试、模块化设计、明确的假设和团队合作时贯穿本书的主题，希望它们也贯穿你的计算机科学职业生涯。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;之所以计算机科学的巨大生产力能够成为可能，都是因为其建立在一套优雅而强大的基本思想之上。所有计算都始于三点：信息的表示、处理的逻辑、设计抽象来管理逻辑的复杂性，掌握这些基础知识需要我们去精确理解计算机程序的构造和解释。&lt;/p&gt;
&lt;h3 id=&quot;1-1-4-第一个例子&quot;&gt;&lt;a</summary>
      
    
    
    
    <category term="CS61A" scheme="https://primeluoqiu.github.io/categories/CS61A/"/>
    
    
  </entry>
  
</feed>
