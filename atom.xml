<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>秋过冬漫长</title>
  
  <subtitle>没有比脚更长的路,走过去就好了</subtitle>
  <link href="https://primeluoqiu.github.io/atom.xml" rel="self"/>
  
  <link href="https://primeluoqiu.github.io/"/>
  <updated>2024-03-27T14:07:07.517Z</updated>
  <id>https://primeluoqiu.github.io/</id>
  
  <author>
    <name>LuoQiu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>1.4设计函数</title>
    <link href="https://primeluoqiu.github.io/2024/03/27/ClassesFormUCBerkely/CS61A/1.4%20%E8%AE%BE%E8%AE%A1%E5%87%BD%E6%95%B0/"/>
    <id>https://primeluoqiu.github.io/2024/03/27/ClassesFormUCBerkely/CS61A/1.4%20%E8%AE%BE%E8%AE%A1%E5%87%BD%E6%95%B0/</id>
    <published>2024-03-27T14:06:19.040Z</published>
    <updated>2024-03-27T14:07:07.517Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-4-设计函数"><a href="#1-4-设计函数" class="headerlink" title="1.4 设计函数"></a>1.4 设计函数</h1><p>函数是所有程序(无论大小)的基本组成部分，并且是我们使用编程语言来表达计算过程的主要媒介。本节内容是如何设计一个好的函数。</p><p>那么好函数共有的品质就是：它们都强化了”函数就是抽象”理念。</p><ul><li>每个函数应该只负责一个任务，且该任务要用一个简短的名称来识别，并在一行文本中进行描述。按顺序执行多个任务的函数应该分为多个函数。</li><li>不要重复自己(Don’t repeat yourself)是软件工程的核心原则。这个所谓的DRY原则直出，多个代码片段不应该描述重复的逻辑。相反，逻辑应该只实现一次，为其指定一个名称后多次使用。</li><li>定义通用函数。比如作为<code>pow</code>函数的一个特例的平方函数就不在<code>Python</code>库中，因为<code>pow</code>函数可以将数字计算为任意次方。</li></ul><p>这些准则提高了代码的可读性，减少了错误的数量，并且通常最大限度地减少了便携的代码总量。将复杂的任务分解为简洁的功能是一项需要经验才能掌握的技能。不过好在Python提供了多种特性来支持工作</p><h3 id="1-4-1-文档"><a href="#1-4-1-文档" class="headerlink" title="1.4.1 文档"></a>1.4.1 文档</h3><p>函数定义通常包括描述函数的文档，称为”文档字符串 docstring”，它必须在函数体中缩进。文档字符串通常使用三个引号，第一行描述函数的任务，随后的几行可以描述参数并解释函数的意图</p><div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">pressure</span>(<span class="params">v, t, n</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    计算理想气体的压力，单位为帕斯卡</span></span><br><span class="line"><span class="string">     v -- 气体体积，单位为立方米</span></span><br><span class="line"><span class="string">        t -- 绝对温度，单位为开尔文</span></span><br><span class="line"><span class="string">        n -- 气体粒子</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    k = <span class="number">1.38</span>e - <span class="number">23</span>  <span class="comment">#玻尔兹曼常数</span></span><br><span class="line">    <span class="keyword">return</span> n * k * t / v </span><br></pre></td></tr></table></figure></div><p>当你使用函数名称作为参数调用<code>help</code>时，你会看到它的文档字符串(键入<code>q</code>以退出Python help)。</p><div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">help</span>(pressure)</span><br></pre></td></tr></table></figure></div><p>编写Python程序时，除了最简单的函数之外，都要包含文档字符串。要记住，虽然代码只编写一次，但是会在之后阅读多次。Python文档包含了文档字符串准则，它会在不同的Python项目中保持一致。</p><p>注释：Python中的注释可以附加到<code>#</code>号后的行尾。例如，上面代码中的<code>#</code>后面的注释描述了k变量的含义。这些注释不会出现在Python的<code>help</code>中，而且会被解释器忽略，它们只为了注释而出现</p><hr><h3 id="1-4-2-参数默认值"><a href="#1-4-2-参数默认值" class="headerlink" title="1.4.2 参数默认值"></a>1.4.2 参数默认值</h3><p>定义通用函数的结果是引入了额外的参数。具有许多参数的函数可能调用起来很麻烦并且难以阅读。</p><p>在Python中，我们可以为函数的参数提供默认值。当调用该函数时，具有默认值的参数是可选的。如果未提供，则将默认值绑定到形参上。例如，如果程序通常用于计算”一摩尔”粒子的压力，则可以提供此值作为默认值</p><div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">pressure</span>(<span class="params">v, t, n = <span class="number">6.022e23</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    计算理想气体的压力，单位为帕斯卡</span></span><br><span class="line"><span class="string">     v -- 气体体积，单位为立方米</span></span><br><span class="line"><span class="string">        t -- 绝对温度，单位为开尔文</span></span><br><span class="line"><span class="string">        n -- 气体粒子</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    k = <span class="number">1.38</span>e - <span class="number">23</span>  <span class="comment">#玻尔兹曼常数</span></span><br><span class="line">    <span class="keyword">return</span> n * k * t / v </span><br></pre></td></tr></table></figure></div><p><code>=</code>符号在此等示例中表示两种不同的含义，具体取决于使用它的上下文。在def语句中,<code>=</code>不执行赋值，而是指示调用<code>pressure</code>函数时使用的默认值。相比之下，函数体中对<code>k</code>的赋值语句中将名称<code>k</code>与玻尔兹曼常数的近似值进行了绑定。</p><div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>pressure(<span class="number">1</span>, <span class="number">273.15</span>)</span><br><span class="line"><span class="number">2269.974834</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pressure(<span class="number">1</span>, <span class="number">237.15</span>, <span class="number">3</span> * <span class="number">6.022e23</span>)</span><br><span class="line"><span class="number">6809.924502</span></span><br></pre></td></tr></table></figure></div><p><code>pressure</code>函数的定义接受三个参数，但上面的第一个调用表达式中值提供了两个。在这种情况下，n的值取自<code>def</code>语句的默认值。如果提供了，那么默认值就会被忽略</p><p>作为准则，函数主体中使用的大多数数据值都应该表示为具名参数(named arguments)的默认值，这样会使他们更易于检查，并且可以被函数调用者更改。一些永远不会改变的值，例如基本常量k可以绑定在函数体或全局帧中。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-4-设计函数&quot;&gt;&lt;a href=&quot;#1-4-设计函数&quot; class=&quot;headerlink&quot; title=&quot;1.4 设计函数&quot;&gt;&lt;/a&gt;1.4 设计函数&lt;/h1&gt;&lt;p&gt;函数是所有程序(无论大小)的基本组成部分，并且是我们使用编程语言来表达计算过程的主要媒介。本</summary>
      
    
    
    
    <category term="CS61A" scheme="https://primeluoqiu.github.io/categories/CS61A/"/>
    
    
  </entry>
  
  <entry>
    <title>1.8历史</title>
    <link href="https://primeluoqiu.github.io/2024/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.8/"/>
    <id>https://primeluoqiu.github.io/2024/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.8/</id>
    <published>2024-03-27T12:03:09.041Z</published>
    <updated>2024-03-27T12:10:08.736Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/27/aeIYP5H3.jpg"                      alt="26.jpg"                ><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/27/O4212m1R.jpg"                      alt="27.jpg"                ><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/27/4wlj58Tf.jpg"                      alt="29.jpg"                ><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/27/9i4NYHEt.jpg"                      alt="30.jpg"                ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;https://img2.imgtp.com</summary>
      
    
    
    
    <category term="计网" scheme="https://primeluoqiu.github.io/categories/%E8%AE%A1%E7%BD%91/"/>
    
    
  </entry>
  
  <entry>
    <title>1.3定义新函数</title>
    <link href="https://primeluoqiu.github.io/2024/03/26/ClassesFormUCBerkely/CS61A/1.3%20%E5%AE%9A%E4%B9%89%E6%96%B0%E5%87%BD%E6%95%B0/"/>
    <id>https://primeluoqiu.github.io/2024/03/26/ClassesFormUCBerkely/CS61A/1.3%20%E5%AE%9A%E4%B9%89%E6%96%B0%E5%87%BD%E6%95%B0/</id>
    <published>2024-03-26T05:47:33.393Z</published>
    <updated>2024-03-26T15:37:21.971Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-3定义新函数"><a href="#1-3定义新函数" class="headerlink" title="1.3定义新函数"></a>1.3定义新函数</h1><p>通过对Python的了解，我们确定了强大的编程语言中会有一些必须出现的元素</p><ol><li>原始的内置数据和函数：数字和算术运算</li><li>组合方式：嵌套函数</li><li>受限的抽象方式：将名称与值绑定</li></ol><p>接下来的内容是函数定义，这是一种更强大的抽象技术，通过它可以将名称与复合操作绑定为一个单元。</p><p>首先来研究一下平方的概念。因为平方就是一个数乘它本身。这在Python中可以表示为</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">square</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> mul(x, x)</span><br></pre></td></tr></table></figure></div><p>上述定义了一个名为square的新函数，这个用户定义的函数并不会内置到解释器中，它表示将一个值和自身相乘的复合运算，定义时的括号里的x是作为被乘的东西的名称，称为<strong>形式参数</strong>， 同时也将此函数与<code>square</code>绑定。</p><p><strong>如何定义函数</strong>：函数定义包含<code>def</code>语句、<code>&lt;name 函数名&gt;</code>和一个以逗号分隔的<code>&lt;formal parameters形式参数&gt;</code>列表，然后是一个被称为函数体的<code>return</code>语句，它指定了调用函数时要计算的表达式，也就是函数的<code>&lt;return expression 返回表达式&gt;</code>：</p><div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> &lt;name&gt;(&lt;formal parameters&gt;):</span><br><span class="line">    <span class="keyword">return</span> &lt;<span class="keyword">return</span> expression&gt;</span><br></pre></td></tr></table></figure></div><p>函数的第二行<strong>必须</strong>进行缩进，大多数程序员使用四个空格。返回表达式会作为新定义的函数的一部分存储，并且在最终调用该函数时才进行求值。</p><p>定义了<code>square</code>之后，我们可以调用它：</p><div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>square(<span class="number">21</span>)</span><br><span class="line"><span class="number">441</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>square(add(<span class="number">2</span>, <span class="number">5</span>))</span><br><span class="line"><span class="number">49</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>square(square(<span class="number">3</span>))</span><br><span class="line"><span class="number">81</span></span><br></pre></td></tr></table></figure></div><p>我们还可以将<code>square</code>作为一个建构单元来定义其他函数。例如，我们可以很容易地定义一个函数<code>sum_squares</code>, 给定任意两个数字作为参数，返回他们的平方和：</p><div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">sum_squares</span>(<span class="params">x, y</span>)</span><br><span class="line"><span class="keyword">return</span> add(square(x), square(y))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sum_squares(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="number">25</span></span><br></pre></td></tr></table></figure></div><p>用户定义函数的使用方式与内置函数完全相同。实际上，从<code>sum_square</code>的定义中我们不能判断<code>square</code>是内置于解释器中，还是从模块中导入的，又或是用户定义的。</p><p><code>def</code>语句和赋值语句都将名称与值绑定，并且绑定后对于之前绑定的东西就会直接失效，也就是throw掉了，例如下述的<code>g</code>首先指的是一个没有参数的函数，然后是指一个数字，最后是一个含有两个参数的函数。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">g</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g()</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g = <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">g</span>(<span class="params">h, i</span>)</span><br><span class="line">reurn h + i</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g(<span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure></div><hr><h3 id="1-3-1-环境"><a href="#1-3-1-环境" class="headerlink" title="1.3.1 环境"></a>1.3.1 环境</h3><p>Python子集已经蛮复杂的，但是程序的含义还并不明显，如果形参与内置函数同名怎么办？两个函数可以共享名称而不混淆么？</p><p>求解表达式的环境由<strong>帧</strong>序列组成，他们可以被描述为一些盒子，每个帧都包含了一些<strong>绑定</strong>，他们将名称和对应的值相关联。<strong>全局帧(global frame)</strong> 只有一个。赋值和导入语句会将条目添加到当前环境的第一帧。目前，我们的环境仅由全局帧组成。<br>![[..&#x2F;..&#x2F;Pasted image 20240326211337.png]]<br>这个环境图显示了当前环境中的绑定，还有名称和值的绑定。(OnlinePythonTutor)[<a class="link"   href="https://www.composingprograms.com/tutor.html]%E4%B8%AD%E6%BC%94%E7%A4%BA%EF%BC%8C%E5%8F%AF%E4%BB%A5%E7%94%A8%E6%9D%A5%E6%9F%A5%E7%9C%8B%E7%8E%AF%E5%A2%83%E5%9B%BE" >https://www.composingprograms.com/tutor.html]中演示，可以用来查看环境图 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p>函数也会出现在环境图中。<code>import</code>语句将名称和内置函数绑定。<code>def</code>语句将名称与用户自定义的函数绑定。导入<code>mul</code>并定义<code>square</code>后的结果环境如下图所示：<br>![[..&#x2F;..&#x2F;Pasted image 20240326211659.png]]<br>每个函数都是一行，以<code>func</code>开头，后面是函数名称和形式参数。<code>mul</code>等内置函数没有正式的参数名称，所以都是使用<code>...</code>代替。<br>函数名称重复两次，一次在环境帧中，另一次是作为函数定义的一部分。函数定义中出现的名称叫做**内在名称(intrinsic name)<strong>，帧中的名称叫做</strong>绑定名称(bound name)**。两者之间有一个区别：不同的名称可能指的是同一个函数，但函数本身只有一个内在名称。</p><p>绑定到帧中的函数名称是在求值过程中使用，而内在名称在求职中不起作用。如下面的实例</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="built_in">max</span></span><br><span class="line"><span class="built_in">max</span> = <span class="number">3</span></span><br><span class="line">result = f(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="built_in">max</span>(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">#casue an error</span></span><br></pre></td></tr></table></figure></div><p>当<code>max</code>函数和数值3绑定之后，它就不能再用作函数<br>错误信息是<code>&quot;TypeError: &#39;int&#39; object is not callable&quot;</code>,报告了名称<code>max</code>(当前绑定到数字3)是一个整数而不是函数，所以它不能用作调用表达式中的运算符。</p><p><strong>函数签名</strong>：每个函数允许采用的参数数量有所不同。为了跟踪这些要求，我们绘制了每个函数的名称及其形式参数。用户定义的<code>square</code>只需要<code>x</code>一个参数，提供或多或少的参数都将导致错误。对函数形式参数的描述被称为函数的签名。</p><p>函数<code>max</code>可以接收任意数量的参数，所以它被呈现为<code>max(...)</code>。因为原始函数从未明确定义，所以无论采用多少个参数，所有的内置函数都将呈现为<code>&lt;name&gt;(...)</code></p><hr><h3 id="1-3-2调用用户定义的函数"><a href="#1-3-2调用用户定义的函数" class="headerlink" title="1.3.2调用用户定义的函数"></a>1.3.2调用用户定义的函数</h3><p>为了求出操作符为用户定义函数的调用表达式，Python解释器遵循了以下计算过程。与其他调用表达式一样，解释器将对操作符和操作数表达式求值，然后用生成的实参调用具名函数。</p><p>调用用户定义的函数会引入<code>局部帧(local frame)</code>，它只能访问该函数。通过一些实参调用用户定义的函数：</p><ol><li>在新的局部帧中，将实参绑定到函数的形参上。</li><li>在此以帧开始的环境中执行函数体。<br>求值函数体的环境由两个帧组成：一是包含形式参数绑定的局部帧，然后是包含其他所有内容的全局帧。函数的每个实例都有自己独立的局部帧。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-3定义新函数&quot;&gt;&lt;a href=&quot;#1-3定义新函数&quot; class=&quot;headerlink&quot; title=&quot;1.3定义新函数&quot;&gt;&lt;/a&gt;1.3定义新函数&lt;/h1&gt;&lt;p&gt;通过对Python的了解，我们确定了强大的编程语言中会有一些必须出现的元素&lt;/p&gt;
&lt;ol&gt;</summary>
      
    
    
    
    <category term="CS61A" scheme="https://primeluoqiu.github.io/categories/CS61A/"/>
    
    
  </entry>
  
  <entry>
    <title>1.7 协议层次和服务模型</title>
    <link href="https://primeluoqiu.github.io/2024/03/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.7/"/>
    <id>https://primeluoqiu.github.io/2024/03/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.7/</id>
    <published>2024-03-25T14:08:13.610Z</published>
    <updated>2024-03-27T12:10:17.105Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/25/N72p3fKJ.jpg"                      alt="21.jpg"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/25/Wi1mIyuc.jpg"                      alt="22.jpg"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/25/sSH1q9SA.jpg"                      alt="23.jpg"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/25/sSH1q9SA.jpg"                      alt="24.jpg"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/26/1i5XQqWi.jpg"                      alt="25.jpg"                ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;https://img2.imgtp.com</summary>
      
    
    
    
    <category term="计网" scheme="https://primeluoqiu.github.io/categories/%E8%AE%A1%E7%BD%91/"/>
    
    
  </entry>
  
  <entry>
    <title>计网第二个实验</title>
    <link href="https://primeluoqiu.github.io/2024/03/25/SchoolHomework/%E8%AE%A1%E7%BD%91/Experiment2/"/>
    <id>https://primeluoqiu.github.io/2024/03/25/SchoolHomework/%E8%AE%A1%E7%BD%91/Experiment2/</id>
    <published>2024-03-25T05:46:43.090Z</published>
    <updated>2024-03-27T12:10:45.128Z</updated>
    
    <content type="html"><![CDATA[<p>五、实验步骤                                      </p><p>1.数据规划（课程目标1）</p><p>表1-交换机VLAN划分及端口</p><table><thead><tr><th>设备名</th><th>VLAN编号</th><th>VLAN名称</th><th>端口范围</th><th>连接计算机</th></tr></thead><tbody><tr><td>LSW1</td><td>vlan 10</td><td>技术部</td><td>E 0&#x2F;0&#x2F;1 - E 0&#x2F;0&#x2F;2</td><td>PC1, PC3</td></tr><tr><td>LSW2</td><td>vlan 20</td><td>财务部</td><td>E 0&#x2F;0&#x2F;1 - E 0&#x2F;0&#x2F;2</td><td>PC2, PC4</td></tr></tbody></table><p>表2-PC计算机IP地址及端口信息</p><table><thead><tr><th>设备名</th><th>端口</th><th>IP地址信息</th><th>网关</th></tr></thead><tbody><tr><td>PC1</td><td>E 0&#x2F;0&#x2F;1</td><td>10.10.1.1</td><td>255.255.255.0</td></tr><tr><td>PC2</td><td>E 0&#x2F;0&#x2F;2</td><td>10.10.1.2</td><td>255.255.255.0</td></tr><tr><td>PC3</td><td>E 0&#x2F;0&#x2F;3</td><td>10.10.1.3</td><td>255.255.255.0</td></tr><tr><td>PC4</td><td>E 0&#x2F;0&#x2F;4</td><td>10.10.1.4</td><td>255.255.255.0</td></tr></tbody></table><p> 2.启动有eNSP模拟器，按实验要求和规划，搭建网络拓扑。（课程目标3）<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/25/trp0rx6s.png"                      alt="Pasted image 20240325105802.png"                ><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/25/zXYjCsX3.png"                      alt="Pasted image 20240325105819.png"                ><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/25/BT39huMp.png"                      alt="Pasted image 20240325105918.png"                ></p><p><strong>上图IP地址应为10.10.1.3，当时打错了，后面有纠正</strong></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/25/YWoj26hw.png"                      alt="Pasted image 20240325105929.png"                ></p><p>3.设备配置。（课程目标3）<br>本次配置比起实验一来说，就是多了对于两个交换机的控制，其余的配置都是一样的，当我们配置完每台PC的IP之后，我们就可以进入交换机进行配置了。<br>首先我们进入LSW(交换机1)，然后我们首先关闭之后可能会出现的提示信息</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">undo info-center enable</span><br></pre></td></tr></table></figure></div><p>接下来，我们首先配置第一个交换机所连接的两台PC和对应连接的一台交换机的端口。<br>操作还是和之前一样的操作</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sys</span><br><span class="line">vlan batch 10 20</span><br></pre></td></tr></table></figure></div><p>首先进入sys<br>然后创建两个vlan 10和20</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface G 0/0/1 //G是一种端口的名称，指千兆以太网端口，而上个实验的E指的是普通以太网端口</span><br><span class="line">port link-type access</span><br><span class="line">port default vlan 10</span><br></pre></td></tr></table></figure></div><p>这是第一台PC的配置</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface G 0/0/2</span><br><span class="line">port link-type access</span><br><span class="line">port default vlan 20</span><br></pre></td></tr></table></figure></div><p>这是第二台PC的配置<br>接下来是本实验的核心内容，就是配置24端口的两台交换机，使得他们可以通过vlan10 和 vlan20这两个线路。这样的话就可以连接起来这两台交换机了。</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface G 0/0/24</span><br><span class="line">port link-type trunk</span><br><span class="line">port trunk allow-pass vlan 10 20</span><br></pre></td></tr></table></figure></div><p>这样的话，这个交换机和交换机之间的线缆就可以通过10和20的接口了。<br>剩下的就是配置第二台交换机的配置，方法和上述方法一样，重复一下即可。</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">undo info-center enable</span><br><span class="line">sys</span><br><span class="line">vlan batch 10 20</span><br><span class="line">interface G 0/0/1 //G是一种端口的名称，指千兆以太网端口，而上个实验的E指的是普通以太网端口</span><br><span class="line">port link-type access</span><br><span class="line">port default vlan 10</span><br><span class="line">interface G 0/0/2</span><br><span class="line">port link-type access</span><br><span class="line">port default vlan 20</span><br><span class="line">interface G 0/0/24</span><br><span class="line">port link-type trunk</span><br><span class="line">port trunk allow-pass vlan 10 20</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/25/Wax8a7rI.png"                      alt="Pasted image 20240325114246.png"                ><br>我们不难看出vlan10和20这两个线路均有24接口通过。那么实验就完成了，接下来验证实验就可以了。</p><p>4.验证。（课程目标3）<br>PC2验证<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/25/nGHjP7zq.png"                      alt="Pasted image 20240325114548.png"                ><br>PC1配置<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/25/5fgk27XM.png"                      alt="Pasted image 20240325114813.png"                ><br>由图可知，pc1可以连3，2可以连4，这样的话我们的实验目的也就完成了</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/25/Eg8vjkjM.png"                      alt="Pasted image 20240325114956.png"                ><br>拓扑图如上。<br>六、实验心得或存在的问题（课程目标1)<br>本次实验学到了有关不同楼层的两台交换机之间应该如何配置，以至于达到楼层之间的互联而不与同楼层之间的互联。<br>本次实验还学习到了有关<code>link-type trunk</code>以及trunk接口是用于交换机之间连接的端口，trunk口可以1加入多个vlan，以及接收和发送多个Vlan的Tagged帧。<br>还了解到了G口是千兆以太网口，E口是以太网口的知识点。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;五、实验步骤                                      &lt;/p&gt;
&lt;p&gt;1.数据规划（课程目标1）&lt;/p&gt;
&lt;p&gt;表1-交换机VLAN划分及端口&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;设备名&lt;/th&gt;
&lt;th&gt;VLAN编号</summary>
      
    
    
    
    <category term="Expriment" scheme="https://primeluoqiu.github.io/categories/Expriment/"/>
    
    
  </entry>
  
  <entry>
    <title>Week4 and Daily Schedule</title>
    <link href="https://primeluoqiu.github.io/2024/03/24/%E6%AF%8F%E5%91%A8%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/Week4/"/>
    <id>https://primeluoqiu.github.io/2024/03/24/%E6%AF%8F%E5%91%A8%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/Week4/</id>
    <published>2024-03-24T13:23:47.317Z</published>
    <updated>2024-03-24T13:40:46.850Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Daily-Schedule"><a href="#Daily-Schedule" class="headerlink" title="Daily Schedule"></a>Daily Schedule</h1><h2 id="Total-Schedule"><a href="#Total-Schedule" class="headerlink" title="Total Schedule"></a>Total Schedule</h2><ol><li>《计算机网络》-郑铨老师的 1.7-2.2</li><li>CS61B Week 7- 10</li><li>CS61A 看完第二章</li><li>CSAPP 看完第二章</li><li>CS61C 前两周内容</li></ol><p>每天任务的话，先看周一吧，周一相对来说课不算多，下午有一节毛概，毛概课的话得补半节课的数电笔记和作业</p><h3 id="Monday"><a href="#Monday" class="headerlink" title="Monday"></a>Monday</h3><p>《计算机网络》 1.7</p><p>CS61A</p><p>CS61B</p><p>CSAPP</p><p>还得看点算法，要不都快要蓝桥杯考试了，顶不住了</p><p>目前先准备这些，看明天的收效，希望明天早上可以起得来然后走两圈锻炼锻炼。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Daily-Schedule&quot;&gt;&lt;a href=&quot;#Daily-Schedule&quot; class=&quot;headerlink&quot; title=&quot;Daily Schedule&quot;&gt;&lt;/a&gt;Daily Schedule&lt;/h1&gt;&lt;h2 id=&quot;Total-Schedule&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="大二下" scheme="https://primeluoqiu.github.io/categories/%E5%A4%A7%E4%BA%8C%E4%B8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>第三周总结</title>
    <link href="https://primeluoqiu.github.io/2024/03/24/%E6%AF%8F%E5%91%A8%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/%E7%AC%AC%E4%B8%89%E5%91%A8%E6%80%BB%E7%BB%93/"/>
    <id>https://primeluoqiu.github.io/2024/03/24/%E6%AF%8F%E5%91%A8%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/%E7%AC%AC%E4%B8%89%E5%91%A8%E6%80%BB%E7%BB%93/</id>
    <published>2024-03-24T13:07:37.059Z</published>
    <updated>2024-03-24T13:34:07.396Z</updated>
    
    <content type="html"><![CDATA[<p>本周学习任务完成情况：</p><ol><li>郑铨《计算机网络》:已看完1.6，还差一节视频</li><li>CS61B 目标未完成，达成率 0</li><li>CS61A 仅仅看了1.4之前的，还差一章</li><li>CSAPP：差一节的知识点和两节的对于知识点的总结</li><li>CS61C：甚至还没看课</li></ol><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>怎么说呢，本周的事情相对来说比较多，很多时候为了处理一些事情不得不去花费一晌的时间。究其根本的话还是因为考虑的事情太多太繁杂，像极了酷安的那张经典图片，某物在拥有前，拥有时，以及拥有后的心情状态。</p><p>其实有的时候也是，覆水难收是肯定的事情，硬要做一些可能看起来不是那么的合常理的事情的时候，往往就会产生很多负面的因素，谁能想到收到的手机会是一个被拿去抵债的手机呢。不过其实经此一事的话，二手的市场还真的水深，得亏是那个老哥很好说话，再加上我的态度也是非常的到位，以至于目前来说似乎并没有产生什么不和平的因素。就感觉也还好。本周这种事情占得时间还是蛮多的。课程的任务量其实也还好，就是笔记和每周的作业。感觉也还OK，起码目前基本上emm也算是个应付的态势吧</p><p>有的时候还是心不静，心乱的话效率也不会很高。每次学习的时候也不妨像他们一样手机扣一下，然后就在一边放着。电脑端挂个微信就行，不过似乎我好像也不会被别人找的样子hhh</p><p>这两周的锻炼还算是有所成效，减重了一些，但不多，想要减重还是得每天坚持锻炼，然后规律作息、规律作息、规律作息，重要的事情说三遍hhh，早上倒也还是能起得来，就是太困了，归根结底还是晚上睡的太晚，十二点半左右能睡的话第二天的精神状态想必就会好很多了。早上起来之后的感觉也不会太困。</p><p>啧，其实有的时候也在想，如果我要不是天天学习，或者说如果我真的把这大学四年荒废过去会怎么样，虽然我妈对我的要求确实不高，也就是混口饭吃的程度。不过再怎么说都是要勤奋的，无论是在后面的学习上，还是之后的找工作上。去哪里，找什么样的工作，这些虽然都是后话，但是也是在茫然之中会考虑到的一些事情。</p><p>时间…时间…</p><p>还有多久呢…</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本周学习任务完成情况：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;郑铨《计算机网络》:已看完1.6，还差一节视频&lt;/li&gt;
&lt;li&gt;CS61B 目标未完成，达成率 0&lt;/li&gt;
&lt;li&gt;CS61A 仅仅看了1.4之前的，还差一章&lt;/li&gt;
&lt;li&gt;CSAPP：差一节的知识点和两节的对于知识</summary>
      
    
    
    
    <category term="大二下" scheme="https://primeluoqiu.github.io/categories/%E5%A4%A7%E4%BA%8C%E4%B8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>CSAPP Chapter1.7 硬件被谁管理啊</title>
    <link href="https://primeluoqiu.github.io/2024/03/24/CSAPP/%E7%AC%AC%E4%B8%80%E7%AB%A0/1.7%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E7%A1%AC%E4%BB%B6/"/>
    <id>https://primeluoqiu.github.io/2024/03/24/CSAPP/%E7%AC%AC%E4%B8%80%E7%AB%A0/1.7%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E7%A1%AC%E4%BB%B6/</id>
    <published>2024-03-24T02:51:49.635Z</published>
    <updated>2024-03-24T02:43:36.991Z</updated>
    
    <content type="html"><![CDATA[<p>从hello的例子可以可以看出来，当shell加载运行包括最后输出的时候，shell和hello都没有直接对硬件进行访问(包括键盘，显示器，主存或者磁盘)。取而代之的是，他们依靠操作系统提供的服务。我们可以把操作系统看成是应用程序和硬件之间插入的一层软件。所有应用程序对硬件的操作尝试都必须通过操作系统<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/24/XDgvCQG1.png"                      alt="Pasted image 20240320002837.png"                ><br>操作系统有两个基本功能，</p><ol><li>防止硬件被失控的应用程序滥用</li><li>向应用程序提供简单一致的机制来控制复杂而又通常大不相同的低级硬件设备。</li></ol><p>操作系统通过几个基本的抽象概念(<strong>进程</strong>、<strong>虚拟内存</strong>和<strong>文件</strong>)来实现这两个功能，如下图所示，文件是对I&#x2F;O设备的抽象表示，虚拟内存是对主存和磁盘I&#x2F;O设备的抽象表示，进程则是对处理器、主存和I&#x2F;O设备的抽象表示<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/24/cavhFdDj.png"                      alt="Pasted image 20240320003206.png"                ></p><h4 id="1-7-1-进程"><a href="#1-7-1-进程" class="headerlink" title="1.7.1 进程"></a>1.7.1 进程</h4><p>像hello这样的程序在现代系统上运行时，操作系统会提供一种假象，就像系统上只有这个程序在运行。程序看上去是独占地只用处理器、主存和I&#x2F;O设备。处理器看上去就像在不间断的一条接一条地执行程序中的指令，即该程序的代码和数据是系统内存中唯一的对象。这些假象是通过进程的概念来实现的，进程是计算机科学中最重要和最成功的概念之一。</p><p><strong>进程</strong>是操作系统对一个正在运行的程序的一种抽象。在一个系统上可以同时运行多个进程，而每个进程都好像在独占的使用硬件。而<strong>并发运行</strong>，则是说一个进程的指令和另一个进程的指令是交错执行的。在大多数系统中，需要运行的进程数是多于可以运行它们的CPU个数的。传统系统在一个时刻只能执行一个程序，而先进的<strong>多核</strong>处理器同时能够执行多个程序。无论是在单核还是多核系统中，一个CPU看上去都像是在并发地执行多个进程，这是通过处理器在进程间切换来实现的。操作系统实现这种操作执行的机制称为<strong>上下文交换</strong>。为了简化讨论，我们只考虑包含一个CPU的<strong>单处理器系统</strong>的情况。后面还会讨论</p><p>操作系统保持跟踪进程运行所需的所有状态信息。这种状态，也就是<strong>上下文</strong>，包括许多信息，比如PC和寄存器文件的当前值，以及主存的内容。在任何一个时刻，单处理器系统都只能执行一个进程的代码。当操作系统决定要把控制权从当前进程转移到某个新进程时，就会进行上下文切换，即保存当前进程的上下文、恢复新进程的上下文，然后将控制权传递到新进程。新进程就会从它上次停止的地方开始。那么hello程序运行场景的基本理念看下面。<br>![[<a class="link"   href="https://hansimov.gitbook.io/~gitbook/image?url=https://4154149387-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%252F-MHt_spaxGgCbp2POnfq%252F-MHzietxOnE2XCBTZHJ7%252F-MHziqrI26zhGJA9_NLL%252F01-12%2520%25E8%25BF%259B%25E7%25A8%258B%25E7%259A%2584%25E4%25B8%258A%25E4%25B8%258B%25E6%2596%2587%25E5%2588%2587%25E6%258D%25A2.png?alt=media&token=5df4420b-e3c7-46ca-8192-ba207aa49f15&width=400&dpr=3&quality=100&sign=7323c7a530eb087f04ecfa52db5f03b77529e0c73a5744a490b2389fecb6b30ehttps://hansimov.gitbook.io/~gitbook/image?url=https://4154149387-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%252F-MHt_spaxGgCbp2POnfq%252F-MHzietxOnE2XCBTZHJ7%252F-MHziqrI26zhGJA9_NLL%252F01-12%2520%25E8%25BF%259B%25E7%25A8%258B%25E7%259A%2584%25E4%25B8%258A%25E4%25B8%258B%25E6%2596%2587%25E5%2588%2587%25E6%258D%25A2.png?alt=media&token=5df4420b-e3c7-46ca-8192-ba207aa49f15&width=400&dpr=3&quality=100&sign=7323c7a530eb087f04ecfa52db5f03b77529e0c73a5744a490b2389fecb6b30e%5D%5D" >https://hansimov.gitbook.io/~gitbook/image?url=https:%2F%2F4154149387-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-legacy-files%2Fo%2Fassets%252F-MHt_spaxGgCbp2POnfq%252F-MHzietxOnE2XCBTZHJ7%252F-MHziqrI26zhGJA9_NLL%252F01-12%2520%25E8%25BF%259B%25E7%25A8%258B%25E7%259A%2584%25E4%25B8%258A%25E4%25B8%258B%25E6%2596%2587%25E5%2588%2587%25E6%258D%25A2.png%3Falt=media%26token=5df4420b-e3c7-46ca-8192-ba207aa49f15&amp;width=400&amp;dpr=3&amp;quality=100&amp;sign=7323c7a530eb087f04ecfa52db5f03b77529e0c73a5744a490b2389fecb6b30ehttps://hansimov.gitbook.io/~gitbook/image?url=https:%2F%2F4154149387-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-legacy-files%2Fo%2Fassets%252F-MHt_spaxGgCbp2POnfq%252F-MHzietxOnE2XCBTZHJ7%252F-MHziqrI26zhGJA9_NLL%252F01-12%2520%25E8%25BF%259B%25E7%25A8%258B%25E7%259A%2584%25E4%25B8%258A%25E4%25B8%258B%25E6%2596%2587%25E5%2588%2587%25E6%258D%25A2.png%3Falt=media%26token=5df4420b-e3c7-46ca-8192-ba207aa49f15&amp;width=400&amp;dpr=3&amp;quality=100&amp;sign=7323c7a530eb087f04ecfa52db5f03b77529e0c73a5744a490b2389fecb6b30e]] <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br>实例当中有两个并发的进程：shell和hello。最开始，只有shell进程在运行，也就是等待命令行上的输入。当我们让他运行hello程序时，shell通过一个专门的函数，也就是系统调用，来执行我们的请求，系统调用会将控制权传递给操作系统。操作系统保存shell进程的上下文，创建一个新的hello进程及其上下文，并将控制权传回给它，shell进程会继续等待下一个命令行输入。</p><p>如图所示，从一个进程到另一个进程的转换是由操作系统<strong>内核(kernel)</strong> 管理的。内核是操作系统代码常驻主存的部分。当应用程序需要操作系统的某些操作时，比如读写文件，它就执行一条特殊的<strong>系统调用(system call)</strong> 指令，将控制权传递给内核。然后内核执行被请求的操作并返回应用程序。注意，内核不是一个独立的进程。相反，它是系统管理全部进程所用代码和数据结构的集合。</p><p>实现进程这个抽象概念需要低级硬件和操作系统软件之间的紧密合作。</p><h4 id="1-7-2-线程"><a href="#1-7-2-线程" class="headerlink" title="1.7.2 线程"></a>1.7.2 线程</h4><p>尽管通常我们认为一个进程只有单一的控制流，但是在现在系统中，一个进程实际上可以由多个称为<strong>线程</strong>的执行单元组成，每个线程都运行在进程的上下文中，并共享的代码和全局数据。由于网络服务器中对并行处理的需求，线程称为越来越重要的编程模型，因为多线程之间比多进程之间更容易共享数据，也因为线程一般来说都比进程更高效。当有多处理器可用的时候，多线程也是一种使得程序可以运行得更快的方法，我们将在后面讨论</p><h4 id="1-7-3-虚拟内存"><a href="#1-7-3-虚拟内存" class="headerlink" title="1.7.3 虚拟内存"></a>1.7.3 虚拟内存</h4><p>虚拟内存是一个抽象概念，它为每一个进程提供了一个假象，即每个进程都在独占地使用主存。每个进程看到的内存都是一致的，称为虚拟地址空间。下图所示的Linux进程的虚拟地址空间(其他Unix系统的设计也与此类似)。在Linux中，地址空间最上面的区域是保留给操作系统中的代码和数据的，这对所有进程来说都一样。地址空间的底部区域存放用户进程定义的代码和数据。图中的地址是从下往上增大的。<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/24/s6u5UnTl.png"                      alt="Pasted image 20240322170742.png"                ><br>每个进程看到的虚拟地址空间由大量准确定义的区构成，每个区都有专门的功能。先做简单的了解，逐步向上介绍</p><ul><li><strong>程序代码和数据</strong>：对所有的进程来说，代码是从同一固定地址开始，紧接着的是C全局变量相对应的数据位置。代码和数据区是直接按照可执行目标文件的内容初始化的，在示例中就是可执行文件hello。</li><li><strong>堆</strong>：代码和数据区后紧随的是运行时堆。代码和数据区在进程一开始运行时就被指定了大小，与此不同，当调用像malloc和free这样的C标准库函数的时候，堆可以在运行时动态地扩展和收缩。</li><li><strong>共享库</strong>：大约在地址空间的中间部分是一块用来存放像C标准库和数学库这样的共享库的代码和数据的区域。共享库的概念非常强大，也相当难懂。</li><li><strong>栈</strong>：位于用户虚拟地址空间顶部的是<strong>用户栈</strong>，编译器用它来实现函数调用。和堆一样，用户栈在程序执行期间可以动态地扩展和收缩。特别的，每次我们调用一个函数时，栈就会增长；从一个函数返回时，栈就会收缩。</li><li><strong>内核虚拟内存</strong>：地址空间顶部的区域是为内核保留的。不允许应用程序读写这个区域的内容或者直接调用内核代码定义的函数。相反，它们必须调用内核来执行这些操作。</li></ul><p>虚拟内存的运作需要硬件和操作系统软件之间精密复杂的交互，包括对处理器生成的每个地址的硬件翻译。基本思想是把一个进程虚拟内存存储在磁盘上，然后用主存作为磁盘的高速缓存。</p><h4 id="1-7-4-文件"><a href="#1-7-4-文件" class="headerlink" title="1.7.4 文件"></a>1.7.4 文件</h4><p><strong>文件</strong>就是字节序列，仅此而已。每个I&#x2F;O设备，包括磁盘、键盘、显示器甚至网络，都可以看成是文件。系统中的所有输入输出都是通过使用一小组称为Unix I&#x2F;O的系统调用读写文件来实现的。</p><p>文件这个简单而精致的概念是十分强大的，因为它向应用程序提供了一个统一的视图，来看待系统中可能含有的所有各式各样的I&#x2F;O设备。例如，处理磁盘文件内容的应用程序员可以非常幸福，因为他们无需了解具体的磁盘技术。进一步说，同一个程序可以在使用不同磁盘技术的不同系统上运行。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;从hello的例子可以可以看出来，当shell加载运行包括最后输出的时候，shell和hello都没有直接对硬件进行访问(包括键盘，显示器，主存或者磁盘)。取而代之的是，他们依靠操作系统提供的服务。我们可以把操作系统看成是应用程序和硬件之间插入的一层软件。所有应用程序对硬件</summary>
      
    
    
    
    <category term="CSAPP" scheme="https://primeluoqiu.github.io/categories/CSAPP/"/>
    
    
  </entry>
  
  <entry>
    <title>CSAPP Chapter1.6 存储设备形成也是有结构的</title>
    <link href="https://primeluoqiu.github.io/2024/03/24/CSAPP/%E7%AC%AC%E4%B8%80%E7%AB%A0/1.6%E5%AD%98%E5%82%A8%E8%AE%BE%E5%A4%87%E5%BD%A2%E6%88%90%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/"/>
    <id>https://primeluoqiu.github.io/2024/03/24/CSAPP/%E7%AC%AC%E4%B8%80%E7%AB%A0/1.6%E5%AD%98%E5%82%A8%E8%AE%BE%E5%A4%87%E5%BD%A2%E6%88%90%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/</id>
    <published>2024-03-24T02:51:49.634Z</published>
    <updated>2024-03-24T02:40:48.774Z</updated>
    
    <content type="html"><![CDATA[<p>也就是说，在处理器中和一个较大较慢的设备(例如主存)之间插入要给更小更快的存储设备(例如高缓)的想法已经成为一个普遍的观念。实际上，每个计算机中的存储设备都被组织成了一个存储器层次结构，如图所示<br>![[<a class="link"   href="https://hansimov.gitbook.io/~gitbook/image?url=https://4154149387-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%252F-MHt_spaxGgCbp2POnfq%252F-MHzhX2vrq6mFP3tN9EU%252F-MHzi1Edm9hUsnQdAkkL%252F01-09%2520%25E4%25B8%2580%25E4%25B8%25AA%25E5%25AD%2598%25E5%2582%25A8%25E5%2599%25A8%25E5%25B1%2582%25E6%25AC%25A1%25E7%25BB%2593%25E6%259E%2584%25E7%259A%2584%25E7%25A4%25BA%25E4%25BE%258B.png?alt=media&token=afb8208e-17dc-475f-9f61-acf0bd0ca891&width=400&dpr=3&quality=100&sign=17fc4e7af9f4033010d24045648add7168e149dc6885e9e1a1730033b06fd7f2%5D%5D" >https://hansimov.gitbook.io/~gitbook/image?url=https:%2F%2F4154149387-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-legacy-files%2Fo%2Fassets%252F-MHt_spaxGgCbp2POnfq%252F-MHzhX2vrq6mFP3tN9EU%252F-MHzi1Edm9hUsnQdAkkL%252F01-09%2520%25E4%25B8%2580%25E4%25B8%25AA%25E5%25AD%2598%25E5%2582%25A8%25E5%2599%25A8%25E5%25B1%2582%25E6%25AC%25A1%25E7%25BB%2593%25E6%259E%2584%25E7%259A%2584%25E7%25A4%25BA%25E4%25BE%258B.png%3Falt=media%26token=afb8208e-17dc-475f-9f61-acf0bd0ca891&amp;width=400&amp;dpr=3&amp;quality=100&amp;sign=17fc4e7af9f4033010d24045648add7168e149dc6885e9e1a1730033b06fd7f2]] <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br>在这个层次结构中，从上到下，设备之间的访问速度越来越慢，容量越来越大，并且每字节的造价也越来越低。寄存器文件在层次结构中位于最顶层，也就是第0级或者L0，主存在第4存…</p><p>存储器层次结构的主要思想是上一层的存储器作为低一层存储器的高速缓存。因此寄存器文件就是L1的高速缓存，L1是L2的高速缓存..在某些具有分布式文件系统的网络系统中，本地磁盘就是存储在其他系统中磁盘上的数据的高速缓存。正如可以运用不同的高速缓存的知识来提高程序性能一样，程序员同样可以利用对整个存储器层次结构的理解来提高程序性能。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;也就是说，在处理器中和一个较大较慢的设备(例如主存)之间插入要给更小更快的存储设备(例如高缓)的想法已经成为一个普遍的观念。实际上，每个计算机中的存储设备都被组织成了一个存储器层次结构，如图所示&lt;br&gt;![[&lt;a class=&quot;link&quot;   href=&quot;https://h</summary>
      
    
    
    
    <category term="CSAPP" scheme="https://primeluoqiu.github.io/categories/CSAPP/"/>
    
    
  </entry>
  
  <entry>
    <title>CSAPP Chapter1.5 多来点高速缓存嘛</title>
    <link href="https://primeluoqiu.github.io/2024/03/24/CSAPP/%E7%AC%AC%E4%B8%80%E7%AB%A0/1.5%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E8%87%B3%E5%85%B3%E9%87%8D%E8%A6%81/"/>
    <id>https://primeluoqiu.github.io/2024/03/24/CSAPP/%E7%AC%AC%E4%B8%80%E7%AB%A0/1.5%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E8%87%B3%E5%85%B3%E9%87%8D%E8%A6%81/</id>
    <published>2024-03-24T02:51:49.633Z</published>
    <updated>2024-03-24T02:40:19.983Z</updated>
    
    <content type="html"><![CDATA[<p>上述简单的运行过程中，我们不难发现系统花费了大量的时间把信息从一个地方挪到另一个地方。例如hello最初放在磁盘上，当程序加载的时候，被复制到主存，最后从主存上复制到显示设备。复制总是需要随时间的。这些复制就是开销，所以系统设计者的一个主要目标就是使这些复制操作尽可能快的完成。</p><p>根据机械原理，较大的存储设备要比比较小的存储设备运行的慢，而快速设备的造价远高于同类的低速设备，比如说，一个典型系统上的磁盘驱动器可能比主存大1000倍，但是对处理器而言，从磁盘驱动器上读取一个字的时间开销要比从主存中的开销大1000万倍。</p><p>类似得，一个典型的寄存器文件只存储几百byte的信息，而主存里面可以存放几十亿字节。然而，处理器从寄存器文件中读数据比从主存中读取几乎要快100倍，而且随着半导体技术的进步，处理器和主存之间的差距还在增大。加快处理器的运行速度比加快主存的运行速度要容易和便宜得多。针对这种处理器和主存之间的差异，系统设计者就采用了更小更快的存储设备，称为<strong>高速缓存存储器</strong>(cache memory, 简称cache或高速缓存)，作为暂时的集结区域，存放处理器近期可能需要的信息。<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/24/Z51UmPNz.png"                      alt="Pasted image 20240318151011.png"                ><br>这是一个典型系统中的高速缓存存储器，位于CPU上的L1高速缓存的荣富良可以达到数万字节。访问速度几乎和访问寄存器文件一样快。一个容量为数十万到百万字节的更大的L2告诉换曾黁通过一条特殊的总线连接到CPU。</p><p>进程访问L2高速缓存的时间要比访问L1告诉换从的时间长5倍，但是这仍然比访问主存的时间快5-10倍。L1和L2告诉换从使用一种叫做<strong>静态随机访问存储器</strong>的硬件技术实现的。比较新的，处理能力更强大的系统甚至有三级高速缓存：L1、L2、L3.系统可以获得一个很大的存储器，同时访问速度也很快，原因是利用了高速缓存的局部性原理，即<strong>程序具有访问局部区域里的数据和代码的趋势</strong>。通过让高速缓存里存放可能经常访问的数据，大部分的内存操作都能在快速的高速缓存中完成。<br>![[Pasted image 20240318151738.png]]</p><p>本书得出的重要结论之一就是，意识到高速缓存存储器存在的应用程序员能够利用高速缓存将程序的的性能提升一个数量级。</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;上述简单的运行过程中，我们不难发现系统花费了大量的时间把信息从一个地方挪到另一个地方。例如hello最初放在磁盘上，当程序加载的时候，被复制到主存，最后从主存上复制到显示设备。复制总是需要随时间的。这些复制就是开销，所以系统设计者的一个主要目标就是使这些复制操作尽可能快的完</summary>
      
    
    
    
    <category term="CSAPP" scheme="https://primeluoqiu.github.io/categories/CSAPP/"/>
    
    
  </entry>
  
  <entry>
    <title>CSAPP Chapter1.3 处理器是干嘛的</title>
    <link href="https://primeluoqiu.github.io/2024/03/24/CSAPP/%E7%AC%AC%E4%B8%80%E7%AB%A0/1.4%E5%A4%84%E7%90%86%E5%99%A8%E8%AF%BB%E5%B9%B6%E8%A7%A3%E9%87%8A%E5%82%A8%E5%AD%98%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E6%8C%87%E4%BB%A4/"/>
    <id>https://primeluoqiu.github.io/2024/03/24/CSAPP/%E7%AC%AC%E4%B8%80%E7%AB%A0/1.4%E5%A4%84%E7%90%86%E5%99%A8%E8%AF%BB%E5%B9%B6%E8%A7%A3%E9%87%8A%E5%82%A8%E5%AD%98%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E6%8C%87%E4%BB%A4/</id>
    <published>2024-03-24T02:51:49.632Z</published>
    <updated>2024-03-24T02:39:50.330Z</updated>
    
    <content type="html"><![CDATA[<p>在我们创建完hello的可执行文件之后，用shell运行如下</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">linux &gt; ./hello</span><br><span class="line">hello, world</span><br><span class="line">linux &gt;</span><br></pre></td></tr></table></figure></div><p>shell是一个命令行解释器，它输出一个提示符，然后等待一个命令行，执行这个命令。如果命令行第一个单词不是一个内置的指令，那么它就会假设这是一个可执行文件的名字，它将加载并运行这个文件。此例中，加载运行了hello，然后等待程序终止，输出消息，然后终止。然后输出一个提示符，等待下一个输入。</p><h3 id="1-4-1-系统的硬件组成"><a href="#1-4-1-系统的硬件组成" class="headerlink" title="1.4.1 系统的硬件组成"></a>1.4.1 系统的硬件组成</h3><h4 id="1-总线"><a href="#1-总线" class="headerlink" title="1.总线"></a>1.总线</h4><p>也就贯穿整个系统的一组电子管道。携带信息字节并在各个部件间传递。通常总线被设计成传送定长的字节块，也就是字。字中的字节数（即字长）是一个基本的系统参数，各个系统中都不尽相同。现在的的大多数机器字长是4或8字节32&#x2F;64位。</p><h4 id="2-I-O设备"><a href="#2-I-O设备" class="headerlink" title="2.I&#x2F;O设备"></a>2.I&#x2F;O设备</h4><p>这是系统和外部世界的联系通道。示例系统包括四个I&#x2F;O设备：作为用户输入的键盘和鼠标，作为用户输出的显示器，以及用于长期存储数据和程序的磁盘驱动器。最开始的hello就存放在磁盘上。</p><p>每个I&#x2F;O都通过以一个<strong>控制器或适配器</strong>与I&#x2F;O总线相连。控制器和适配器之间的的区别而在于他们的<strong>封装方式</strong>。控制器是I&#x2F;O设备本身或者系统的主印制电路板(主板)上的芯片组。而适配器是一块插在主板插槽上的卡。这些设备的功能都是在I&#x2F;O总线和I&#x2F;O设备之间传递信息·<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/24/CLnPwRdz.png"                      alt="Pasted image 20240315143111.png"                ></p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALU:算数/逻辑单元 PC：程序计数器 USB：通用串行总线</span><br></pre></td></tr></table></figure></div><h4 id="3-主存"><a href="#3-主存" class="headerlink" title="3.主存"></a>3.主存</h4><p><strong>主存</strong>是一个临时存储设备，在处理器执行程序时，用来存放程序和程序处理的数据。从物理上来说，主存是由一组<strong>动态随机存储器(DRAM)</strong> 芯片组成的。从逻辑上来说，存储器是一个线性的字节数组，每个字节都有其唯一的地址(数组索引)，这些地址是从零开始的。一般来说，组成程序的每条机器指令都由不同数量的字节构成。一般来说，组成程序的每条机器指令都有不同数量的字节构成。与C程序变量相对应的数据项大小是根据类型变化的。</p><h4 id="4-处理器"><a href="#4-处理器" class="headerlink" title="4.处理器"></a>4.处理器</h4><p>中央处理单元(CPU),简称<strong>处理器</strong>，是解释(或执行)存储在主存中指令的引擎。处理器的核心是一个大小为一个字的存储设备(或<strong>寄存器</strong>) ，称为<strong>程序计数器&#x2F;指令计数器</strong>(PC)。在任何时刻，PC都指向主存中某条机器语言指令(即含有该条指令的地址)</p><p>从系统通电开始到断电，处理器一直在不断地执行程序计数器指向的指令，再更新程序计数器，使其指向下一条指令。处理器看上去是按照一个非常简单的指令执行模型来操作的，这个模型是由指令集架构(Arm, x86,)决定的。<strong>在这个模型中，指令按照严格的顺序执行，而执行一条指令包含执行一系列的步骤。处理器从程序计数器指向的内存处读取指令，解释指令中的位，执行该指令指示的简单操作，然后更新PC，使其指向下一条指令，而这条指令并不一定和在内存中刚刚执行的指令相邻。</strong></p><p>这样的简单操作并不多，它们围绕着主存、寄存器文件和算数&#x2F;逻辑单元进行。寄存器文件是个小的存储设备，由一些单个字长的寄存器组成，每个寄存器都有唯一的名字。ALU计算新的数据和地址值。下面是一些简单操作的例子，CPU在指令的要求下可能会执行这些操作</p><ul><li>加载：从主存复制一个字节或者一个字到寄存器，以覆盖寄存器原来的内容。</li><li>存储：从寄存器复制一个字节或者一个字到主存的某个位置，以覆盖这个位置上原有的内容</li><li>操作：把两个寄存器的内容复制到ALU，ALU对这两个字做算术运算，并将结果存放到一个寄存器中，以覆盖该寄存器中原来的内容</li><li>跳转：从指令本身中抽取一个字，并将这个字复制到PC中，以覆盖PC中原来的值</li></ul><p>处理器看上去是它的指令集架构的简单实现，但是实际上现代处理器使用了非常复杂的机制来加速程序的执行。因此，我们将处理器的指令集架构和处理器的微体系结构区分开来：指令集架构描述的是每条机器代码指令的效果；而微体系结构描述的是处理器实际上是如何实现的。</p><h3 id="1-4-2运行Hello程序"><a href="#1-4-2运行Hello程序" class="headerlink" title="1.4.2运行Hello程序"></a>1.4.2运行Hello程序</h3><p>目前先暂时省略一些细节。</p><p>起初，shell程序执行它的指令，等待我们输入一个命令。当我们在键盘上输入字符串”.&#x2F;hello”后，shell程序将字符逐一读入寄存器，再把它存放到内存中。如下图所示<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/24/UPG9V8JH.png"                      alt="Pasted image 20240316001811.png"                ></p><p>当我们在键盘上敲回车键之后，shell程序就知道我们已经结束了命令的输入，然后shell执行一系列指令来加载可执行的hello文件，这些指令将hello目标文件中的代码和数据从磁盘复制到主存。数据包括最后会被输出的字符串”hello, world\n”</p><p>利用直接存储器存取(DMA)技术，数据可以不通过处理器而直接从磁盘到达主存。这个步骤如下图所示<br>![[<a class="link"   href="https://hansimov.gitbook.io/~gitbook/image?url=https://4154149387-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%252F-MHt_spaxGgCbp2POnfq%252F-MHzfLHp5XFUFTsUJAKx%252F-MHzfN_gwQJSG2YnC5Gk%252F01-06%2520%25E4%25BB%258E%25E7%25A3%2581%25E7%259B%2598%25E5%258A%25A0%25E8%25BD%25BD%25E5%258F%25AF%25E6%2589%25A7%25E8%25A1%258C%25E6%2596%2587%25E4%25BB%25B6%25E5%2588%25B0%25E4%25B8%25BB%25E5%25AD%2598.png?alt=media&token=9a49507e-f20d-4af8-b277-bebf57cc597f&width=400&dpr=3&quality=100&sign=74b6cf3ac9a458f0c5b3b6cbc5920a9cd3dcc59d6250e0badd63c26859b486f3%5D%5D" >https://hansimov.gitbook.io/~gitbook/image?url=https:%2F%2F4154149387-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-legacy-files%2Fo%2Fassets%252F-MHt_spaxGgCbp2POnfq%252F-MHzfLHp5XFUFTsUJAKx%252F-MHzfN_gwQJSG2YnC5Gk%252F01-06%2520%25E4%25BB%258E%25E7%25A3%2581%25E7%259B%2598%25E5%258A%25A0%25E8%25BD%25BD%25E5%258F%25AF%25E6%2589%25A7%25E8%25A1%258C%25E6%2596%2587%25E4%25BB%25B6%25E5%2588%25B0%25E4%25B8%25BB%25E5%25AD%2598.png%3Falt=media%26token=9a49507e-f20d-4af8-b277-bebf57cc597f&amp;width=400&amp;dpr=3&amp;quality=100&amp;sign=74b6cf3ac9a458f0c5b3b6cbc5920a9cd3dcc59d6250e0badd63c26859b486f3]] <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br>一旦目标文件hello中的代码和数据被加载到主存，处理器就开始执行hello程序的main程序中的机器语言指令。这些指令将”Hello,world\n”字符串中的字节从主存复制到寄存器文件，再从寄存器文件中复制到显示设备，最终显示在屏幕上。步骤如下所示<br>![[<a class="link"   href="https://hansimov.gitbook.io/~gitbook/image?url=https://4154149387-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%252F-MHt_spaxGgCbp2POnfq%252F-MHzfVZwd5iIwJfDkOPj%252F-MHzffvOB90toXVTON5G%252F01-07%2520%25E5%25B0%2586%25E8%25BE%2593%25E5%2587%25BA%25E5%25AD%2597%25E7%25AC%25A6%25E4%25B8%25B2%25E4%25BB%258E%25E5%25AD%2598%25E5%2582%25A8%25E5%2599%25A8%25E5%2586%2599%25E5%2588%25B0%25E6%2598%25BE%25E7%25A4%25BA%25E5%2599%25A8.png?alt=media&token=d0480c36-9640-4159-bc71-8f5db262a6ba&width=400&dpr=3&quality=100&sign=a45f19ed618ab752f842b7f269e3b6411ec8fa6f81166c73190f0156510d0c4a%5D%5D" >https://hansimov.gitbook.io/~gitbook/image?url=https:%2F%2F4154149387-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-legacy-files%2Fo%2Fassets%252F-MHt_spaxGgCbp2POnfq%252F-MHzfVZwd5iIwJfDkOPj%252F-MHzffvOB90toXVTON5G%252F01-07%2520%25E5%25B0%2586%25E8%25BE%2593%25E5%2587%25BA%25E5%25AD%2597%25E7%25AC%25A6%25E4%25B8%25B2%25E4%25BB%258E%25E5%25AD%2598%25E5%2582%25A8%25E5%2599%25A8%25E5%2586%2599%25E5%2588%25B0%25E6%2598%25BE%25E7%25A4%25BA%25E5%2599%25A8.png%3Falt=media%26token=d0480c36-9640-4159-bc71-8f5db262a6ba&amp;width=400&amp;dpr=3&amp;quality=100&amp;sign=a45f19ed618ab752f842b7f269e3b6411ec8fa6f81166c73190f0156510d0c4a]] <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在我们创建完hello的可执行文件之后，用shell运行如下&lt;/p&gt;
&lt;div class=&quot;highlight-container&quot; data-rel=&quot;Plaintext&quot;&gt;&lt;figure class=&quot;iseeu highlight plaintext&quot;&gt;&lt;table</summary>
      
    
    
    
    <category term="CSAPP" scheme="https://primeluoqiu.github.io/categories/CSAPP/"/>
    
    
  </entry>
  
  <entry>
    <title>CSAPP Chapter1.3 了解编译系统如何工作是大有益处的</title>
    <link href="https://primeluoqiu.github.io/2024/03/24/CSAPP/%E7%AC%AC%E4%B8%80%E7%AB%A0/1.3%E4%BA%86%E8%A7%A3%E7%BC%96%E8%AF%91%E7%B3%BB%E7%BB%9F%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E6%98%AF%E5%A4%A7%E6%9C%89%E7%9B%8A%E5%A4%84%E7%9A%84/"/>
    <id>https://primeluoqiu.github.io/2024/03/24/CSAPP/%E7%AC%AC%E4%B8%80%E7%AB%A0/1.3%E4%BA%86%E8%A7%A3%E7%BC%96%E8%AF%91%E7%B3%BB%E7%BB%9F%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E6%98%AF%E5%A4%A7%E6%9C%89%E7%9B%8A%E5%A4%84%E7%9A%84/</id>
    <published>2024-03-24T02:51:49.631Z</published>
    <updated>2024-03-24T02:25:47.980Z</updated>
    
    <content type="html"><![CDATA[<p>益处大致有三点</p><ul><li><strong>优化程序性能</strong>。尽管已经无需为了写出高效代码而了解编译器的内部工作。不过为了在C中做出更好对的编码选择，我们确实需要了解一些机器代码以及编译器将不同的C转化成机器代码的方式。例如在C语言程序中有<code>if-else</code>和<code>switch</code>两种语句。那么这两种哪个更高效呢，while和for之间哪个更有效呢？这些都是可以得到了解的</li><li><strong>理解链接时出现的错误</strong>。根据经验来讲，一些令人困扰的程序错误往往都与链接器操作有关，尤其是试图构建大型的软件系统时。例如链接器报告说无法解析一个引用，这是什么意思？静态变量和全局变量的区别是什么等一系列问题</li><li><strong>避免安全漏洞</strong>。多年来，缓冲区溢出错误时造成大多数网络和Internet服务器上安全漏洞的主要原因。存在这些错误是因为很少有程序员能够理解需要限制从不受信任的源接受数据的数量和格式。 学习安全编程的第一步就是理解数据和控制信息存储在程序栈上的方式会引起的后果。等</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;益处大致有三点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;优化程序性能&lt;/strong&gt;。尽管已经无需为了写出高效代码而了解编译器的内部工作。不过为了在C中做出更好对的编码选择，我们确实需要了解一些机器代码以及编译器将不同的C转化成机器代码的方式。例如在C语言程序中有&lt;co</summary>
      
    
    
    
    <category term="CSAPP" scheme="https://primeluoqiu.github.io/categories/CSAPP/"/>
    
    
  </entry>
  
  <entry>
    <title>CSAPP Chapter1.2 程序被其他程序翻译成不同的格式</title>
    <link href="https://primeluoqiu.github.io/2024/03/24/CSAPP/%E7%AC%AC%E4%B8%80%E7%AB%A0/1.2%E7%A8%8B%E5%BA%8F%E8%A2%AB%E5%85%B6%E4%BB%96%E7%A8%8B%E5%BA%8F%E7%BF%BB%E8%AF%91%E6%88%90%E4%B8%8D%E5%90%8C%E7%9A%84%E6%A0%BC%E5%BC%8F/"/>
    <id>https://primeluoqiu.github.io/2024/03/24/CSAPP/%E7%AC%AC%E4%B8%80%E7%AB%A0/1.2%E7%A8%8B%E5%BA%8F%E8%A2%AB%E5%85%B6%E4%BB%96%E7%A8%8B%E5%BA%8F%E7%BF%BB%E8%AF%91%E6%88%90%E4%B8%8D%E5%90%8C%E7%9A%84%E6%A0%BC%E5%BC%8F/</id>
    <published>2024-03-24T02:51:49.630Z</published>
    <updated>2024-03-24T02:36:29.315Z</updated>
    
    <content type="html"><![CDATA[<p>为了在系统上运行Hello.c程序，每条C语句必须被其他程序转化成一系列的低级机器语言指令。然后这些指令按照一种称为可执行程序的格式打好包，并以二进制磁盘文件的形式存放起来。目标程序也成为可执行目标文件</p><p>高级语言 -&gt; 低级指令 -&gt; 指令打包并以二进制文件存放。</p><p>![[<a class="link"   href="https://hansimov.gitbook.io/~gitbook/image?url=https://4154149387-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%252F-MHt_spaxGgCbp2POnfq%252F-MHzZfEIY91yIzOD0Rce%252F-MHzZpZI-gs8CNcwHIyv%252F01-03%2520compilation%2520systems.png?alt=media&token=91ca688e-1cfc-4ec6-8b99-d52e672bbac7&width=400&dpr=3&quality=100&sign=ad2978e04a286ea0e07b7bbfb5d2a96b78a69a9b23614f1df17e662f4615f344%5D%5D" >https://hansimov.gitbook.io/~gitbook/image?url=https:%2F%2F4154149387-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-legacy-files%2Fo%2Fassets%252F-MHt_spaxGgCbp2POnfq%252F-MHzZfEIY91yIzOD0Rce%252F-MHzZpZI-gs8CNcwHIyv%252F01-03%2520compilation%2520systems.png%3Falt=media%26token=91ca688e-1cfc-4ec6-8b99-d52e672bbac7&amp;width=400&amp;dpr=3&amp;quality=100&amp;sign=ad2978e04a286ea0e07b7bbfb5d2a96b78a69a9b23614f1df17e662f4615f344]] <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><ul><li>预处理阶段，通过以字符#开头的命令，修改原始程序。如<code>#include&lt;iostream&gt;</code>命令就是告诉预处理器读取系统头文件<code>stdio.h</code>的内容，然后直接插入程序文本中。然后得到了另一个C程序，通常以.i作为文件扩展名。</li><li>编译阶段：通过编译器将文本文件翻译成hello.s，也就是汇编语言程序，该程序包含<code>main</code>的定义<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">main:</span><br><span class="line">    subq $8, %rsp</span><br><span class="line">    movl $.LC0, %edi</span><br><span class="line">    call puts</span><br><span class="line">    movl $0, %eax</span><br><span class="line">    addq $8, %rsp</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure></div></li><li>2-7行每条都以一种文本格式描述了一条低级语言指令。(汇编语言为所有不同高级语言的不同编译器提供了通用的输出语言)</li><li>汇编阶段；通过汇编器将hello.s翻译成机器语言指令。把这些指令打包成可重定位目标程序。并保存到hello.o中(这是一个二进制文件)，里面包含的是<code>main</code>的指令代码。</li><li>链接阶段：hello程序调用了printf函数，是标准C库中的一个函数。函数存在于一个名为<code>printf.o</code>的单独的预编译好了的目标文件中，而这个文件必须以某种方式合并到hello.c的程序中，链接器负责合并，结果得到hello文件，是一个可执行文件。可以被加载到内存中，由系统执行。<br>也就是说，一个C程序都是先从预处理阶段开始的，先读取头文件然后插入程序中，然后通过编译器翻译成汇编语言，再通过汇编器翻译成机器语言指令生成hello.o，接下来引入在hello中调用的printf函数，而该函数存在于一个单独编译好的目标文件<code>printf.o</code>中，然后连接器负责合并这两个.o的目标文件，然后最后得出一个可执行文件。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;为了在系统上运行Hello.c程序，每条C语句必须被其他程序转化成一系列的低级机器语言指令。然后这些指令按照一种称为可执行程序的格式打好包，并以二进制磁盘文件的形式存放起来。目标程序也成为可执行目标文件&lt;/p&gt;
&lt;p&gt;高级语言 -&amp;gt; 低级指令 -&amp;gt; 指令打包并以</summary>
      
    
    
    
    <category term="CSAPP" scheme="https://primeluoqiu.github.io/categories/CSAPP/"/>
    
    
  </entry>
  
  <entry>
    <title>CSAPP Chapter1.1 信息就是位+上下文</title>
    <link href="https://primeluoqiu.github.io/2024/03/24/CSAPP/%E7%AC%AC%E4%B8%80%E7%AB%A0/1.1%E4%BF%A1%E6%81%AF%E5%B0%B1%E6%98%AF%E4%BD%8D+%E4%B8%8A%E4%B8%8B%E6%96%87/"/>
    <id>https://primeluoqiu.github.io/2024/03/24/CSAPP/%E7%AC%AC%E4%B8%80%E7%AB%A0/1.1%E4%BF%A1%E6%81%AF%E5%B0%B1%E6%98%AF%E4%BD%8D+%E4%B8%8A%E4%B8%8B%E6%96%87/</id>
    <published>2024-03-24T02:51:49.625Z</published>
    <updated>2024-03-24T02:25:25.510Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一节：信息就是位＋上下文"><a href="#第一节：信息就是位＋上下文" class="headerlink" title="第一节：信息就是位＋上下文"></a>第一节：信息就是位＋上下文</h2><p>我们在创建第一个hello.c的时候，这些文件都是由ASCII码组成的，也就是用一个唯一的单字节大小的值来表示每个字符。而只由ASCII字符构成的文件成为<strong>文本文件</strong>，其他的文件被称为二进制文件。</p><p>这件事说明了一个基本思想：系统中所有的信息都是由一串bit表示的。区分不同数据对象的唯一方法是我们读到这些数据对象时的上下文。例如在不同的上下文中，一个同样的字节序列可能表示一个整数、浮点数、字符串、机器指令。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;第一节：信息就是位＋上下文&quot;&gt;&lt;a href=&quot;#第一节：信息就是位＋上下文&quot; class=&quot;headerlink&quot; title=&quot;第一节：信息就是位＋上下文&quot;&gt;&lt;/a&gt;第一节：信息就是位＋上下文&lt;/h2&gt;&lt;p&gt;我们在创建第一个hello.c的时候，这些文件都是由</summary>
      
    
    
    
    <category term="CSAPP" scheme="https://primeluoqiu.github.io/categories/CSAPP/"/>
    
    
  </entry>
  
  <entry>
    <title>模拟堆</title>
    <link href="https://primeluoqiu.github.io/2024/03/23/Algorithm/duiyouhua/"/>
    <id>https://primeluoqiu.github.io/2024/03/23/Algorithm/duiyouhua/</id>
    <published>2024-03-23T14:13:09.233Z</published>
    <updated>2024-03-23T14:14:47.893Z</updated>
    
    <content type="html"><![CDATA[<h3 id="模拟堆"><a href="#模拟堆" class="headerlink" title="模拟堆"></a>模拟堆</h3><p>接下来看模拟堆，模拟堆比起之前就是多了两个数组，这两个数组属于互为反函数的类型。例如 <code>hp[k] = j</code>那么<code>ph[j] = k</code>，一个是对应着在堆里的下标，另一个对应的是下标对应的值。 那么对应的，在进行交换的时候，就不能只考虑值之间的交换了，就还得考虑数组之间的交换。这个时候，就需要一个全新的函数了</p><p>因为题目中要考虑第k个数，那么就需要两个数组来存储第k个数是什么<br>ph[k]存的是第k个插入的数在堆里的下标是什么,还需要一个hp[k],用来存的是堆的某个点是第几个插入的点。</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap_head</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="built_in">swap</span>(ph[hp[a]], ph[hp[b]]);  </span><br><span class="line">    <span class="built_in">swap</span>(hp[a], hp[b]);  </span><br><span class="line">    <span class="built_in">swap</span>(a, b);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>然后就是把所有的<code>swap</code>函数进行更换为堆里面特有的<code>swap</code>。<br>这个方法不常用，但是djikstra堆优化是常用的，所以要了解一下</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, a, b;</span><br><span class="line"><span class="type">int</span> h[N], cnt, ph[N], hp[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heap_swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">swap</span>(ph[hp[a]], ph[hp[b]]);</span><br><span class="line">    <span class="built_in">swap</span>(hp[a], hp[b]);</span><br><span class="line">    <span class="built_in">swap</span>(h[a], h[b]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = u;</span><br><span class="line">    <span class="keyword">if</span>(u * <span class="number">2</span> &lt;= cnt &amp;&amp; h[u * <span class="number">2</span>] &lt; h[t]) t = u * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(u * <span class="number">2</span> + <span class="number">1</span> &lt;= cnt &amp;&amp; h[u * <span class="number">2</span> + <span class="number">1</span>] &lt; h[t]) t = u * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(u != t)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">heap_swap</span>(u, t);</span><br><span class="line">        <span class="built_in">down</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(u / <span class="number">2</span> &amp;&amp; h[u / <span class="number">2</span>] &gt; h[u])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">heap_swap</span>(u, u / <span class="number">2</span>);</span><br><span class="line">        u &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(n --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> op[<span class="number">10</span>];</span><br><span class="line">        <span class="type">int</span> k, x;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, op);</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(op, <span class="string">&quot;I&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">            cnt ++;</span><br><span class="line">            m ++;</span><br><span class="line">            ph[m] = cnt, hp[cnt] = m;</span><br><span class="line">            h[cnt] = x;</span><br><span class="line">            <span class="built_in">up</span>(cnt);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(op, <span class="string">&quot;PM&quot;</span>)) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, h[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(op, <span class="string">&quot;DM&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">heap_swap</span>(<span class="number">1</span>, cnt);</span><br><span class="line">            cnt --;</span><br><span class="line">            <span class="built_in">down</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(op, <span class="string">&quot;D&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;k);</span><br><span class="line">            k = ph[k];</span><br><span class="line">            <span class="built_in">heap_swap</span>(k, cnt);</span><br><span class="line">            cnt --;</span><br><span class="line">            <span class="built_in">down</span>(k), <span class="built_in">up</span>(k);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;k, &amp;x);</span><br><span class="line">            k = ph[k], h[k] = x;</span><br><span class="line">            <span class="built_in">down</span>(k), <span class="built_in">up</span>(k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;模拟堆&quot;&gt;&lt;a href=&quot;#模拟堆&quot; class=&quot;headerlink&quot; title=&quot;模拟堆&quot;&gt;&lt;/a&gt;模拟堆&lt;/h3&gt;&lt;p&gt;接下来看模拟堆，模拟堆比起之前就是多了两个数组，这两个数组属于互为反函数的类型。例如 &lt;code&gt;hp[k] = j&lt;/code&gt;那</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://primeluoqiu.github.io/categories/Algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>1.6分组延时、丢失和吞吐量</title>
    <link href="https://primeluoqiu.github.io/2024/03/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.6/"/>
    <id>https://primeluoqiu.github.io/2024/03/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.6/</id>
    <published>2024-03-23T06:21:33.296Z</published>
    <updated>2024-03-23T12:46:00.036Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/23/4XZbDEld.jpg"                      alt="17.jpg"                ><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/23/wc80rluy.jpg"                      alt="18.jpg"                ><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/23/mMM91mwr.jpg"                      alt="19.jpg"                ><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/23/o4jbDSvk.jpg"                      alt="20.jpg"                ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;https://img2.imgtp.com</summary>
      
    
    
    
    <category term="计网" scheme="https://primeluoqiu.github.io/categories/%E8%AE%A1%E7%BD%91/"/>
    
    
  </entry>
  
  <entry>
    <title>1.5Internet结构和ISP</title>
    <link href="https://primeluoqiu.github.io/2024/03/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.5/"/>
    <id>https://primeluoqiu.github.io/2024/03/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.5/</id>
    <published>2024-03-23T06:21:32.774Z</published>
    <updated>2024-03-23T06:28:30.826Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/23/Y36VrbMf.jpg"                      alt="13.jpg"                ><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/23/FG8Br175.jpg"                      alt="14.jpg"                ><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/23/ZJyEJEkW.jpg"                      alt="15.jpg"                ><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/23/tjVTjn0e.jpg"                      alt="16.jpg"                ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;https://img2.imgtp.com</summary>
      
    
    
    
    <category term="计网" scheme="https://primeluoqiu.github.io/categories/%E8%AE%A1%E7%BD%91/"/>
    
    
  </entry>
  
  <entry>
    <title>1.4接入网和网络媒体</title>
    <link href="https://primeluoqiu.github.io/2024/03/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.4/"/>
    <id>https://primeluoqiu.github.io/2024/03/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.4/</id>
    <published>2024-03-23T06:21:32.245Z</published>
    <updated>2024-03-23T06:28:32.286Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/23/uWbuUjGi.jpg"                      alt="9.jpg"                ><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/23/N5GvtHel.jpg"                      alt="10.jpg"                ><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/23/lppuK39o.jpg"                      alt="11.jpg"                ><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/23/kfjGSqA1.jpg"                      alt="12.jpg"                ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;https://img2.imgtp.com</summary>
      
    
    
    
    <category term="计网" scheme="https://primeluoqiu.github.io/categories/%E8%AE%A1%E7%BD%91/"/>
    
    
  </entry>
  
  <entry>
    <title>1.3网络核心</title>
    <link href="https://primeluoqiu.github.io/2024/03/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.3/"/>
    <id>https://primeluoqiu.github.io/2024/03/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.3/</id>
    <published>2024-03-23T06:21:31.662Z</published>
    <updated>2024-03-23T06:28:32.926Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/23/3d5Unwa7.jpg"                      alt="5.jpg"                ><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/23/5hqppVMQ.jpg"                      alt="6.jpg"                ><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/23/PaiZxOFi.jpg"                      alt="7.jpg"                ><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/23/QaC6Sdnu.jpg"                      alt="8.jpg"                ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;https://img2.imgtp.com</summary>
      
    
    
    
    <category term="计网" scheme="https://primeluoqiu.github.io/categories/%E8%AE%A1%E7%BD%91/"/>
    
    
  </entry>
  
  <entry>
    <title>1.2网络边缘</title>
    <link href="https://primeluoqiu.github.io/2024/03/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.2/"/>
    <id>https://primeluoqiu.github.io/2024/03/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.2/</id>
    <published>2024-03-23T06:21:30.368Z</published>
    <updated>2024-03-23T06:28:33.782Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/23/t3uhqPrU.jpg"                      alt="3.jpg"                ><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/23/mZeqzUZB.jpg"                      alt="4.jpg"                ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;https://img2.imgtp.com</summary>
      
    
    
    
    <category term="计网" scheme="https://primeluoqiu.github.io/categories/%E8%AE%A1%E7%BD%91/"/>
    
    
  </entry>
  
</feed>
