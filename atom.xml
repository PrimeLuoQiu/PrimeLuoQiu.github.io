<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>秋过冬漫长</title>
  
  <subtitle>没有比脚更长的路,走过去就好了</subtitle>
  <link href="https://primeluoqiu.github.io/atom.xml" rel="self"/>
  
  <link href="https://primeluoqiu.github.io/"/>
  <updated>2024-04-06T13:59:01.246Z</updated>
  <id>https://primeluoqiu.github.io/</id>
  
  <author>
    <name>LuoQiu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2.8 TCP套接字编程</title>
    <link href="https://primeluoqiu.github.io/2024/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.8/"/>
    <id>https://primeluoqiu.github.io/2024/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.8/</id>
    <published>2024-04-06T13:57:31.127Z</published>
    <updated>2024-04-06T13:59:01.246Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/04/06/uMODHIAC.jpg"                      alt="56.jpg"                ><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/04/06/ZW10ZehE.jpg"                      alt="57.jpg"                ><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/04/06/MBxZIUZg.jpg"                      alt="58.jpg"                ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;https://img2.imgtp.com</summary>
      
    
    
    
    <category term="计网" scheme="https://primeluoqiu.github.io/categories/%E8%AE%A1%E7%BD%91/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://primeluoqiu.github.io/2024/04/06/Algorithm/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/%E7%AC%AC%E4%B8%80%E7%AB%A0/"/>
    <id>https://primeluoqiu.github.io/2024/04/06/Algorithm/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/%E7%AC%AC%E4%B8%80%E7%AB%A0/</id>
    <published>2024-04-06T13:55:22.142Z</published>
    <updated>2024-04-06T13:54:09.345Z</updated>
    
    <content type="html"><![CDATA[<h3 id="深度优先搜索-DFS"><a href="#深度优先搜索-DFS" class="headerlink" title="深度优先搜索(DFS)"></a>深度优先搜索(DFS)</h3><p>很执着，尽可能的往深搜。当搜不到的时候回溯，然后回溯完之后看看，当前是不是所有的路径都遍历过了。</p><p>对于数据结构来讲：使用的是栈</p><p>空间：O(n)</p><p>不具有最短性</p><p>第一次搜索完之后不一定具备最短性</p><p>存在两个概念</p><h4 id="概念1：回溯"><a href="#概念1：回溯" class="headerlink" title="概念1：回溯"></a>概念1：回溯</h4><h4 id="概念2：剪枝"><a href="#概念2：剪枝" class="headerlink" title="概念2：剪枝"></a>概念2：剪枝</h4><p>DFS最重要的是顺序，要考虑是用一个什么样的顺序来比遍历整个方案。想不清楚的话画棵树考虑一下。</p><p>对于本题而言，顺序有很多种，这里的搜索顺序是假设我们已经有n个空位了，从第一位开始填，从前往后填，每次填的时候数字不能和前面一样就可以了。最开始状态是n个空，第一位有三种填法，分别对应三个不同的分支。深搜的话会继续往下搜，也就是搜第二个位置，第二个位置也有三种方案。但是深搜的时候不会把方案先画出来，直接走到黑。第二位枚举一下，第一位确定了是1，那第二位肯定不能是1，因为重复了，第二位只能先填2，优先往下走，就只剩第三位，那么第三位就只剩下3了，这个时候分支对应的就是123，已经无路可走，然后回退一步。回到填写第二位的时候，发现第二位还有一条路可以走，还可以填3，那么就填上3，就是有3的分支，那么132，再回溯，无路可走，在回溯，回到根节点，这个时候就要枚举2这个分支。</p><p>求全排列的过程，是可以用DFS来做的。搜索顺序可以看成一棵树。当然只是看成一棵树，每次存的时候存储的都是路径，回溯的时候就没了，不需要存数和栈。在回溯的时候一定要记得回复现场。下去的时候是什么样子，回溯回来的话还得是那个样子。走的时候分支看到的状态是一样的。</p><p>看一下代码怎么写：</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> path[N]; <span class="comment">//状态用一个全局数组来存,存储的是方案 </span></span><br><span class="line"><span class="type">bool</span> st[N]; <span class="comment">//true表示点被用过了</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> u)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//当完美走到n,说明全部填满了</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n;i ++) <span class="built_in">cout</span> &lt;&lt; path[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!st[i])</span><br><span class="line">        &#123;</span><br><span class="line">            path[u] = i; <span class="comment">//i放到当前位置上</span></span><br><span class="line">            st[i] = <span class="literal">true</span>; <span class="comment">//记录i已经被用过了</span></span><br><span class="line">            dfs(u + <span class="number">1</span>); <span class="comment">//状态处理好之后递归到下一层</span></span><br><span class="line">            st[i] = <span class="literal">false</span>; <span class="comment">//恢复现场 path不需要回复，会覆盖，递归函数结束之后一定要记得恢复。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    dfs(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>还有一个经典的N皇后问题，有很多种搜索方式</p><p>​在n*n的棋盘上放n个皇后，皇后可以横竖斜着走，让任何两个皇后不能互相攻击到，给定一个n，输出所有的方案</p><p>比如说：搜索全排列的思路是一样的，搜索顺序是：先看一下同一行同一列只放一个皇后，先看第一行皇后可以放在那一列。枚举每一行皇后可以放到哪里去。从第一位开始枚举。递归枚举第二行皇后放到那…这里要注意<strong>剪枝</strong>。这是按照全排列的方法来枚举。</p><p>也可以先生成一个全排列，然后再判断。也是可以的。</p><p>蛋柿呢，也可以边做边判断，假设枚举了一个4，直接判断有没有冲突，如果有冲突，就不用再往下走，直接停止了。可以看作是把枝剪掉，直接回溯，这就是剪枝了。</p><p>那么这种方法对应的解决方案是</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">20</span>;</span><br><span class="line"><span class="type">bool</span> col[N], dg[N], udg[N];</span><br><span class="line"><span class="type">char</span> g[N][N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u == n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) <span class="built_in">puts</span>(g[i]);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!col[i] &amp;&amp; !dg[u + i] &amp;&amp; !udg[n - u + i])</span><br><span class="line">        &#123;</span><br><span class="line">            g[u][i] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">            col[i] = dg[u + i] = udg[n - u + i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(u + <span class="number">1</span>);</span><br><span class="line">            col[i] = dg[u + i] = udg[n - u + i] = <span class="literal">false</span>;</span><br><span class="line">            g[u][i] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++)</span><br><span class="line">            g[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>没有模板，只有顺序和思路。</p><p>除了这种方式之外，我们还可以用一种更原始的方式来解决这种问题。也就是说，对于每个点而言，都有两种状态，分别是放或者不放这两种分支，然后我们挨个枚举所有格子，当枚举到n²格子的时候，就结束了。这个更加原始，更加接近题目的选项的方式</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">20</span>;</span><br><span class="line"><span class="type">bool</span> row[N], col[N], dg[N], udg[N];</span><br><span class="line"><span class="type">char</span> g[N][N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(y == n) y = <span class="number">0</span>, x ++;</span><br><span class="line">    <span class="keyword">if</span>(x == n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s == n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n; i ++) <span class="built_in">puts</span>(g[i]);</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//不放皇后</span></span><br><span class="line">    <span class="built_in">dfs</span>(x, y + <span class="number">1</span>, s);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//放皇后</span></span><br><span class="line">    <span class="keyword">if</span>(!row[x] &amp;&amp; !col[y] &amp;&amp; !dg[x + y] &amp;&amp; !udg[x - y + n])</span><br><span class="line">    &#123;</span><br><span class="line">        g[x][y] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">        row[x] = col[y] = dg[x + y] = udg[x - y + n] = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(x, y + <span class="number">1</span>, s + <span class="number">1</span>);</span><br><span class="line">        row[x] = col[y] = dg[x + y] = udg[x - y + n] = <span class="literal">false</span>;</span><br><span class="line">        g[x][y] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++)</span><br><span class="line">            g[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="宽度优先搜索-BFS"><a href="#宽度优先搜索-BFS" class="headerlink" title="宽度优先搜索(BFS)"></a>宽度优先搜索(BFS)</h3><p>按层搜索。同时看很多条路，第一次看第一层，第二次看第二层。第二层搜完之后再搜第三层。每次只扩展一层。</p><p>数据结构：队列</p><p>空间：O(n^2)</p><p>有最短路的概念，第一次扩展到的点，一定是离他最近的点</p><p>为什么可以呢？是一圈一圈往外扩展，可以搜到的点是离起点越来越远的。第一次搜到的一定是距离最小的。前提是图里的边权重必须都得是1.</p><h3 id="树与图的存储"><a href="#树与图的存储" class="headerlink" title="树与图的存储"></a>树与图的存储</h3><h3 id="树与图的深度优先遍历"><a href="#树与图的深度优先遍历" class="headerlink" title="树与图的深度优先遍历"></a>树与图的深度优先遍历</h3><h3 id="树与图的宽度优先遍历"><a href="#树与图的宽度优先遍历" class="headerlink" title="树与图的宽度优先遍历"></a>树与图的宽度优先遍历</h3><h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;深度优先搜索-DFS&quot;&gt;&lt;a href=&quot;#深度优先搜索-DFS&quot; class=&quot;headerlink&quot; title=&quot;深度优先搜索(DFS)&quot;&gt;&lt;/a&gt;深度优先搜索(DFS)&lt;/h3&gt;&lt;p&gt;很执着，尽可能的往深搜。当搜不到的时候回溯，然后回溯完之后看看，当前是不</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Ts快速入门</title>
    <link href="https://primeluoqiu.github.io/2024/04/06/HarmonyOsDeveloper/Ts%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
    <id>https://primeluoqiu.github.io/2024/04/06/HarmonyOsDeveloper/Ts%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</id>
    <published>2024-04-05T16:37:05.386Z</published>
    <updated>2024-04-05T16:42:07.571Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h3><p>赋值语句:<code>let 变量名: 变量类型  = 值</code></p><p>变量类型还是布尔值、数字、字符串(单引号双引号都可以)、数组、元组、枚举、Unknown、Void和Undefined以及联合类型</p><p>数字：</p><p>所有数字全部都是浮点数，类型是<code>number</code>。支持标准进制</p><div class="highlight-container" data-rel="Ts"><figure class="iseeu highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">decLiteral</span>: <span class="built_in">number</span> = <span class="number">2023</span>;</span><br></pre></td></tr></table></figure></div><p>两种定义方式:</p><p>元素后+[]，表示由此类型元素组成的一个数组</p><div class="highlight-container" data-rel="Typescript"><figure class="iseeu highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">list</span>: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure></div><p>第二种:使用数组泛型，Array&lt;元素类型&gt;</p><div class="highlight-container" data-rel="Ts"><figure class="iseeu highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">list</span>: <span class="title class_">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure></div><p>元组：元组类型允许表示一个已知元素数量和类型的数组。各元素的类型不必相同。比如，可以定义一对值分别为<code>string</code>和<code>number</code>类型的元组，顺序不可相反</p><div class="highlight-container" data-rel="Ts"><figure class="iseeu highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">x</span>: [<span class="built_in">string</span>, <span class="built_in">number</span>];</span><br><span class="line">x = [<span class="string">&#x27;hello&#x27;</span>, <span class="number">10</span>];</span><br></pre></td></tr></table></figure></div><p>枚举：</p><p><code>enum</code>类型是对js标准数据类型的一个补充，使用枚举类型可以为一组数值赋予友好的名字</p><div class="highlight-container" data-rel="Ts"><figure class="iseeu highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;<span class="title class_">Red</span>, <span class="title class_">Green</span>, <span class="title class_">Blue</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">c</span>: <span class="title class_">Color</span> = <span class="title class_">Color</span>.<span class="property">Green</span>; </span><br></pre></td></tr></table></figure></div><p>Unknow:为编程阶段还尚不清楚类型的变量指定一个类型。在这种情况下，不希望类型检查器对这些值进行检查而实直接通过编译阶段的检查。便可以使用Unknown</p><p>Void还是出现在函数返回值类型。</p><p>在ts中，undefined和null各自有自己的类型分别叫做undefined和null</p><p>联合类型(Union Type): 取值可以为多种类型中的一种</p><div class="highlight-container" data-rel="Ts"><figure class="iseeu highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">myFavouriteNumver</span>: <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line">myFavouriteNumber = <span class="string">&#x27;seven&#x27;</span>;</span><br><span class="line">myFavouriteNumber = <span class="number">7</span>;</span><br></pre></td></tr></table></figure></div><hr><h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><p>通过一条或者多条的执行结果来决定执行的代码块</p><h4 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h4><div class="highlight-container" data-rel="Ts"><figure class="iseeu highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="attr">num</span>: <span class="built_in">number</span> = <span class="number">5</span></span><br><span class="line"><span class="keyword">if</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;数字是正数&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>其他的和C语言类似</p><h4 id="switch…case语句"><a href="#switch…case语句" class="headerlink" title="switch…case语句"></a>switch…case语句</h4><div class="highlight-container" data-rel="Ts"><figure class="iseeu highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="attr">grade</span>: <span class="built_in">string</span> = <span class="string">&#x27;A&#x27;</span></span><br><span class="line"><span class="keyword">switch</span>(grade) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>: &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;优秀&#x27;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span>: &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;良&#x27;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span>: &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;及格&#x27;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attr">default</span>: &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;非法输入&#x27;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><hr><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>是一组一起执行一个任务的语句，函数声明要告诉编译器函数的名称、返回类型和参数。Ts可以创建有名的函数和匿名函数，创建方法如下</p><div class="highlight-container" data-rel="Ts"><figure class="iseeu highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//有名函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//匿名函数</span></span><br><span class="line"><span class="keyword">let</span> myAdd = <span class="keyword">function</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><h4 id="为函数定义类型"><a href="#为函数定义类型" class="headerlink" title="为函数定义类型"></a>为函数定义类型</h4><p>为了确保输入输出的准确性，我们可以为函数添加类型:</p><div class="highlight-container" data-rel="Ts"><figure class="iseeu highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有名函数: 给变量设置为number类型</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匿名函数: 给变量设置为number类型</span></span><br><span class="line"><span class="keyword">let</span> myAdd = <span class="keyword">function</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h4><p>在Ts里可以在参数名旁边使用<code>?</code>实现可选参数的功能。比如，我们想让lastName是可选的:</p><div class="highlight-container" data-rel="Ts"><figure class="iseeu highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">buildName</span>(<span class="params">firstName: <span class="built_in">string</span>, lastName?: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(lastName)</span><br><span class="line">        <span class="keyword">return</span> firstName + <span class="string">&#x27; &#x27;</span> + lastName;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> firstName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = <span class="title function_">buildName</span>(<span class="string">&#x27;Bob&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> result2 = <span class="title function_">buildName</span>(<span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Adams&#x27;</span>);</span><br></pre></td></tr></table></figure></div><h4 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h4><p>剩余参数会被当做个数不限的可选参数，可以一个都没有，同样也可以有任意个。可以使用省略号(…)进行定义:</p><div class="highlight-container" data-rel="Ts"><figure class="iseeu highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getEmployeeName</span>(<span class="params">firstName: <span class="built_in">string</span>, ...restOfName: <span class="built_in">string</span>[]</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> firstName + <span class="string">&#x27; &#x27;</span> + restOfName.<span class="title function_">join</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> employeeName = <span class="title function_">getEmployeeName</span>(<span class="string">&#x27;Joseph&#x27;</span>, <span class="string">&#x27;Samuel&#x27;</span>, <span class="string">&#x27;Luces&#x27;</span>, <span class="string">&#x27;MacKinzie&#x27;</span>);</span><br></pre></td></tr></table></figure></div><h4 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h4><p>es6版本的ts提供了一个箭头函数，它是定义匿名函数的简写语法，用于函数表达式，省略了function关键字。箭头函数的定义如下，其函数是一个语句块:</p><div class="highlight-container" data-rel="Ts"><figure class="iseeu highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">( [param1, param2, ... param n] ) =&gt; &#123;</span><br><span class="line">    <span class="comment">//代码块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>其中，括号内是函数的入参，可以有0到多个参数，箭头后是函数的代码块。我们可以将这个箭头函数赋值给一个变量，如下所示</p><div class="highlight-container" data-rel="Ts"><figure class="iseeu highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">arrowFun</span> = (<span class="params"> [param1, param2, ... param n] </span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">//代码块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>如何要主动调用这个箭头函数，可以按如下方法调用:</p><div class="highlight-container" data-rel="Ts"><figure class="iseeu highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">arrowFun</span>(param1, param2, ... param n)</span><br></pre></td></tr></table></figure></div><p>那么如何将熟悉的函数定义方式转换成箭头函数</p><div class="highlight-container" data-rel="Ts"><figure class="iseeu highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">testNumber</span>(<span class="params">num: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">testArrowFun</span> = (<span class="params">num: <span class="built_in">number</span></span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">//函数体内容一致</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>后面在开发HarmonyOS时会经常用到箭头函数。例如，给一个按钮添加点击事件，其中onClick事件中的函数就是箭头函数</p><div class="highlight-container" data-rel="Ts"><figure class="iseeu highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Button</span>(<span class="string">&quot;Click Now&quot;</span>)</span><br><span class="line">.<span class="title function_">onClick</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">info</span>(<span class="string">&quot;Button is click&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div><hr><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>Ts支持基于类的面向对象的编程方式，定义类的关键字为class，后面紧跟类名。类描述了所创建的对象共同的属性和方法。</p><h4 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h4><p>例如，我们可以声明一个Person类，这个类有三个成员：一个是属性(包含name和age)，一个是构造函数，一个是getPersonInfo方法，其定义如下所示</p><div class="highlight-container" data-rel="Ts"><figure class="iseeu highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">    <span class="keyword">private</span> <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">    </span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">getPersonInfo</span>(): <span class="built_in">string</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;My name is $&#123;this.name&#125; and age is $&#123;this.age&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>继承就是子类继承父类的特征和行为，使得子类具有父亲相同的行为。Ts中允许使用继承来扩展现有的类，对应的关键字为extend。</p><div class="highlight-container" data-rel="Ts"><figure class="iseeu highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="attr">department</span>: <span class="built_in">string</span></span><br><span class="line">    </span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span>, department: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>(name, age);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">department</span> = department;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">getEmployeeInfo</span>(): <span class="built_in">string</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">getPersonInfo</span>() + <span class="string">`and work in <span class="subst">$&#123;<span class="variable language_">this</span>.department&#125;</span>`</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>通过上面的Employee类，可以定义一个人物并获取他的基本信息，具体使用场景参考相关学习资料。</p><h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p>随着应用越来越大，通常要将代码拆分成多个文件，即所谓的模块（module）。模块可以相互加载，并可以使用特殊的指令 export 和 import 来交换功能，从另一个模块调用一个模块的函数。</p><p>两个模块之间的关系是通过在文件级别上使用 import 和 export 建立的。模块里面的变量、函数和类等在模块外部是不可见的，除非明确地使用 export 导出它们。类似地，我们必须通过 import 导入其他模块导出的变量、函数、类等。</p><h4 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h4><p>任何声明(比如变量、函数、类、类型别名和接口)都能通过添加export关键字来导出，例如要导出一个类</p><div class="highlight-container" data-rel="Ts"><figure class="iseeu highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">NewsData</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h4><div class="highlight-container" data-rel="Ts"><figure class="iseeu highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;<span class="title class_">NewsData</span>&#125; <span class="keyword">from</span> <span class="string">&#x27;../common/bean/NewsData&#x27;</span>;</span><br></pre></td></tr></table></figure></div><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>当一个对象实现了Symbol.iterator属性时，我们认为它是可迭代的。一些内置的类型如Array，Map，Set，String，Int32Array，Uint32Array等都具有可迭代性。</p><h4 id="for…of语句"><a href="#for…of语句" class="headerlink" title="for…of语句"></a>for…of语句</h4><p>for..of会遍历可迭代的对象，调用对象上的Symbol.iterator方法。下面是在数组上使用for..of的简单例子:</p><div class="highlight-container" data-rel="Ts"><figure class="iseeu highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> someArray = [<span class="number">1</span>, <span class="string">&quot;string&quot;</span>, <span class="literal">false</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> entry <span class="keyword">of</span> someArray) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(entry); <span class="comment">// 1, &quot;string&quot;, false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="for…in语句"><a href="#for…in语句" class="headerlink" title="for…in语句"></a>for…in语句</h4><p>上述两种方式均可迭代一个列表，但是用于迭代的值却不同:for…in迭代的是对象的键，而for..of则迭代的是对象的值</p><div class="highlight-container" data-rel="Ts"><figure class="iseeu highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> list = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> list) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i) <span class="comment">// &quot;0&quot;, &quot;1&quot;, &quot;2&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> <span class="keyword">in</span> <span class="keyword">of</span> list) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">//&quot;4&quot;, &quot;5&quot;, &quot;6&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>TypeScript是一个开源的编程语言，本章节只有TypeScript的基础语法知识，更多内容参考TypeScript的官方教程（<a class="link"   href="https://www.typescriptlang.org/docs/%EF%BC%89%E3%80%82" >https://www.typescriptlang.org/docs/）。 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;基础类型&quot;&gt;&lt;a href=&quot;#基础类型&quot; class=&quot;headerlink&quot; title=&quot;基础类型&quot;&gt;&lt;/a&gt;基础类型&lt;/h3&gt;&lt;p&gt;赋值语句:&lt;code&gt;let 变量名: 变量类型  = 值&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;变量类型还是布尔值、数字、字符串(单</summary>
      
    
    
    
    <category term="OpenHarmonyDeveloper" scheme="https://primeluoqiu.github.io/categories/OpenHarmonyDeveloper/"/>
    
    
  </entry>
  
  <entry>
    <title>2.7 CDN(内容分发网络)</title>
    <link href="https://primeluoqiu.github.io/2024/04/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.7/"/>
    <id>https://primeluoqiu.github.io/2024/04/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.7/</id>
    <published>2024-04-05T06:31:06.791Z</published>
    <updated>2024-04-05T06:33:13.372Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/04/05/FoZrhkS8.jpg"                      alt="54.jpg"                ><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/04/05/QvnBufgw.jpg"                      alt="55.jpg"                ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;https://img2.imgtp.com</summary>
      
    
    
    
    <category term="计网" scheme="https://primeluoqiu.github.io/categories/%E8%AE%A1%E7%BD%91/"/>
    
    
  </entry>
  
  <entry>
    <title>2.6 P2P</title>
    <link href="https://primeluoqiu.github.io/2024/04/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.6/"/>
    <id>https://primeluoqiu.github.io/2024/04/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.6/</id>
    <published>2024-04-04T15:29:50.750Z</published>
    <updated>2024-04-04T15:30:55.076Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/04/04/R3X2Nco5.jpg"                      alt="50.jpg"                ><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/04/04/TFIyogDt.jpg"                      alt="51.jpg"                ><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/04/04/CUZMPxTG.jpg"                      alt="52.jpg"                ><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/04/04/ayBVCH5r.jpg"                      alt="53.jpg"                ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;https://img2.imgtp.com</summary>
      
    
    
    
    <category term="计网" scheme="https://primeluoqiu.github.io/categories/%E8%AE%A1%E7%BD%91/"/>
    
    
  </entry>
  
  <entry>
    <title>2.5 DNS</title>
    <link href="https://primeluoqiu.github.io/2024/04/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.5/"/>
    <id>https://primeluoqiu.github.io/2024/04/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.5/</id>
    <published>2024-04-03T14:32:46.454Z</published>
    <updated>2024-04-03T14:42:13.470Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/04/03/eDDtt0xR.jpg"                      alt="45.jpg"                ><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/04/03/7QasoPyg.jpg"                      alt="46.jpg"                ><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/04/03/rQvuGoqE.jpg"                      alt="47.jpg"                ><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/04/03/dXTAhcmR.jpg"                      alt="48.jpg"                ><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/04/03/GXV38DGF.jpg"                      alt="49.jpg"                ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;https://img2.imgtp.com</summary>
      
    
    
    
    <category term="计网" scheme="https://primeluoqiu.github.io/categories/%E8%AE%A1%E7%BD%91/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://primeluoqiu.github.io/2024/04/02/Algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(%E4%B8%89)/"/>
    <id>https://primeluoqiu.github.io/2024/04/02/Algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(%E4%B8%89)/</id>
    <published>2024-04-02T14:10:44.252Z</published>
    <updated>2024-04-02T14:11:48.550Z</updated>
    
    <content type="html"><![CDATA[<hr><p>title: 哈希表和STL</p><p>categories: Algorithm</p><hr><h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><p>哈希表实际上就是把一个很大范围的数据结构映射成为一个很小的数据范围的东西。举例来说，比如说想把从0-10的9次方这些数映射到从0到10的五次方左右的一些数。</p><p>比如现在有一批数的范围是-10九次方到+10的九次方，然后通过一个哈希函数把它们放进一个很小的(10的五次方)的范围之内。</p><p>哈希函数的一些问题，例如：</p><ol><li><p>哈希函数一般怎么写：就是直接模一个数，例如可以直接模10^5。</p></li><li><p>冲突定义域比较大，映射的结果比较小，那么必然会产生冲突，把两个不一样的数映射到同一个数。按照处理冲突的方式分为开放寻址法和拉链法。</p></li></ol><h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><h3 id="开放寻址法"><a href="#开放寻址法" class="headerlink" title="开放寻址法"></a>开放寻址法</h3><p>通俗来讲的话，也叫蹲坑法，什么意思呢，就是说，我们只需要一个数组就可以了，但是这个数组的大小一般要开到题目范围的2-3倍，然后就像大家上厕所一样，当一个坑位被占了的时候，只能去找下一个坑位，然后下一个坑位被占了再找下一个，也就意味着说，我们先通过函数来寻找到k，但是如果那个k被占用了的话，那么就去k+1，如果k+1被占用了，就去k+2…</p><p>然后这个方法主要就是find函数的实现，然后插入的话，就是通过find找到对应的位置，然后把x放进去就可以了，而查找的话就是如果对应的位置不是空的，那么就是有的，不然就是没有。删除其实也可以看做另外一种形式的查找，因为并不是真正的删除，而是对那个点做一个标记</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e6</span> + <span class="number">3</span>, null = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> h[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k = (x % N + N) % N;</span><br><span class="line">    <span class="keyword">while</span>(h[k] != null &amp;&amp; h[k] != x)</span><br><span class="line">    &#123;</span><br><span class="line">        k ++;</span><br><span class="line">        <span class="keyword">if</span>(k == N) k = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(h));</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(n --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d&quot;</span>, op, &amp;x);</span><br><span class="line">        <span class="type">int</span> k = <span class="built_in">find</span>(x);</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">&#x27;I&#x27;</span>) h[k] = x;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(h[k] != null)</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h3><p>简单来讲，就是说，先开出来一个空间，然后例如我们把h(11)映射到了3，h(23)也映射到了3，这个时候，我们就在3的下面拉一个线，类似拉链一样。多一个点就多一个线。然后一般哈希表只会存在两种操作，分别是添加和查找，添加很简单，只需要通过对应的哈希函数找到它的位置，然后添加一条拉链就可以了，查找的话，就是先看出来这个数值哈希完之后是什么，如果是某个点，然后顺着那个点去查找是不是有那个值。一般不会有删除操作的，就算有，也不是真的把那个数值删了，而是给那个点打个标记，例如布尔变量，然后就删除掉了。</p><p>这里要注意一个点，我们的哈希函数模的那个值最好是一个质数，而且距离2的多少次方比较远，这样能够保证冲突的概率是最小的。</p><p>接下来，看一下我们拉链法的模板</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> h[N], e[N], ne[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k = (x % N + N) % N;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    ne[idx] = h[k];</span><br><span class="line">    h[k] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k = (x % N + N) % N;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[k]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(e[i] == x)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="built_in">sizeof</span>(h));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(n --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d&quot;</span>, op, &amp;x);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">&#x27;I&#x27;</span>) <span class="built_in">insert</span>(x);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(x)) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="字符串哈希方式"><a href="#字符串哈希方式" class="headerlink" title="字符串哈希方式"></a>字符串哈希方式</h2><p>一种特殊的方式：字符串前缀哈希法。</p><p>求哈希之前，先预处理出来所有前缀的哈希。</p><p>那么如何处理出来所有前缀的哈希呢？</p><p>我们可以把每个字符串看成是一个<code>P</code>进制的数，例如”ABCD”是一个p进制的数，然后我们将它转化成为一个十进制的数，那么”ABCD”如果分别代表第一位第二位第三位和第四位的话，那么它可以转化成<br>$$<br>1<em>p^3+2</em>p^2+3<em>p^1+4</em>p^0<br>$$<br>那么当这个字符串比较长的时候，这个数值就会变得很大，那么我们不妨给它模一个<code>Q</code>让他变小，然后我们就把范围缩小到了0-<code>Q-1</code></p><p>不过有两个值得注意的点</p><ol><li>首先是任何一个字母都不能映射成0，毕竟0在任何进制上转换成十进制的时候都是0。</li><li>这个是建立在我们rp(人品)足够好的前提下，也就是说不存在冲突的情况。</li></ol><p>不过这倒是有个经验值可以保证在99.99%的前提下不会出现冲突，就是指当p &#x3D; 131&#x2F;13331，且Q &#x3D; 2^64的时候，就可以了</p><p>这么处理的好处是什么呢？</p><p>就是说我们可以通过一个公式来计算出所有子串的哈希值。</p><p>那么，具体是什么公式呢？</p><p>就是说，有一个线段，例如从L-R，那么我们把从1-L这一段让它和L-R这一段对齐，那么用这两段相减就可以了。那么最后的公式就是</p><p>h[R] - h[L] * p ^ (R - L + 1)</p><p>Q是等于2^64,如果我们这个时候开一个<code>unsigned long long</code>的话，那么只要溢出的话就相当于是自动模上2^64了</p><p>预处理的话就是</p><p><code>h(i) = h(i - 1) * p + str[i]</code></p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ULL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>, P = <span class="number">131</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">char</span> str[N];</span><br><span class="line">ULL h[N], p[N]; <span class="comment">//p[N]用来存储公式中的L-R+1</span></span><br><span class="line"></span><br><span class="line"><span class="function">ULL <span class="title">get</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h[r] - h[l - <span class="number">1</span>] * p[r - l + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%s&quot;</span>, &amp;n, &amp;m, str + <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        p[i] = p[i - <span class="number">1</span>] * P;</span><br><span class="line">        h[i] = h[i - <span class="number">1</span>] * P + str[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (m --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l1, r1, l2, r2;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;l1, &amp;r1, &amp;l2, &amp;r2);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">get</span>(l1, r1) == <span class="built_in">get</span>(l2, r2)) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h1 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h1><h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><p>实际上就是一个变长数组，倍增的思想。</p><p>有这样的一些函数</p><p><code>size()</code>返回元素个数</p><p><code>empty()</code>返回是否为空</p><p><code>clean()</code>清空这个vector</p><p><code>front()/ back()</code>最前面的和最后面的</p><p><code>push_back() / pop_back()</code>在最后插入和把最后一个删掉</p><p><code>begin() / end()</code>第0个和最后一个的后一个，也就是迭代器。</p><h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><p>字符串，一些常用的函数例如<code>substr()</code>、<code>c_str()</code></p><h3 id="queue-priority-queue"><a href="#queue-priority-queue" class="headerlink" title="queue, priority_queue"></a>queue, priority_queue</h3><p>队列,<code>push()</code>, <code>pop()</code> ,<code>front()</code></p><h3 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h3><p>栈,<code>push()</code>, <code>pop()</code>, <code>front()</code></p><h3 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h3><p>双端队列，也就是在队列的基础上让队列的头和尾都可以插入和删除</p><h3 id="set-map-multiset-multimap"><a href="#set-map-multiset-multimap" class="headerlink" title="set, map, multiset, multimap"></a>set, map, multiset, multimap</h3><p>基于平衡二叉树(红黑树)，动态维护有序序列</p><h3 id="unordered-map-unordered-set-unordered-multiset-unordered-multimap"><a href="#unordered-map-unordered-set-unordered-multiset-unordered-multimap" class="headerlink" title="unordered_map, unordered_set, unordered_multiset, unordered_multimap"></a>unordered_map, unordered_set, unordered_multiset, unordered_multimap</h3><p>哈希表</p><h3 id="bitset"><a href="#bitset" class="headerlink" title="bitset"></a>bitset</h3><p>压位</p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;p&gt;title: 哈希表和STL&lt;/p&gt;
&lt;p&gt;categories: Algorithm&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;哈希表&quot;&gt;&lt;a href=&quot;#哈希表&quot; class=&quot;headerlink&quot; title=&quot;哈希表&quot;&gt;&lt;/a&gt;哈希表&lt;/h1&gt;&lt;p&gt;哈希表实际</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>2.3 &amp; 2.4 FTP &amp; Email</title>
    <link href="https://primeluoqiu.github.io/2024/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.3.4/"/>
    <id>https://primeluoqiu.github.io/2024/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.3.4/</id>
    <published>2024-04-02T11:50:04.609Z</published>
    <updated>2024-04-02T11:51:37.209Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/04/02/eQAl7p0k.jpg"                      alt="42.jpg"                ><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/04/02/qbJOFAiA.jpg"                      alt="43.jpg"                ><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/04/02/rW9brCrU.jpg"                      alt="44.jpg"                ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;https://img2.imgtp.com</summary>
      
    
    
    
    <category term="计网" scheme="https://primeluoqiu.github.io/categories/%E8%AE%A1%E7%BD%91/"/>
    
    
  </entry>
  
  <entry>
    <title>Week5 and Daily Schedule</title>
    <link href="https://primeluoqiu.github.io/2024/04/01/%E6%AF%8F%E5%91%A8%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/Week5/"/>
    <id>https://primeluoqiu.github.io/2024/04/01/%E6%AF%8F%E5%91%A8%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/Week5/</id>
    <published>2024-04-01T13:54:40.572Z</published>
    <updated>2024-04-01T15:06:28.953Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Daily-Schedule"><a href="#Daily-Schedule" class="headerlink" title="Daily Schedule"></a>Daily Schedule</h1><h2 id="Total-Schedule"><a href="#Total-Schedule" class="headerlink" title="Total Schedule"></a>Total Schedule</h2><ol><li>《计算机网络》-郑铨老师的 2.3-2.10(第二章看完)</li><li>CS61A 看完第一章</li><li>每天更新一点算法内容</li></ol><p>每天任务的话，先看周一吧，周一相对来说课不算多，下午有一节毛概，毛概课的话得补半节课的数电笔记和作业</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Daily-Schedule&quot;&gt;&lt;a href=&quot;#Daily-Schedule&quot; class=&quot;headerlink&quot; title=&quot;Daily Schedule&quot;&gt;&lt;/a&gt;Daily Schedule&lt;/h1&gt;&lt;h2 id=&quot;Total-Schedule&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="大二下" scheme="https://primeluoqiu.github.io/categories/%E5%A4%A7%E4%BA%8C%E4%B8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>Week4 总结</title>
    <link href="https://primeluoqiu.github.io/2024/04/01/%E6%AF%8F%E5%91%A8%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/Week4%E6%80%BB%E7%BB%93/"/>
    <id>https://primeluoqiu.github.io/2024/04/01/%E6%AF%8F%E5%91%A8%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/Week4%E6%80%BB%E7%BB%93/</id>
    <published>2024-04-01T13:51:52.141Z</published>
    <updated>2024-04-01T13:54:24.593Z</updated>
    
    <content type="html"><![CDATA[<p>本周内容学习的不多，不过计网内容算是比较完美的达成了，就是昨天身体不大舒服，不然熬一下基本上任务就完成了。这种每周都有任务的感觉还是蛮爽的。然后其实还是很喜欢这种每天都有一定的任务量的感觉，这样的话完成之后内心也会收获一份成就感。</p><p>CS61A的进度不算很快，也不知道是不是学习方法的问题，现在进展速度奇慢，61B也没来得及看，更别提61C和CSAPP了，下周还有蓝桥杯要准备。加油吧，还要再重温一下算法的相关知识。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本周内容学习的不多，不过计网内容算是比较完美的达成了，就是昨天身体不大舒服，不然熬一下基本上任务就完成了。这种每周都有任务的感觉还是蛮爽的。然后其实还是很喜欢这种每天都有一定的任务量的感觉，这样的话完成之后内心也会收获一份成就感。&lt;/p&gt;
&lt;p&gt;CS61A的进度不算很快，也</summary>
      
    
    
    
    <category term="大二下" scheme="https://primeluoqiu.github.io/categories/%E5%A4%A7%E4%BA%8C%E4%B8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>哈希表</title>
    <link href="https://primeluoqiu.github.io/2024/04/01/Algorithm/hashtable/"/>
    <id>https://primeluoqiu.github.io/2024/04/01/Algorithm/hashtable/</id>
    <published>2024-04-01T13:51:04.389Z</published>
    <updated>2024-04-01T13:51:37.676Z</updated>
    
    <content type="html"><![CDATA[<h3 id="模拟堆"><a href="#模拟堆" class="headerlink" title="模拟堆"></a>模拟堆</h3><p>接下来看模拟堆，模拟堆比起之前就是多了两个数组，这两个数组属于互为反函数的类型。例如 <code>hp[k] = j</code>那么<code>ph[j] = k</code>，一个是对应着在堆里的下标，另一个对应的是下标对应的值。 那么对应的，在进行交换的时候，就不能只考虑值之间的交换了，就还得考虑数组之间的交换。这个时候，就需要一个全新的函数了</p><p>因为题目中要考虑第k个数，那么就需要两个数组来存储第k个数是什么<br>ph[k]存的是第k个插入的数在堆里的下标是什么,还需要一个hp[k],用来存的是堆的某个点是第几个插入的点。</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap_head</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="built_in">swap</span>(ph[hp[a]], ph[hp[b]]);  </span><br><span class="line">    <span class="built_in">swap</span>(hp[a], hp[b]);  </span><br><span class="line">    <span class="built_in">swap</span>(a, b);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>然后就是把所有的<code>swap</code>函数进行更换为堆里面特有的<code>swap</code>。<br>这个方法不常用，但是djikstra堆优化是常用的，所以要了解一下</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, a, b;</span><br><span class="line"><span class="type">int</span> h[N], cnt, ph[N], hp[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heap_swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">swap</span>(ph[hp[a]], ph[hp[b]]);</span><br><span class="line">    <span class="built_in">swap</span>(hp[a], hp[b]);</span><br><span class="line">    <span class="built_in">swap</span>(h[a], h[b]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = u;</span><br><span class="line">    <span class="keyword">if</span>(u * <span class="number">2</span> &lt;= cnt &amp;&amp; h[u * <span class="number">2</span>] &lt; h[t]) t = u * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(u * <span class="number">2</span> + <span class="number">1</span> &lt;= cnt &amp;&amp; h[u * <span class="number">2</span> + <span class="number">1</span>] &lt; h[t]) t = u * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(u != t)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">heap_swap</span>(u, t);</span><br><span class="line">        <span class="built_in">down</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(u / <span class="number">2</span> &amp;&amp; h[u / <span class="number">2</span>] &gt; h[u])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">heap_swap</span>(u, u / <span class="number">2</span>);</span><br><span class="line">        u &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(n --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> op[<span class="number">10</span>];</span><br><span class="line">        <span class="type">int</span> k, x;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, op);</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(op, <span class="string">&quot;I&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">            cnt ++;</span><br><span class="line">            m ++;</span><br><span class="line">            ph[m] = cnt, hp[cnt] = m;</span><br><span class="line">            h[cnt] = x;</span><br><span class="line">            <span class="built_in">up</span>(cnt);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(op, <span class="string">&quot;PM&quot;</span>)) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, h[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(op, <span class="string">&quot;DM&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">heap_swap</span>(<span class="number">1</span>, cnt);</span><br><span class="line">            cnt --;</span><br><span class="line">            <span class="built_in">down</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(op, <span class="string">&quot;D&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;k);</span><br><span class="line">            k = ph[k];</span><br><span class="line">            <span class="built_in">heap_swap</span>(k, cnt);</span><br><span class="line">            cnt --;</span><br><span class="line">            <span class="built_in">down</span>(k), <span class="built_in">up</span>(k);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;k, &amp;x);</span><br><span class="line">            k = ph[k], h[k] = x;</span><br><span class="line">            <span class="built_in">down</span>(k), <span class="built_in">up</span>(k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><p>哈希表实际上就是把一个很大范围的数据结构映射成为一个很小的数据范围的东西。举例来说，比如说想把从0-10的9次方这些数映射到从0到10的五次方左右的一些数。</p><p>比如现在有一批数的范围是-10九次方到+10的九次方，然后通过一个哈希函数把它们放进一个很小的(10的五次方)的范围之内。</p><p>哈希函数的一些问题，例如：</p><ol><li><p>哈希函数一般怎么写：就是直接模一个数，例如可以直接模10^5。</p></li><li><p>冲突定义域比较大，映射的结果比较小，那么必然会产生冲突，把两个不一样的数映射到同一个数。按照处理冲突的方式分为开放寻址法和拉链法。</p></li></ol><h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><h3 id="开放寻址法"><a href="#开放寻址法" class="headerlink" title="开放寻址法"></a>开放寻址法</h3><p>通俗来讲的话，也叫蹲坑法，什么意思呢，就是说，我们只需要一个数组就可以了，但是这个数组的大小一般要开到题目范围的2-3倍，然后就像大家上厕所一样，当一个坑位被占了的时候，只能去找下一个坑位，然后下一个坑位被占了再找下一个，也就意味着说，我们先通过函数来寻找到k，但是如果那个k被占用了的话，那么就去k+1，如果k+1被占用了，就去k+2…</p><p>然后这个方法主要就是find函数的实现，然后插入的话，就是通过find找到对应的位置，然后把x放进去就可以了，而查找的话就是如果对应的位置不是空的，那么就是有的，不然就是没有。删除其实也可以看做另外一种形式的查找，因为并不是真正的删除，而是对那个点做一个标记</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e6</span> + <span class="number">3</span>, null = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> h[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k = (x % N + N) % N;</span><br><span class="line">    <span class="keyword">while</span>(h[k] != null &amp;&amp; h[k] != x)</span><br><span class="line">    &#123;</span><br><span class="line">        k ++;</span><br><span class="line">        <span class="keyword">if</span>(k == N) k = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(h));</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(n --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d&quot;</span>, op, &amp;x);</span><br><span class="line">        <span class="type">int</span> k = <span class="built_in">find</span>(x);</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">&#x27;I&#x27;</span>) h[k] = x;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(h[k] != null)</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h3><p>简单来讲，就是说，先开出来一个空间，然后例如我们把h(11)映射到了3，h(23)也映射到了3，这个时候，我们就在3的下面拉一个线，类似拉链一样。多一个点就多一个线。然后一般哈希表只会存在两种操作，分别是添加和查找，添加很简单，只需要通过对应的哈希函数找到它的位置，然后添加一条拉链就可以了，查找的话，就是先看出来这个数值哈希完之后是什么，如果是某个点，然后顺着那个点去查找是不是有那个值。一般不会有删除操作的，就算有，也不是真的把那个数值删了，而是给那个点打个标记，例如布尔变量，然后就删除掉了。</p><p>这里要注意一个点，我们的哈希函数模的那个值最好是一个质数，而且距离2的多少次方比较远，这样能够保证冲突的概率是最小的。</p><p>接下来，看一下我们拉链法的模板</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> h[N], e[N], ne[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k = (x % N + N) % N;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    ne[idx] = h[k];</span><br><span class="line">    h[k] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k = (x % N + N) % N;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[k]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(e[i] == x)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="built_in">sizeof</span>(h));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(n --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d&quot;</span>, op, &amp;x);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">&#x27;I&#x27;</span>) <span class="built_in">insert</span>(x);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(x)) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="字符串哈希方式"><a href="#字符串哈希方式" class="headerlink" title="字符串哈希方式"></a>字符串哈希方式</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;模拟堆&quot;&gt;&lt;a href=&quot;#模拟堆&quot; class=&quot;headerlink&quot; title=&quot;模拟堆&quot;&gt;&lt;/a&gt;模拟堆&lt;/h3&gt;&lt;p&gt;接下来看模拟堆，模拟堆比起之前就是多了两个数组，这两个数组属于互为反函数的类型。例如 &lt;code&gt;hp[k] = j&lt;/code&gt;那</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://primeluoqiu.github.io/categories/Algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>2.2 Web &amp; HTTP</title>
    <link href="https://primeluoqiu.github.io/2024/04/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.2/"/>
    <id>https://primeluoqiu.github.io/2024/04/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.2/</id>
    <published>2024-04-01T09:17:42.879Z</published>
    <updated>2024-04-01T11:08:04.359Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/04/01/2rzwqWwz.jpg"                      alt="37.jpg"                ><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/04/01/B3XokmUT.jpg"                      alt="38.jpg"                ><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/04/01/40radGgU.jpg"                      alt="39.jpg"                ><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/04/01/CDSUceBp.jpg"                      alt="40.jpg"                ><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/04/01/nSBajZgM.jpg"                      alt="41.jpg"                ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;https://img2.imgtp.com</summary>
      
    
    
    
    <category term="计网" scheme="https://primeluoqiu.github.io/categories/%E8%AE%A1%E7%BD%91/"/>
    
    
  </entry>
  
  <entry>
    <title>0401日记</title>
    <link href="https://primeluoqiu.github.io/2024/04/01/Dairy/0401/"/>
    <id>https://primeluoqiu.github.io/2024/04/01/Dairy/0401/</id>
    <published>2024-04-01T09:17:30.561Z</published>
    <updated>2024-04-01T15:10:33.935Z</updated>
    
    <content type="html"><![CDATA[<p>今天到目前为止似乎有一点点恢复，但是嗓子还是时不时的痛一会，早上花了110块钱报了软考，网络工程师，得等到蓝桥杯结束之后再看情况准备这个了。不过好在今天状态还行，学习的内容也不算很多。不过感觉也还好，该学习的时候学习，该放松的时候就好好放松一下。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天到目前为止似乎有一点点恢复，但是嗓子还是时不时的痛一会，早上花了110块钱报了软考，网络工程师，得等到蓝桥杯结束之后再看情况准备这个了。不过好在今天状态还行，学习的内容也不算很多。不过感觉也还好，该学习的时候学习，该放松的时候就好好放松一下。&lt;/p&gt;
</summary>
      
    
    
    
    <category term="Dairy" scheme="https://primeluoqiu.github.io/categories/Dairy/"/>
    
    
  </entry>
  
  <entry>
    <title>3月31号日记</title>
    <link href="https://primeluoqiu.github.io/2024/03/31/Dairy/0331/"/>
    <id>https://primeluoqiu.github.io/2024/03/31/Dairy/0331/</id>
    <published>2024-03-31T15:27:26.331Z</published>
    <updated>2024-03-31T15:36:28.667Z</updated>
    
    <content type="html"><![CDATA[<pre><code>今天身体不大舒服，早上起来之后就直接嗓子痛，很难受，然后晚上的话嗓子似乎好了一些，但是头有点晕，然后右胳膊也不是很舒服，一种酸痛的感觉。然后想学感觉脑子也跟不上了，这周任务还是没有完成，身体还是要好好养着的，不能太累，也不能太慵懒。也许是最近喝水不太多，也许是这两天做裁判有点累，今天还没休息的过来。然后就出去玩了一天，下午还洗了个澡。应该问题不大，下周有一个清明节，除了复习蓝桥杯之外应该还可以多学一点别的东西，任务应该是可以完成了。本周真的蛮可惜的，就差半个小时就把这周的任务做完了。但是身体实在是扛不住了，早点休息为好。剩下的下周任务的明天早上看看能不能早点起来写吧。还是要加油。希望的曙光就在眼前了。加油！五一还是想回家把驾照考了。然后就没什么事情了，主要是考完之后就没什么事情了，还可以早过实习期。只要从学校跑出去，学校的事情就不管了，虽然不一定。但是还是要试试。</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;pre&gt;&lt;code&gt;今天身体不大舒服，早上起来之后就直接嗓子痛，很难受，然后晚上的话嗓子似乎好了一些，但是头有点晕，然后右胳膊也不是很舒服，一种酸痛的感觉。然后想学感觉脑子也跟不上了，这周任务还是没有完成，身体还是要好好养着的，不能太累，也不能太慵懒。也许是最近喝水不太多，也许</summary>
      
    
    
    
    <category term="Dairy" scheme="https://primeluoqiu.github.io/categories/Dairy/"/>
    
    
  </entry>
  
  <entry>
    <title>3月30号日记</title>
    <link href="https://primeluoqiu.github.io/2024/03/30/Dairy/0330/"/>
    <id>https://primeluoqiu.github.io/2024/03/30/Dairy/0330/</id>
    <published>2024-03-30T13:22:10.277Z</published>
    <updated>2024-03-30T13:47:23.634Z</updated>
    
    <content type="html"><![CDATA[<p>今天的志愿工作做的还不错，就是上午第一次给他们做评分的时候因为紧张，还有一些没注意过得地方出了不少差错。有两个组因为因为不小心的失误都少扣了十分，然后还好有一组没什么影响，但是有一组还是不得不扣了，不然的话名词会发生变化。这样的话就没有公平性可言了。不过这一上午的裁判工作还算是比较完善，没出什么大的差错，也没有遇见那种喜欢叨叨的同学和家长以及指导老师，大家都很不错，不过比起高中那边，听说有很多都在抬杠，包括指导老师。学生抬杠就算了，指导老师也跟着一起抬，这就没啥意思了。为人师长，自己不好好看看规则，然后就带着学生来比赛了。还带着学生一起抬杠，咱这也不是抬杠大赛，不是你声音大就可以赢了。以至于最后初中这边的比赛结束之后，高中那边的还没结束。然后就到了中午吃饭，这个饭啊，emm，只能说和昨天是天壤之别了。不过好歹也算是对付了两口，不至于大下午空着肚子执裁。下午的小学生组确实相对来说轻松一点，不过中间还是出现了一点小插曲，例如有一个小同学还是比较心急的想要碰一下，但是我们提醒到位，再加上也就是轻微碰了一下器材，也没有对实验造成什么实质上的印象，于是我们就没有让他重置了。当时在场的所有人都没有吭声，一直到结束之后换了下一组那个男人才开始说起来，这会已经没有时间再处理了。那个男人还在那里口若悬河的说说说。我们和主裁说了很多话，就是不听。对此只有一句话，就是菜就多练，输不起就别玩。换做是他的学生他是不是就不会吭声了，这个时候如果有别人像他一样，他是会觉得那个人不太行呢，还是怎么说呢？这就不好评价了。不过执裁的路途中还是学到了很多的。包括如何执裁，如何让同学和老师们信服执裁过程而没有意义，面对小朋友的时候该凶一点就要凶一点，该温柔的时候就应该温柔一点。都要有个度，例如，像下午小学场的小孩子们总是完美的结束之后不知道喊停，为了公平起见，我都是按照大概接触的时间给他们算的，这样也是一种相对来说的公平。然后比赛的时候有一次我就比较严声的跟他们说，我说你们不说，我给你们按什么时间算呢，是按照你喊的时间呢，还是按照结束的时间呢，结束之后一定要自己喊停。有的孩子喊早了，我还是一样的，我说你喊早了我应该怎么给你算呢，是按照早一点的算呢，还是等到了终点之后再算呢。希望他们可以记得住这次经历，并在以后的比赛中不要再犯这样的错误了。</p><p>不过有一说一今天是真的累，已经没有任何心力再学下去了，目前的任务其实也就是计网的2.2，不过这周的任务完成情况还得看明天结束这一周之后的任务状态。也不知道明天早上会睡到几点，因为今天实在是太累了，从早上执裁到下午。真的是做了一天的事情，走来走去，还要耗费精力去做这些事情，一不留神可能就漏掉了一个问题，然后就容易导致一些差错。下午的过程明显相对来说要顺利很多。晚上吃完饭回新工科之后，可能身体还好，但是思想是真的懈怠了，一点力气都没有了，或许这就是耗费了一天精力之后的感受吧。不过这一趟的收获还真的是蛮多的。而且在上午制裁的过程中，还无意中注意到了有一个正在做介绍的好像是体育馆的老师还是科技馆的老师，给那些领导讲解的时候，那个领导说他讲的还不错，然后问他在哪工作，那个人就说在科技馆这边工作，然后领导说他干得还不错，问之前怎么没见过他。他说好像是今天要接待领导，然后专门好好收拾了一下自己。看来这哥们的仕途应该要稍微往上一点点了，多少也是给领导留下来了一个好印象，没准哪天之后就会因为一些原因被提拔起来。哈哈哈哈</p><p>这两天嗓子似乎不大舒服，可能是扁桃体有点发炎，得多喝点水了。好好休息一下，也比较累，少熬会夜。加油吧</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天的志愿工作做的还不错，就是上午第一次给他们做评分的时候因为紧张，还有一些没注意过得地方出了不少差错。有两个组因为因为不小心的失误都少扣了十分，然后还好有一组没什么影响，但是有一组还是不得不扣了，不然的话名词会发生变化。这样的话就没有公平性可言了。不过这一上午的裁判工作还</summary>
      
    
    
    
    <category term="Dairy" scheme="https://primeluoqiu.github.io/categories/Dairy/"/>
    
    
  </entry>
  
  <entry>
    <title>1.5 控制</title>
    <link href="https://primeluoqiu.github.io/2024/03/29/ClassesFormUCBerkely/CS61A/1.5%E6%8E%A7%E5%88%B6/"/>
    <id>https://primeluoqiu.github.io/2024/03/29/ClassesFormUCBerkely/CS61A/1.5%E6%8E%A7%E5%88%B6/</id>
    <published>2024-03-29T13:50:16.549Z</published>
    <updated>2024-03-29T13:50:53.432Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-5-控制"><a href="#1-5-控制" class="headerlink" title="1.5 控制"></a>1.5 控制</h3><p>现在可以定义的函数能力十分有限，因为还没有引入一种方法来进行比较，并根据比较的结果执行不同的操作。控制语句将赋予我们这种能力，就是根据逻辑比较的结果来控制执行流程的语句。</p><p>语句与我们目前研究过的表达式有着根本的不同，<strong>他们没有值</strong>。执行一个控制语句决定了解释器接下来应该做什么，而不是计算某些东西</p><hr><h3 id="1-5-1-语句"><a href="#1-5-1-语句" class="headerlink" title="1.5.1 语句"></a>1.5.1 语句</h3><p>到目前为止，虽然思考的是如何计算表达式，但我们已经见过了三种语句：赋值(assignment)、<code>def</code>和<code>return</code>语句。尽管这些Python代码都包含表达式作为他们的一部分，但它们本身并不是表达式。</p><p>语句不会被求解，而会被执行。每个语句都描述了对解释器状态的一些更改，并且执行语句就会应用该更改。正如在<code>return</code>和赋值语句中看到的那样，执行语句可能涉及求解其包含的子表达式。</p><p>表达式也可以作为语句执行，在这种情况下，它们会被求值，但是它们的值会被丢弃。执行纯函数没有效果，但执行非纯函数会因为调用函数而产生效果。</p><p>思考一下，例如:</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">square</span>(<span class="params">x</span>):</span><br><span class="line">    mul(x, x)</span><br></pre></td></tr></table></figure></div><p>这个例子是有效的Python代码，但是不能达到预期。表达式本身是一个有效的语句，但语句的效果是调用<code>mul</code>函数，然后把结果丢弃。如果想对表达式的结果做什么，需要用赋值语句存储它或用<code>return</code>语句返回它：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">square</span>(<span class="params">x</span>)</span><br><span class="line">    <span class="keyword">return</span> mul(x, x)</span><br></pre></td></tr></table></figure></div><p>有时，在调用<code>print</code>等非纯函数时，拥有一个主体为表达式的函数确实有意义。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">print_square</span>(<span class="params">x</span>)</span><br><span class="line">    <span class="built_in">print</span>(square(x))</span><br></pre></td></tr></table></figure></div><p>在最高层级上，Python解释器的工作是执行由语句组成的程序。然而，很多有趣的计算工作都来自对表达式的求值。语句用来管理程序中不同表达式之间的关系，以及它们产生的结果。</p><hr><h3 id="1-5-2-复合语句"><a href="#1-5-2-复合语句" class="headerlink" title="1.5.2 复合语句"></a>1.5.2 复合语句</h3><p>通常，Python代码是一系列语句。简单语句是不以冒号结尾的单行，而由其他语句(简单语句和复合语句)组成被称为复合语句。复合语句通常跨越多行，以单行头部(header)开始，并以冒号结尾，其中冒号标识语句的类型。头部和缩进的句体(suite)一起称为子句。复合语句由一个或多个子句组成：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;header&gt;:</span><br><span class="line">    &lt;statement&gt;</span><br><span class="line">    &lt;statement&gt;</span><br><span class="line">    ...</span><br><span class="line">&lt;separating header&gt;</span><br><span class="line">    &lt;statement&gt;</span><br><span class="line">    &lt;statement&gt;</span><br><span class="line">    ...</span><br><span class="line">...</span><br></pre></td></tr></table></figure></div><p>我们可以用这些术语来理解我们之前介绍过的语句。</p><ul><li>表达式、返回语句和赋值语句都是简单语句。</li><li><code>def</code>语句是复合语句，<code>def</code>头后面的句体定义了函数体。<br>对每类header 都有专门的求值规则来规定其何时执行以及是否执行其句体中的语句。我们说”the header controls its suite”, 例如，在<code>def</code>语句中，<code>return</code>表达式不会立即求值，而是存储起来供以后调用该函数时使用。</li></ul><p>我们现在也可以理解多行程序了。</p><ul><li>要执行一系列语句，会先执行第一个语句，如果不重定向控制，那么就继续执行其余部分<br>这个定义解释了递归定义序列(sequence)的基本结构：一个序列可以分解成它的第一个元素和其余元素。语句序列的”其余部分”本身也是语句序列!因此，我们可以递归地应用这个执行规则。这就是将递归视为数据结构的观点</li></ul><p>此规则的重要结论时语句会按顺序执行，但由于重定向控制(redirected control),后面的语句可能永远不会被执行到。</p><p>缩进必须要缩进相同的量。</p><hr><h3 id="1-5-3-定义函数II-局部赋值"><a href="#1-5-3-定义函数II-局部赋值" class="headerlink" title="1.5.3 定义函数II:局部赋值"></a>1.5.3 定义函数II:局部赋值</h3><p>函数的主体不仅仅是包含单个返回语句的<code>return</code>组成，事实上，还可以定义超出单个表达式的一系列操作。</p><p>每当用户定义的函数被调用时，其具体中的子句序列将会在局部环境中执行-&gt;该环境通过调用函数创建的局部帧开始。<code>return</code>语句会重定向控制：每当执行一个<code>return</code>语句时，函数应用程序就会终止，<code>return</code>表达式的值会被作为被调用函数的返回值。</p><p>赋值语句可以出现在函数体中，例如</p><div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">percent_difference</span>(<span class="params">x, y</span>):</span><br><span class="line">    difference = <span class="built_in">abs</span>(x - y)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">100</span> * difference / x</span><br><span class="line">result = percent_difference(<span class="number">40</span>, <span class="number">50</span>)</span><br></pre></td></tr></table></figure></div><p>这个函数利用了两步计算，首先计算两个数的差的绝对值，然后求出它与第一个数的百分比并返回</p><p>赋值语句的作用是将名称和当前环境中的第一帧的值绑定。因此，函数体内的赋值语句不会影响全局帧。”函数只能操纵其局部帧”是创建模块化程序的关键，而在模块化程序中，纯函数仅通过它们接收和返回的值与外界交互。</p><p>当然，上述函数也可以只用一条赋值语句实现，但是返回表达式会更复杂</p><p><code>return 100 * abs(x - y)</code></p><p>到目前为止，局部赋值并没有增强函数定义的表达能力，而当它与其他控制语句结合时，就会增强。此外，局部赋值在”通过中间量赋名来解释复杂表达式的含义”方面也起着至关重要的作用。</p><hr><h3 id="1-5-4-条件语句"><a href="#1-5-4-条件语句" class="headerlink" title="1.5.4 条件语句"></a>1.5.4 条件语句</h3><p>Python有一个用于计算绝对值的内置函数。</p><div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">abs</span>(-<span class="number">2</span>)</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure></div><p>我们希望可以实现这样一个函数。但是我们想清楚我们要表达的是，如果x为正，就为正，为负取反。那么可以用条件语句来表示</p><div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">absolute_value</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">if</span>(x &gt;= <span class="number">0</span>):</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">return</span> -x</span><br><span class="line">result = absolute_value(x)    </span><br></pre></td></tr></table></figure></div><p>这个<code>absolute_value</code>函数的实现提出了几个重要问题：</p><p>条件语句(Condition statement):Python中的条件语句是由一系列头部和句体组成的：必须的<code>if</code>子句、可选的<code>elif</code>子句序列，最后是可选的<code>else</code>子句：</p><div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> &lt;expression&gt;:</span><br><span class="line">    &lt;suite&gt;</span><br><span class="line"><span class="keyword">elif</span> &lt;expression&gt;:</span><br><span class="line">    &lt;suite&gt;</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    &lt;suite&gt;</span><br></pre></td></tr></table></figure></div><p>执行条件语句的时候，每个子句都会按顺序被考虑。执行条件子句的计算过程如下。</p><ol><li>求解头部的表达式</li><li>如果它是真值，则执行该句体。然后跳过条件语句中的所有后续子句。</li></ol><p>如果达到<code>else</code>语句(仅当所有<code>if</code>和<code>elif</code>表达式的计算结果为假值时才会发生),则执行其句体。</p><p>布尔上下文(Boolean contexts)：上面，执行过程提到了”假值 a false value”和”真值 a true value”。<strong>条件块头部语句内的表达式</strong>被称为布尔上下文：它们值的真假对控制流很重要，另外，它们的值不会被赋值或返回。Python包含多个假值，包括**0, <code>None</code>, 和布尔值<code>false</code>**，所有其他数字都是真值。</p><p>布尔值(Boolean Value)：Python中有两个布尔值:<code>True</code>和<code>False</code>。布尔值表示逻辑表达式中的真值。内置的比较运算符&gt;,&lt;,&gt;&#x3D;,&lt;&#x3D;,&#x3D;&#x3D;, !&#x3D;会返回这些值。</p><div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">4</span> &gt; <span class="number">2</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">5</span> &gt;= <span class="number">5</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure></div><p>第二个例子在<code>operator</code>模块中的<code>ge</code></p><div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">0</span> == -<span class="number">0</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure></div><p>这个对应的是<code>operator</code>中的<code>eq</code>。Python会区分赋值和相等比较符号，许多语言都是这样</p><p>布尔运算符(Boolean operator):Python中还内置了三个基本的逻辑运算符：</p><div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">True</span> <span class="keyword">and</span> <span class="literal">False</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">True</span> <span class="keyword">or</span> <span class="literal">False</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">not</span> <span class="literal">False</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure></div><p>逻辑表达式具有相应的求值过程。而这些过程利用了这样的一个理论-&gt;有时，逻辑表达式的真值可以在不对其所有子表达式求值的情况下确定，这一特性称为短路，例如(or)</p><hr><p>求解表达式 <code>&lt;left&gt; and &lt;right&gt;</code> 的步骤如下：</p><ol><li>求解子表达式  <code>&lt;left&gt;</code>。</li><li>如果左边的结果为假值 v，则表达式的计算结果就是 v。</li><li>否则，表达式的计算结果为子表达式 <code>&lt;right&gt;</code> 的值。</li></ol><hr><p>求解表达式  <code>&lt;left&gt; or &lt;right&gt;</code> 的步骤如下：</p><ol><li>求解子表达式  <code>&lt;left&gt;</code>。</li><li>如果左边的结果为真值 v，则表达式的计算结果就是 v。</li><li>否则，表达式的计算结果为子表达式 <code>&lt;right&gt;</code> 的值。</li></ol><hr><p>求解表达式  <code>not &lt;exp&gt;</code> 的步骤如下：</p><ol><li>求解  <code>&lt;exp&gt;</code>，如果结果为假值，则值为 <code>True</code> ，否则为 <code>False</code>。</li></ol><hr><p>这些值、规则和运算符为我们提供了一种组合比较结果的方法。<strong>执行比较并返回布尔值的函数通常以 <code>is</code> 开头，后面不跟下划线</strong>（例如 <code>isfinite, isdigit, isinstance</code> 等）。</p><hr><h3 id="1-5-5-迭代"><a href="#1-5-5-迭代" class="headerlink" title="1.5.5 迭代"></a>1.5.5 迭代</h3><p>除了选择要执行的语句外，控制语句还用于重复。如果我们编写的每一行代码只执行一次，那么编程将是一项非常低效的工作只有通过重复执行语句，我们才能释放计算机的全部潜力。我们之前已经见过了一种重复形式:一种函数只用定义一次，就可以被多次调用。迭代控制(Iterative control)结构是另一种多次执行相同语句的机制。</p><p>思考一下之前学过的斐波那契数列，其中每个数都是前两个数的和。<br>$$<br>0, 1, 1, 2, 3, 5, 8, 13, 21 …<br>$$<br>每个值都是通过重复应用<code>sum-previous-two</code>的规则构建的，第一个和第二个值固定为0和1.</p><p>我们可以使用<code>while</code>语句来枚举n项斐波那契数列。我们需要跟踪已经创建了多少个值(k),和第k个值(<code>curr</code>)及其前身(<code>pred</code>)。单步执行此函数并观察斐波那契数列如何一个一个的演化，并绑定到<code>curr</code></p><div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fib</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Compute the nth Fibonacci number, for n &gt;= 2</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    pred, curr = <span class="number">0</span>, <span class="number">1</span> <span class="comment">#Fibonacci numbers 1 and 2</span></span><br><span class="line">    k = <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> k &lt; n:</span><br><span class="line">        pred, curr = curr, pred + curr</span><br><span class="line">        k = k + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> curr</span><br><span class="line">    result = fib(<span class="number">8</span>)</span><br></pre></td></tr></table></figure></div><p>请记住，单行赋值语句可以用逗号分隔多个名称和值同时赋值。该行：</p><p><code>pred, curr = curr, pred + curr</code></p><p>在更新左侧的绑定之前求出所有 <code>=</code> 右侧的内容 → 这种事件顺序对于此函数的正确性至关重要。</p><p><code>while</code> 子句包含一个头部表达式，后跟一个句体：</p><div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> &lt;expression&gt;:</span><br><span class="line">    &lt;suite&gt;</span><br></pre></td></tr></table></figure></div><p>要执行 <code>while</code> 子句：</p><ol><li>求解头部的表达式。</li><li>如果是真值，则执行后面的句体，然后返回第 1 步。</li></ol><p>在第 2 步中，<code>while</code> 子句的整个句体在再次计算头部表达式之前执行。</p><p>为了防止 <code>while</code> 子句的句体无限期地执行，句体应该总是在每次循环中更改一些绑定。</p><p>不会终止的 <code>while</code> 语句被称为无限循环（infinite loop）。按 <code>&lt;Control&gt;-C</code> 可以强制 Python 停止循环。</p><h3 id="1-5-6-测试"><a href="#1-5-6-测试" class="headerlink" title="1.5.6 测试"></a>1.5.6 测试</h3><p>测试一个函数就是去验证函数的行为是否符合预期。</p><p>测试是一种系统地执行验证的机制。它通常采用另一个函数的形式，其中包含对一个或多个对被测试函数的调用样例，然后根据预期结果验证其返回值。与大多数旨在通用的函数不同，测试需要选择特定参数值，并使用它们验证函数调用。测试也可用作文档：去演示如何调用函数，以及如何选取合适的参数值。</p><p>断言（Assertions）：程序员使用 <code>assert</code> 语句来验证是否符合预期，例如验证被测试函数的输出。<code>assert</code> 语句在布尔上下文中有一个表达式，后面是一个带引号的文本行（单引号或双引号都可以，但要保持一致），如果表达式的计算结果为假值，则显示该行。</p><div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">assert</span> fib(<span class="number">8</span>) == <span class="number">13</span>, <span class="string">&#x27;第八个斐波那契数应该是 13&#x27;</span></span><br></pre></td></tr></table></figure></div><p>当被断言的表达式的计算结果为真值时，执行断言语句无效。而当它是假值时，<code>assert</code> 会导致错误，使程序停止执行。</p><p>fib 的测试函数应该测试几个参数，包括 n 的极限值。</p><div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">fib_test</span>():</span><br><span class="line">        <span class="keyword">assert</span> fib(<span class="number">2</span>) == <span class="number">1</span>, <span class="string">&#x27;第二个斐波那契数应该是 1&#x27;</span></span><br><span class="line">        <span class="keyword">assert</span> fib(<span class="number">3</span>) == <span class="number">1</span>, <span class="string">&#x27;第三个斐波那契数应该是 1&#x27;</span></span><br><span class="line">        <span class="keyword">assert</span> fib(<span class="number">50</span>) == <span class="number">7778742049</span>, <span class="string">&#x27;在第五十个斐波那契数发生 Error&#x27;</span></span><br></pre></td></tr></table></figure></div><p>当在文件中而不是直接在解释器中编写 Python 时，测试通常是在同一个文件或带有后缀 <code>_test.py</code> 的相邻文件中编写的。</p><p>文档测试（Doctests）：Python 提供了一种方便的方法，可以将简单的测试直接放在函数的文档字符串中。文档字符串的第一行应该包含函数的单行描述，接着是一个空行，下面可能是参数和函数意图的详细描述。此外，文档字符串可能包含调用该函数的交互式会话示例：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">sum_naturals</span>(<span class="params">n</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;返回前 n 个自然数的和。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; sum_naturals(10)</span></span><br><span class="line"><span class="string">        55</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; sum_naturals(100)</span></span><br><span class="line"><span class="string">        5050</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        total, k = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> k &lt;= n:</span><br><span class="line">            total, k = total + k, k + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> total</span><br></pre></td></tr></table></figure></div><p>然后，可以通过 <a class="link"   href="http://docs.python.org/py3k/library/doctest.html" >doctest 模块 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 来验证交互，如下。</p><div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> doctest <span class="keyword">import</span> testmod</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>testmod()</span><br><span class="line">TestResults(failed=<span class="number">0</span>, attempted=<span class="number">2</span>)</span><br></pre></td></tr></table></figure></div><p>如果仅想验证单个函数的 doctest 交互，我们可以使用名为 <code>run_docstring_examples</code> 的 <code>doctest</code> 函数。不幸的是，这个函数调用起来有点复杂。第一个参数是要测试的函数；第二个参数应该始终是表达式 <code>globals()</code> 的结果，这是一个用于返回全局环境的内置函数；第三个参数 <code>True</code> 表示我们想要“详细”输出：所有测试运行的目录。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> doctest <span class="keyword">import</span> run_docstring_examples</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>run_docstring_examples(sum_naturals, <span class="built_in">globals</span>(), <span class="literal">True</span>)</span><br><span class="line">Finding tests <span class="keyword">in</span> NoName</span><br><span class="line">Trying:</span><br><span class="line">    sum_naturals(<span class="number">10</span>)</span><br><span class="line">Expecting:</span><br><span class="line">    <span class="number">55</span></span><br><span class="line">ok</span><br><span class="line">Trying:</span><br><span class="line">    sum_naturals(<span class="number">100</span>)</span><br><span class="line">Expecting:</span><br><span class="line">    <span class="number">5050</span></span><br><span class="line">ok</span><br></pre></td></tr></table></figure></div><p>当函数的返回值与预期结果不匹配时，<code>run_docstring_examples</code> 函数会将此问题报告为测试失败。</p><p>当你在文件中编写 Python 时，可以通过使用 doctest 命令行选项启动 Python 来运行文件中的所有 doctest：</p><div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -m doctest &lt;python_source_file&gt;</span><br></pre></td></tr></table></figure></div><p>有效测试的关键是在实现新功能后立即编写（并运行）测试。在实现之前编写一些测试也是一种很好的做法，以便在你的脑海中有一些示例输入和输出。调用单个函数的测试称为单元测试（unit test）。详尽的单元测试是良好程序设计的标志。</p><p>总结来看，本节的主要内容是对于函数的控制，函数不仅包含了能够返回值的<code>return</code>语句，还可以对函数进行多种复杂的语句，例如复合语句。然后就是有关局部赋值，也就是在函数内部定义一个变量用来进行赋值的操作。接下来就是有关条件的<code>if-else</code>语句和布尔值，在这里，要对逻辑表达式的求值过程中的短路有所了解。接下来就是函数内部的迭代，这里利用到了<code>while</code>语句，通过<code>while</code>语句来更新斐波那契数列的<code>pred</code>和<code>curr</code>，最后就是对于函数的测试，我们要看我们写的函数是不是满足我们的心理预期。测试的方式有很多种，包括但不限于断言和文档测试。最后，我们了解到有效测试的关键是在实现新功能后立即编写(并运行)测试。在实验之前编写一些测试也是一种很好的做法。详尽的单元测试是良好程序设计的标志。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-5-控制&quot;&gt;&lt;a href=&quot;#1-5-控制&quot; class=&quot;headerlink&quot; title=&quot;1.5 控制&quot;&gt;&lt;/a&gt;1.5 控制&lt;/h3&gt;&lt;p&gt;现在可以定义的函数能力十分有限，因为还没有引入一种方法来进行比较，并根据比较的结果执行不同的操作。控制语句将</summary>
      
    
    
    
    <category term="CS61A" scheme="https://primeluoqiu.github.io/categories/CS61A/"/>
    
    
  </entry>
  
  <entry>
    <title>3月29日日记</title>
    <link href="https://primeluoqiu.github.io/2024/03/29/Dairy/0329/"/>
    <id>https://primeluoqiu.github.io/2024/03/29/Dairy/0329/</id>
    <published>2024-03-29T13:37:01.094Z</published>
    <updated>2024-03-29T13:49:58.154Z</updated>
    
    <content type="html"><![CDATA[<p>今天下午去做了志愿之前的准备工作，虽然似乎并没有干什么，但是还是感觉到身体有一阵疲惫的感觉。晚上回来的路上甚至靠在车的座位的背部小憩了一会。这个志愿工作也签署了保密协议，不过感觉跟之前的在严谨性上差了好多。晚上的餐食还不错，小小的炫了点饭。也是没想到居然会拿蒜薹炒一点牛肉。这个是没想到的。</p><p>一下午基本上过去之后就是在那边坐着，然后开了个预备大会，然后就是吃饭啥的，然后在吃饭之前的比赛场馆里面看到有一些看起来比较高科技的所谓的能够通过脑电波来测试专注力，虽然但是，我还是觉得是有一定的技术成分，但是似乎也并不高。有参考意义，但不多。就像手上带的手表和购买的体脂秤所评价出来的心率道理是一样的。两个数据基本上就从来都没有对准过。</p><p>还是在减肥的路上，但是目前好像又涨了一些，体重目前保持在了95附近，但是也不知道下个月能不能到90左右，是有在坚持运动和锻炼，但是主要还是早上起不来，起得来的话早上出去走两圈还是很舒服的，晚上睡的也晚，其实是可以早点休息的，不过主要似乎也不是很困，然后熬着熬着夜就深起来了，倒也没什么办法。晚上上床之后还是看看书，有啥好一点的电子书看着看着应该也就困了。</p><p>希望明天的志愿活动不要出什么差错，完完整整的度过这一整天就好</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天下午去做了志愿之前的准备工作，虽然似乎并没有干什么，但是还是感觉到身体有一阵疲惫的感觉。晚上回来的路上甚至靠在车的座位的背部小憩了一会。这个志愿工作也签署了保密协议，不过感觉跟之前的在严谨性上差了好多。晚上的餐食还不错，小小的炫了点饭。也是没想到居然会拿蒜薹炒一点牛肉。</summary>
      
    
    
    
    <category term="Dairy" scheme="https://primeluoqiu.github.io/categories/Dairy/"/>
    
    
  </entry>
  
  <entry>
    <title>2.0-2.1应用层概述及应用层原理</title>
    <link href="https://primeluoqiu.github.io/2024/03/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.0.1/"/>
    <id>https://primeluoqiu.github.io/2024/03/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.0.1/</id>
    <published>2024-03-28T15:08:54.880Z</published>
    <updated>2024-03-28T15:22:22.428Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/28/jP11UBQt.jpg"                      alt="31.jpg"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/28/VmylFgdU.jpg"                      alt="32.jpg"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/28/u1KArs2u.jpg"                      alt="33.jpg"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/28/qyFjL5eT.jpg"                      alt="34.jpg"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/28/gxDfjYvy.jpg"                      alt="35.jpg"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/28/gcWxPUxg.jpg"                      alt="36.jpg"                ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;https://img2.imgtp.com</summary>
      
    
    
    
    <category term="计网" scheme="https://primeluoqiu.github.io/categories/%E8%AE%A1%E7%BD%91/"/>
    
    
  </entry>
  
  <entry>
    <title>1.4设计函数</title>
    <link href="https://primeluoqiu.github.io/2024/03/27/ClassesFormUCBerkely/CS61A/1.4%20%E8%AE%BE%E8%AE%A1%E5%87%BD%E6%95%B0/"/>
    <id>https://primeluoqiu.github.io/2024/03/27/ClassesFormUCBerkely/CS61A/1.4%20%E8%AE%BE%E8%AE%A1%E5%87%BD%E6%95%B0/</id>
    <published>2024-03-27T14:06:19.040Z</published>
    <updated>2024-03-27T14:07:07.517Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-4-设计函数"><a href="#1-4-设计函数" class="headerlink" title="1.4 设计函数"></a>1.4 设计函数</h1><p>函数是所有程序(无论大小)的基本组成部分，并且是我们使用编程语言来表达计算过程的主要媒介。本节内容是如何设计一个好的函数。</p><p>那么好函数共有的品质就是：它们都强化了”函数就是抽象”理念。</p><ul><li>每个函数应该只负责一个任务，且该任务要用一个简短的名称来识别，并在一行文本中进行描述。按顺序执行多个任务的函数应该分为多个函数。</li><li>不要重复自己(Don’t repeat yourself)是软件工程的核心原则。这个所谓的DRY原则直出，多个代码片段不应该描述重复的逻辑。相反，逻辑应该只实现一次，为其指定一个名称后多次使用。</li><li>定义通用函数。比如作为<code>pow</code>函数的一个特例的平方函数就不在<code>Python</code>库中，因为<code>pow</code>函数可以将数字计算为任意次方。</li></ul><p>这些准则提高了代码的可读性，减少了错误的数量，并且通常最大限度地减少了便携的代码总量。将复杂的任务分解为简洁的功能是一项需要经验才能掌握的技能。不过好在Python提供了多种特性来支持工作</p><h3 id="1-4-1-文档"><a href="#1-4-1-文档" class="headerlink" title="1.4.1 文档"></a>1.4.1 文档</h3><p>函数定义通常包括描述函数的文档，称为”文档字符串 docstring”，它必须在函数体中缩进。文档字符串通常使用三个引号，第一行描述函数的任务，随后的几行可以描述参数并解释函数的意图</p><div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">pressure</span>(<span class="params">v, t, n</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    计算理想气体的压力，单位为帕斯卡</span></span><br><span class="line"><span class="string">     v -- 气体体积，单位为立方米</span></span><br><span class="line"><span class="string">        t -- 绝对温度，单位为开尔文</span></span><br><span class="line"><span class="string">        n -- 气体粒子</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    k = <span class="number">1.38</span>e - <span class="number">23</span>  <span class="comment">#玻尔兹曼常数</span></span><br><span class="line">    <span class="keyword">return</span> n * k * t / v </span><br></pre></td></tr></table></figure></div><p>当你使用函数名称作为参数调用<code>help</code>时，你会看到它的文档字符串(键入<code>q</code>以退出Python help)。</p><div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">help</span>(pressure)</span><br></pre></td></tr></table></figure></div><p>编写Python程序时，除了最简单的函数之外，都要包含文档字符串。要记住，虽然代码只编写一次，但是会在之后阅读多次。Python文档包含了文档字符串准则，它会在不同的Python项目中保持一致。</p><p>注释：Python中的注释可以附加到<code>#</code>号后的行尾。例如，上面代码中的<code>#</code>后面的注释描述了k变量的含义。这些注释不会出现在Python的<code>help</code>中，而且会被解释器忽略，它们只为了注释而出现</p><hr><h3 id="1-4-2-参数默认值"><a href="#1-4-2-参数默认值" class="headerlink" title="1.4.2 参数默认值"></a>1.4.2 参数默认值</h3><p>定义通用函数的结果是引入了额外的参数。具有许多参数的函数可能调用起来很麻烦并且难以阅读。</p><p>在Python中，我们可以为函数的参数提供默认值。当调用该函数时，具有默认值的参数是可选的。如果未提供，则将默认值绑定到形参上。例如，如果程序通常用于计算”一摩尔”粒子的压力，则可以提供此值作为默认值</p><div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">pressure</span>(<span class="params">v, t, n = <span class="number">6.022e23</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    计算理想气体的压力，单位为帕斯卡</span></span><br><span class="line"><span class="string">     v -- 气体体积，单位为立方米</span></span><br><span class="line"><span class="string">        t -- 绝对温度，单位为开尔文</span></span><br><span class="line"><span class="string">        n -- 气体粒子</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    k = <span class="number">1.38</span>e - <span class="number">23</span>  <span class="comment">#玻尔兹曼常数</span></span><br><span class="line">    <span class="keyword">return</span> n * k * t / v </span><br></pre></td></tr></table></figure></div><p><code>=</code>符号在此等示例中表示两种不同的含义，具体取决于使用它的上下文。在def语句中,<code>=</code>不执行赋值，而是指示调用<code>pressure</code>函数时使用的默认值。相比之下，函数体中对<code>k</code>的赋值语句中将名称<code>k</code>与玻尔兹曼常数的近似值进行了绑定。</p><div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>pressure(<span class="number">1</span>, <span class="number">273.15</span>)</span><br><span class="line"><span class="number">2269.974834</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pressure(<span class="number">1</span>, <span class="number">237.15</span>, <span class="number">3</span> * <span class="number">6.022e23</span>)</span><br><span class="line"><span class="number">6809.924502</span></span><br></pre></td></tr></table></figure></div><p><code>pressure</code>函数的定义接受三个参数，但上面的第一个调用表达式中值提供了两个。在这种情况下，n的值取自<code>def</code>语句的默认值。如果提供了，那么默认值就会被忽略</p><p>作为准则，函数主体中使用的大多数数据值都应该表示为具名参数(named arguments)的默认值，这样会使他们更易于检查，并且可以被函数调用者更改。一些永远不会改变的值，例如基本常量k可以绑定在函数体或全局帧中。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-4-设计函数&quot;&gt;&lt;a href=&quot;#1-4-设计函数&quot; class=&quot;headerlink&quot; title=&quot;1.4 设计函数&quot;&gt;&lt;/a&gt;1.4 设计函数&lt;/h1&gt;&lt;p&gt;函数是所有程序(无论大小)的基本组成部分，并且是我们使用编程语言来表达计算过程的主要媒介。本</summary>
      
    
    
    
    <category term="CS61A" scheme="https://primeluoqiu.github.io/categories/CS61A/"/>
    
    
  </entry>
  
  <entry>
    <title>1.8历史</title>
    <link href="https://primeluoqiu.github.io/2024/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.8/"/>
    <id>https://primeluoqiu.github.io/2024/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.8/</id>
    <published>2024-03-27T12:03:09.041Z</published>
    <updated>2024-03-27T12:10:08.736Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/27/aeIYP5H3.jpg"                      alt="26.jpg"                ><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/27/O4212m1R.jpg"                      alt="27.jpg"                ><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/27/4wlj58Tf.jpg"                      alt="29.jpg"                ><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/27/9i4NYHEt.jpg"                      alt="30.jpg"                ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;https://img2.imgtp.com</summary>
      
    
    
    
    <category term="计网" scheme="https://primeluoqiu.github.io/categories/%E8%AE%A1%E7%BD%91/"/>
    
    
  </entry>
  
</feed>
