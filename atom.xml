<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>秋过冬漫长</title>
  
  <subtitle>没有比脚更长的路,走过去就好了</subtitle>
  <link href="https://primeluoqiu.github.io/atom.xml" rel="self"/>
  
  <link href="https://primeluoqiu.github.io/"/>
  <updated>2024-04-14T05:37:23.747Z</updated>
  <id>https://primeluoqiu.github.io/</id>
  
  <author>
    <name>LuoQiu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>1.6 高阶函数</title>
    <link href="https://primeluoqiu.github.io/2024/04/14/ClassesFormUCBerkely/CS61A/1.6/"/>
    <id>https://primeluoqiu.github.io/2024/04/14/ClassesFormUCBerkely/CS61A/1.6/</id>
    <published>2024-04-14T03:22:11.346Z</published>
    <updated>2024-04-14T05:37:23.747Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-6-高阶函数"><a href="#1-6-高阶函数" class="headerlink" title="1.6 高阶函数"></a>1.6 高阶函数</h1><p>我们已知函数是一种抽象方法，描述了与<strong>特定参数</strong>无关的<strong>复合操作</strong></p><p>也就是说，在<code>square</code>中我们并不是讨论一个参数的平方，而是讨论一种可以获得任何数字平方的办法，当然也可以通过<code>8*8</code>这样的表达式来计算平方得到结果。从而不显式的提到<code>square</code></p><p>这种虽然看起来很方便，但是对于一些简单的操作是足够的，但是对于复杂的表达式就会变得很麻烦，一般来说，缺少函数定义对我们来说就像是一个原始人，而不是modern people，程序虽然可以计算平方，但是缺少了对平方的概念的能力。</p><p>我们对强大的编程语言提出的要求之一就是能通过将名称分配给通用模板(general patterns)来构造抽象，然后直接使用该名称进行工作。函数提供了这种能力。代码中重复出现一些常见模板，它们可以与许多不同的函数一起使用。这些模板也可以通过给它们命名来进行抽象。</p><p>为了将某些通用模板表达为具名概念(named concepts)，我们需要构造一种可以**”接受其他函数作为参数”<strong>或可以把</strong>可以把函数当作返回值**的函数。这种可以操作函数的函数就叫做高阶函数(high-order functions)。</p><hr><h3 id="1-6-1-作为函数的参数"><a href="#1-6-1-作为函数的参数" class="headerlink" title="1.6.1 作为函数的参数"></a>1.6.1 作为函数的参数</h3><p>现在有三个函数，分别是计算自然数之和，计算立方之和，计算一个收敛到Π的总和</p><div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">sum_naturals</span>(<span class="params">n</span>):</span><br><span class="line">    total, k = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> k &lt;= n:</span><br><span class="line">            total += k</span><br><span class="line">            k ++</span><br><span class="line">    <span class="keyword">return</span> total</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">sum_cubes</span>(<span class="params">n</span>):</span><br><span class="line">    total, k = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> k &lt;= n:</span><br><span class="line">            total, k = total + k*k*k, k+<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> total</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">pi_sum</span>(<span class="params">n</span>):</span><br><span class="line">    total, k = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> k &lt;= n:</span><br><span class="line">            total, k = total + (<span class="number">4</span>*k-<span class="number">3</span>)*(<span class="number">4</span>*k-<span class="number">1</span>) ,k + <span class="number">1</span> </span><br><span class="line">        <span class="keyword">return</span> total</span><br></pre></td></tr></table></figure></div><p>我们不难看出来，它们在背后共用的其实是一个模板，它们在很大程度上是相同的，仅在名称和用于计算被加项<code>k</code>的函数上有所不同。我们可以通过在同一模板中填充槽位(slots)来生成每个函数:</p><div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> &lt;name&gt;(n):</span><br><span class="line">    total, k = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> k &lt;= n:</span><br><span class="line">        total, k = total + &lt;term&gt;(k), k + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> total</span><br></pre></td></tr></table></figure></div><p>这种通用模板的封存在证明了有一个实用的抽象手段正在”浮出水面”。这些函数都是用来求和的，我们不妨编写一个表达求和概念的函数，方法是使用通用模板，并将槽位转换为形式参数:</p><p>接下来看一个例子，<code>summation</code>将上界<code>n</code>和计算第k项的函数<code>term</code>作为两个参数，并简洁地表达了求和。</p><div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">summation</span>(<span class="params">n, term</span>):</span><br><span class="line">    total, k = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> k&lt;=n:</span><br><span class="line">        total, k = total + term(k), k ++</span><br><span class="line">    <span class="keyword">return</span> total</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cube</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x*x*x</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sum_cubes</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">return</span> summation(n, cube)</span><br><span class="line"></span><br><span class="line">result = sum_cubes(<span class="number">3</span>)</span><br></pre></td></tr></table></figure></div><p>同样的，我们还可以利用返回其函数的<code>identity</code>函数，我们还可以使用完全相同的<code>summation</code>函数对自然数求和。</p><div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">summation</span>(<span class="params">n ,term</span>)</span><br><span class="line">total, k = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> k&lt;=n: </span><br><span class="line">        total, k = total + term(k), k ++</span><br><span class="line">    <span class="keyword">return</span> total</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">identity</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sum_naturals</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">return</span> summation(n, identity)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sum_naturals(<span class="number">10</span>)</span><br><span class="line"><span class="number">55</span></span><br></pre></td></tr></table></figure></div><p><code>summation</code>函数也可以直接调用，而无需为特定数列去定义另一个函数。</p><p><code>pi_sum</code>函数也可以如此，只要抽象的出来就可以。但是得有一个限制用的，例如一个精确值<code>1e6</code>以计算pi的近似值</p><div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">pi_term</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="number">8</span> / ((<span class="number">4</span>*x-<span class="number">3</span>) * (<span class="number">4</span>*x-<span class="number">1</span>))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pi_sum</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> smmation(n, pi_term)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pi_sum(<span class="number">1e6</span>)</span><br></pre></td></tr></table></figure></div><hr><h3 id="1-6-2作为通用方法的函数"><a href="#1-6-2作为通用方法的函数" class="headerlink" title="1.6.2作为通用方法的函数"></a>1.6.2作为通用方法的函数</h3><p>之前引入了”用户定义函数”，在有了高阶函数之后，会看到一种更强大的抽象，用一些函数来表达计算的通用方法，而且和它们调用的特定函数无关。</p><p>尽管我们对函数的意义进行了这些概念上的扩展，但我们用于查看“调用表达式如何求解”的环境模型可以优雅地、无需更改地扩展到高阶函数。当将用户定义的函数应用于某些参数时，形式参数将与局部帧中它们的值（参数可能是函数）绑定。</p><p>下面的例子实现了<strong>迭代改进(iterative improvement)的通用方法</strong>，并使它来计算黄金比例的值，黄金比例通常被称为phi，是一个接近1.6的数字。</p><p><strong>迭代改进算法</strong>从方程的<code>guess</code>解(推测值)开始，重复应用<code>update</code>函数来改进猜测，并调用<code>close</code>来比较当前的<code>guess</code>是否已经足够接近正确值</p><div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">improve</span>(<span class="params">update, close, guess = <span class="number">1</span></span>): <span class="comment">#给一个推测值</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> close(guess):  <span class="comment">#推测之不够接近</span></span><br><span class="line">        guess = update(guess) <span class="comment">#更新推测值</span></span><br><span class="line">    <span class="keyword">return</span> guess <span class="comment">#返回正确值</span></span><br></pre></td></tr></table></figure></div><p><strong>这个<code>improve</code>函数是迭代求精的的通用表达式，它并不指定要解决的问题，而是会将这些细节留给作为参数传入的<code>update</code>和<code>close</code>函数</strong></p><p>黄金比例的一个著名特性是它可以<strong>通过反复叠加任何正数的倒数加上1来计算</strong>，而且它比它的平方小1，我们可以将这些特性表示为与<code>improve</code>一起使用的函数</p><div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">goleden_update</span>(<span class="params">guess</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>/guess + <span class="number">1</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">square_close_to_successor</span>(<span class="params">guess</span>):</span><br><span class="line">    <span class="keyword">return</span> approx_eq(guess * guess, guess + <span class="number">1</span>)</span><br></pre></td></tr></table></figure></div><p>以上我们调用了<code>approx_eq</code>函数：如果其参数大致相等，则返回<code>True</code>。为了实现<code>approx_eq</code>，我们可以将两个数字差的绝对值与一个小的公差值(tolerance value)进行比较</p><div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">approx_eq</span>(<span class="params">x, y, tolerance=<span class="number">1e-15</span></span>):</span><br><span class="line">    retun <span class="built_in">abs</span>(x - y) &lt; tolerance</span><br></pre></td></tr></table></figure></div><p>使用参数<code>golden_update</code>和<code>square_close_to_successor</code>来调用<code>improve</code>将会计算出黄金比例的有限近似值。</p><div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>improve(golden_update, square_close_to_successor)</span><br></pre></td></tr></table></figure></div><p>通过追踪求解的步骤，我们可以看到这个结果是如何计算出来的。首先，将 <code>update</code>、<code>close</code> 和 <code>guess</code> 绑定在构造 <code>improve</code> 的局部帧上。然后在 <code>improve</code> 的函数体中，将名称 <code>close</code> 绑定到 <code>square_close_to_successor</code> ，它会使用 <code>guess</code> 的初始值进行调用。</p><div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">improve</span>(<span class="params">update, close, guess = <span class="number">1</span></span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> close(guess):</span><br><span class="line">        guess = update(guess)</span><br><span class="line">    <span class="keyword">return</span> guess</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">golden_update</span>(<span class="params">guess</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> / guess + <span class="number">1</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">square_close_to_successor</span>(<span class="params">guess</span>):</span><br><span class="line">    <span class="keyword">return</span> approx_eq(guess * guess, guess + <span class="number">1</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">approx_eq</span>(<span class="params">x, y, tolerance=<span class="number">1e-3</span></span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">abs</span>(x - y) &lt; tolerance</span><br><span class="line">phi = improve(golden_update, square_close_to_successor)</span><br></pre></td></tr></table></figure></div><hr><p><del>突然想起来一句话，虽然算法对于程序来讲非常的重要，但是对于一个臃肿的程序运行起来肯定时间很长，但是如果有了算法的加持，那么这个程序跑起来就会很快，所有的进程运行起来就会很流畅。因此就可以在类似例如打开应用的时候做出一些比较精美的打开动画，但是其实，臃肿也不代表不能用，对于现在而言，能够开发出来就已经很不错了，如果一味追求动画的优雅和流畅而连一个正常的APP都开发不出来的话，那么不久本末倒置了。</del></p><p>一点废话，当我没说</p><hr><p>这个例子说明了计算机科学中两个相关的重要思想：首先，命名和函数能使我们将大量的复杂事务进行抽象。虽然每个函数定义都很简单，但是求解程序出发的计算过程非常复杂。其次，正是我们对Python有一个及其通用的求解过程，小的组件才能组合成复杂的程序。理解解释程序的求解过程有便于我们验证和检查我们创建的程序。</p><hr><h3 id="1-6-3-定义函数III-嵌套定义"><a href="#1-6-3-定义函数III-嵌套定义" class="headerlink" title="1.6.3 定义函数III:嵌套定义"></a>1.6.3 定义函数III:嵌套定义</h3><p>上面的示例演示了将函数作为参数传递的能力显著地增强编程语言的表达能力。每个通用概念或方程都能映射到自己的小型函数上，但这种方法的一个负面后果是<strong>全局帧会变得混乱</strong>，因为小型函数的名称必须都是唯一的。另一个问题是我们受到<strong>特定函数签名的限制</strong>：<code>improve</code> 的 <code>update</code> 参数只能接受一个参数。<strong>嵌套函数定义</strong>（Nested function definition）解决了这两个问题，但需要我们丰富一下环境模型。</p><p>那么上述的方法是不是可以拿来计算一个数的平方根呢？重复以下更新，值会收敛为的平方根。</p><div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">average</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">return</span> (x + y)/<span class="number">2</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sqrt_update</span>(<span class="params">x, a</span>):</span><br><span class="line">    <span class="keyword">return</span> average(x, a/x)</span><br></pre></td></tr></table></figure></div><p>但是这个双参数更新函数和<code>improve</code>函数不兼容(他有两个参数，而不是一个)，而且它只提供一次更新，但是我们真正想要的是通过重复更新求平方根。这两个问题的解决方案是将函数定义放在其他函数的主体中。</p><div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sqrt</span>(<span class="params">a</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sqrt_update</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="keyword">return</span> average(x, a/x)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sqrt_close</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="keyword">return</span> approx_eq(x * x, a)</span><br><span class="line">    <span class="keyword">return</span> improve(sqrt_update, sqrt_close)</span><br></pre></td></tr></table></figure></div><p>与局部赋值一样，这些函数之影响当前局部帧。这些函数尽在求解<code>sqrt</code>时在作用域内。与求解过程一致，局部在调用函数前不会被求解。</p><p>词法作用域（Lexical scope）：局部定义的函数也可以访问定义作用域内的名称绑定。在此示例中， <code>sqrt_update</code> 引用名称 <code>a</code>，它是其封闭函数 <code>sqrt</code> 的形式参数。这种在<strong>嵌套定义之间共享名称的规则称为词法作用域</strong>。最重要的是，<strong>内部函数可以访问定义它们的环境中的名称</strong>（而不是它们被调用的位置）。</p><p> 如果想要启用词法作用域，得实现两个扩展</p><ol><li>每个用户定义的函数都有一个定义这个函数的父环境。</li><li>在调用用户定义的函数的时候，它的局部frame会继承父环境。</li></ol><p>在调用创建的sqrt的函数之前，所有的函数都是在全局环境中定义的。因此他们的父级都是全局环境。相比之下，当计算<code>sqrt</code>的前两个子句的时候，在这次调用中，它会创建局部环境关联的函数。</p><p>环境先为<code>sqrt</code>添加一个局部frame，然后求解<code>sqrt_update</code>和<code>sqrt_close</code>的def语句。</p><p>通过可视化网站我们可以得出Python中词法作用域的两个关键优势</p><ul><li>局部函数的名称不会影响定义它的函数的外部名称，因为局部函数的名称将绑定在定义它的当前局部环境中，而不是全局环境中。</li><li>局部函数可以访问外层函数的环境，这是因为局部函数的函数体的求值环境会继承定义它的求值环境。</li></ul><p>局部定义的函数通常被称为闭包。(closures)</p><hr><h3 id="1-6-4-作为返回值的函数"><a href="#1-6-4-作为返回值的函数" class="headerlink" title="1.6.4 作为返回值的函数"></a>1.6.4 作为返回值的函数</h3><p>通过创建”返回值就是函数”的函数，我们可以在程序中实现更强大的表达能力。带有词法作用域的编程语言的一个重要特性就是，局部定义函数在它们返回时仍持有所关联的环境。</p><p>一旦定义了许多简单的函数，函数组合(composition)就称为编程语言中的一种自然的组合方法。也就是说，给定两个函数<code>f(x)</code>和<code>g(x)</code>，我们可能想要定义<code>h(x) = f(g(x))</code>。我们可以使用我们现有的工具定义函数组合:</p><div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">compose1</span>(<span class="params">f, g</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">h</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="keyword">return</span> f(g(x))</span><br><span class="line">    <span class="keyword">return</span> h</span><br></pre></td></tr></table></figure></div><p> 下面是一个例子,展示了如何正确解析名称<code>f</code>和<code>g</code>，即使它们存在名称冲突</p><div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">square</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x * x</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">successor</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x + <span class="number">1</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">compose1</span>(<span class="params">f, g</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">h</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="keyword">return</span> f(g(x))</span><br><span class="line">    <span class="keyword">return</span> h</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="string">&quot;Never Called.&quot;</span></span><br><span class="line">    <span class="keyword">return</span> -x</span><br><span class="line"></span><br><span class="line">square_successor = compose1(square, successor)</span><br><span class="line">result = square_successor(<span class="number">12</span>)</span><br></pre></td></tr></table></figure></div><p><code>compose1</code>中的1表示这个组合的函数只有一个参数。这个命名惯例不是解释器强制要求的，1只是函数名的一部分。</p><p>在这点上，我们已经能够察觉到努力去精确定义计算环境模型的好处：不需要修改环境模型就可以解释如何以这种方式来返回函数。</p><hr><h3 id="1-6-5-示例：牛顿法"><a href="#1-6-5-示例：牛顿法" class="headerlink" title="1.6.5 示例：牛顿法"></a>1.6.5 示例：牛顿法</h3><p>这个拓展的示例展示了函数和局部定义如何协同工作，以简洁地表达一般的思想。我们将实现一种广泛用于机器学习，科学计算、硬件设计和优化的算法。</p><p>牛顿法(Newton’s method)是一种经典的迭代方法，用于查找返回值为0地数学函数地参数。这些值(参数)称为函数的零点(Zero)。找到函数的零点通常等同于解决了其他一些有趣的问题，例如求平方根。</p><p>这个操作在现代看来是非常便捷的，但是学习计算机科学的一部分是理解这样的量是如何计算的，此处介绍的一般方法适用于求解Python内置方程之外的一大类方程。</p><p>牛顿法也是一种迭代改进算法，他会对所有可微函数的零点的猜测值进行改进，这意味着它可以在任意点用直线进行近似处理。牛顿的方法遵循这些线性近似(linear approximations)来找到函数零点。</p><p>试想一条穿过点(x, f(x))的直线与函数f(x)在该点拥有相同的斜率。这样的直线称为切线(tangent)，它的斜率我们称为f在x处的导数</p><p>这条直线的斜率是函数值变化量与函数自变量的比值。所以，按照f(x)除以这个斜率来平移x，就会得到切线到达0时的自变量的值。</p><p><code>newton_update</code>表示函数f及其导数df沿着这条切线到0的计算过程</p><div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">newton_update</span>(<span class="params">f, df</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="keyword">return</span> x - f(x) / df(x)</span><br><span class="line">    <span class="keyword">return</span> update</span><br></pre></td></tr></table></figure></div><p>最后，我们可以使用<code>newton_update</code>、<code>improve</code>算法以及比较f(x)是否接近0来定义<code>find_root</code>函数。</p><div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">find_zero</span>(<span class="params">f, df</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">near_zero</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="keyword">return</span> approx_eq(f(x), <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> improve(newton_update(f, df), near_zero)</span><br></pre></td></tr></table></figure></div><p>计算根：我们可以使用牛顿法来计算任意次方根。</p><p>如果我们可以找到最后一个方程的零点，那么我们就可以计算出n次方根。通过绘制n&#x3D;2、3、6，a&#x3D;64的曲线，我们可以将这种关系可视化</p><p>我们首先通过定义f和它的导数df来实现<code>square_root</code>函数，使用微积分中的知识，f(x)&#x3D;x²-a的导数是线性方程df(x) &#x3D; 2x。</p><div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">square_root_newton</span>(<span class="params">a</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="keyword">return</span> x * x - a</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">df</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * x</span><br><span class="line">    <span class="keyword">return</span> find_zero(f, df)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>square_root_newton(<span class="number">64</span>)</span><br><span class="line"><span class="number">8.0</span></span><br></pre></td></tr></table></figure></div><p>推广到n次方根，我们可以得到f(x)&#x3D;x^n-a和它的导数df(x) &#x3D; nx^n-1</p><div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">power</span>(<span class="params">x, n</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;返回n个x相乘&quot;&quot;&quot;</span></span><br><span class="line">    product, k = <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> k &lt; n:</span><br><span class="line">        product, k = product*x, k + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> product</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">nth_root_of_a</span>(<span class="params">n, a</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pow</span>(x, n) - a</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">df</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="keyword">return</span> n * power(x, n-<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> find_zero(f, df)</span><br></pre></td></tr></table></figure></div><p>所有这些计算中的近似误差都可以通过将<code>approx_eq</code>中的公差tolerance改为更小的数字来减小</p><p>当1使用牛顿法时，要注意它并不总是收敛的。<code>improve</code>的初始猜测必须足够接近零，并且必须满足有关函数的各种条件。尽管有这个缺点，牛顿法仍是一种用于求解微积分方程的强大的通用计算方法。现代计算机技术中的对数和大整数除法的快速算法，都采用了该方法的变体。</p><hr><h3 id="1-6-6-柯里化"><a href="#1-6-6-柯里化" class="headerlink" title="1.6.6 柯里化"></a>1.6.6 柯里化</h3><p>我们可以使用高阶函数将一个接受多个参数的函数转换为一个函数链，每个函数接受一个参数。</p><p>给定一个函数<code>f(x, y)</code>可以定义另一个函数<code>g</code>使得<code>g(x)(y) == f(x, y)</code>。g是一个高阶函数，它接受单个参数x并返回另一个接受单个参数y的函数。这种转化称为<strong>柯里化</strong></p><p>例如pow函数的柯里化版本</p><div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">curried_pow</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">h</span>(<span class="params">y</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pow</span>(x, y)</span><br><span class="line">    <span class="keyword">return</span> h</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>curried_pow(<span class="number">2</span>)(<span class="number">3</span>)</span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure></div><p>​感觉就是在嵌套函数的基础上，通过定义一个新的函数，然后传入两个参数，主函数返回定义的新的函数的值即可。</p><p>例如我们计算2的前10次方，我们就可以不用专门编写一个函数来实现。而是</p><div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>map_to_range(<span class="number">0</span>, <span class="number">10</span>, curried_pow)</span><br><span class="line">...</span><br></pre></td></tr></table></figure></div><p>我们可以类似地使用相同的两个函数来计算其他数字的幂。柯里化允许我们这么做，而无需为每个数字编写特定的函数。</p><p>上面，我们对<code>pow</code>进行了柯里化变换，得到了<code>curried_pow</code>。相反，我们可以定义函数来自动进行柯里化，以及逆柯里化变换。</p><div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">curry2</span>(<span class="params">f</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;返回给定的双参数函数的柯里化版本&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">g</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">h</span>(<span class="params">y</span>):</span><br><span class="line">            <span class="keyword">return</span> f(x, y)</span><br><span class="line">        <span class="keyword">return</span> h</span><br><span class="line">    <span class="keyword">return</span> g</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cuury2</span>(<span class="params">g</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;返回给定的柯里化函数的双参数版本&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">x, y</span>):</span><br><span class="line">        <span class="keyword">return</span> g(x, y)</span><br><span class="line">    <span class="keyword">return</span> f</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pow_curried = curried2(<span class="built_in">pow</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pow_curried(<span class="number">2</span>)(<span class="number">5</span>)</span><br><span class="line"><span class="number">32</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>map_to_range(<span class="number">0</span>, <span class="number">10</span>, pow_curried(<span class="number">2</span>))</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line">...</span><br><span class="line"><span class="number">512</span></span><br></pre></td></tr></table></figure></div><p><code>curry2</code>函数接受一个双参数函数<code>f</code>并返回一个单参数函数<code>g</code>。当<code>g</code>应用于参数<code>x</code>时，它返回一个单参数函数<code>h</code>。当<code>h</code>应用于参数y时，它调用<code>f(x, y)</code>。因此，<code>curry2(f)(x)(y)</code>等价于<code>f(x, y)</code>。<code>uncurry2</code>函数反转了柯里化变换，因此<code>uncurry2(curry2(f))</code>等价于<code>f</code></p><div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>uncurry2(pow_curried)(<span class="number">2</span>, <span class="number">5</span>)</span><br><span class="line"><span class="number">32</span></span><br></pre></td></tr></table></figure></div><hr><h3 id="1-6-7-Lambda表达式"><a href="#1-6-7-Lambda表达式" class="headerlink" title="1.6.7 Lambda表达式"></a>1.6.7 Lambda表达式</h3><p>在Python中，我们可以使用lambda表达式临时创建函数，这些表达式会计算为未命名的函数。一个lambda表达式的计算结果是一个<strong>函数</strong>，它仅有一个返回表达式作为主体。不允许使用赋值和控制语句。</p><div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">compose</span>(<span class="params">f, g</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">lambda</span> x: f(g(x))</span><br></pre></td></tr></table></figure></div><p>我们可以通过构造相应的英文句子来理解lambda表达式的结构</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lambda                    x                  :                  f(g(x))</span><br><span class="line">&quot;A function that          takes x            and returns        f(g(x))&quot;</span><br></pre></td></tr></table></figure></div><p>lambda表达式的结果称为lambda函数(匿名函数)。它没有固有名称，但除此之外它的行为与任何其他函数都相同</p><div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="keyword">lambda</span> x: x * x</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">&lt;function &lt;<span class="keyword">lambda</span>&gt; at ......</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s(<span class="number">12</span>)</span><br><span class="line"><span class="number">144</span></span><br></pre></td></tr></table></figure></div><p>从环境图当中来看的话，lambda表达式的结果也是一个函数，以希腊字母λ(lambda)命名。我们的<code>compose</code>示例就可以用lambda表达式非常简洁的表示出来</p><div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">compose1</span>(<span class="params">f, g</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">lambda</span> x: f(g(x))</span><br><span class="line">f = compose1(<span class="keyword">lambda</span> x: x * x, <span class="keyword">lambda</span> y: y + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">result = f(<span class="number">12</span>)</span><br></pre></td></tr></table></figure></div><p>虽然lambda表达式这种方式更短更直接。然而，它确实出了名的难以辨认。</p><p>一般来说，Python style更喜欢使用明确的<code>def</code>语句哈不是lambda表达式，但在需要简单函数作为参数或返回值的情况下可以使用它们。</p><hr><h3 id="1-6-8-抽象和一等函数"><a href="#1-6-8-抽象和一等函数" class="headerlink" title="1.6.8 抽象和一等函数"></a>1.6.8 抽象和一等函数</h3><p>作为程序员，我们应该警觉地寻找发现我们程序中的基本抽象，然后对其进行扩展，并加以推广去创建更强大的抽象。要选择符合任务地抽象级别。不过，重要的是我们能够思考这些抽象的概念，然后准备好将其应用到新的环境中。高阶函数的重要性在于，它们使我们将这些抽象显示地表示为我们编程语言中的元素，以便可以像其他元素一样处理。</p><p>一般而言，编程语言会对计算元素的操作方式施加限制。拥有最少限制的元素可以获得一等地位(first-class status)。这些一等元素的”权力和特权包括”</p><ol><li>可以与名称保定</li><li>可以作为参数传递给函数</li><li>可以作为函数的结果返回</li><li>可以包含在数据结构中</li></ol><p>Python授予函数完全的一等地位，由此带来的表达能力的提升是巨大的。</p><hr><h3 id="1-6-9-函数装饰器"><a href="#1-6-9-函数装饰器" class="headerlink" title="1.6.9 函数装饰器"></a>1.6.9 函数装饰器</h3><p>Python提供了一种特殊的语法来使用高阶函数作为执行<code>def</code>语句地一部分，称为装饰器(decorator)。最常见的例子也许就是<code>trace</code></p><div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">trace</span>(<span class="params">fn</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapped</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;-&gt;&#x27;</span>, fn, <span class="string">&#x27;(&#x27;</span>, x, <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> fn(x)</span><br><span class="line">    <span class="keyword">return</span> wrapped</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>@trace</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">triple</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span> * x</span><br><span class="line">    </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>triple(<span class="number">12</span>)</span><br><span class="line">-&gt; &lt;function triple at ... &gt;(<span class="number">12</span>)</span><br><span class="line"><span class="number">36</span></span><br></pre></td></tr></table></figure></div><p><code>triple</code>的<code>def</code>语句有一个注释(annotation)<code>@trace</code>，它会影响<code>def</code>执行的规则。和往常一样，函数<code>triple</code>被创建了。但是名称triple不会绑定到这个函数上，相反，这个名称会被绑定到在新定义的<code>triple</code>函数调用<code>trace</code>后返回的函数值上。代码中，这个装饰器等价于</p><div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">triple</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span> * x</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>triple = trace(triple)</span><br></pre></td></tr></table></figure></div><p>在本教材相关的项目中，装饰器被用于追踪，以及在从命令行运行程序时选择要调用哪些函数。</p><p>对于专家的额外内容：装饰器符号<code>@</code>也可以后跟一个调用表达式。跟在@后面的表达式会先被解析，然后是def语句，最后将装饰器表达式的运算结果应用到新定义的函数上，并将结果绑定到<code>def</code>语句中的名称上</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-6-高阶函数&quot;&gt;&lt;a href=&quot;#1-6-高阶函数&quot; class=&quot;headerlink&quot; title=&quot;1.6 高阶函数&quot;&gt;&lt;/a&gt;1.6 高阶函数&lt;/h1&gt;&lt;p&gt;我们已知函数是一种抽象方法，描述了与&lt;strong&gt;特定参数&lt;/strong&gt;无关的&lt;str</summary>
      
    
    
    
    <category term="CS61A" scheme="https://primeluoqiu.github.io/categories/CS61A/"/>
    
    
  </entry>
  
  <entry>
    <title>3.1-3 概述和传输层服务、多路复用和解复用、无连接传输UDP</title>
    <link href="https://primeluoqiu.github.io/2024/04/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.1-3/"/>
    <id>https://primeluoqiu.github.io/2024/04/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.1-3/</id>
    <published>2024-04-08T12:35:27.048Z</published>
    <updated>2024-04-08T12:37:36.010Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/04/08/QwEk2fO6.jpg"                      alt="61.jpg"                ><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/04/08/Zjtl3ltv.jpg"                      alt="62.jpg"                ><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/04/08/uDSZt1vB.jpg"                      alt="63.jpg"                ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;https://img2.imgtp.com</summary>
      
    
    
    
    <category term="计网" scheme="https://primeluoqiu.github.io/categories/%E8%AE%A1%E7%BD%91/"/>
    
    
  </entry>
  
  <entry>
    <title>第五周总结 + 第六周学习计划</title>
    <link href="https://primeluoqiu.github.io/2024/04/07/%E6%AF%8F%E5%91%A8%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/Week6/"/>
    <id>https://primeluoqiu.github.io/2024/04/07/%E6%AF%8F%E5%91%A8%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/Week6/</id>
    <published>2024-04-07T13:38:15.326Z</published>
    <updated>2024-04-07T13:41:49.446Z</updated>
    
    <content type="html"><![CDATA[<h4 id="第五周总结"><a href="#第五周总结" class="headerlink" title="第五周总结"></a>第五周总结</h4><p>其实本周内容还是把最最主要的计网完成了，不过看起来计网后面的题目相对来说还是比较难的。得认真地的看一下对应的题目。<br>然后就是准备蓝桥杯和复习来着，蓝桥杯好像是下周六，本周还是以计网和蓝桥杯为主吧，其余的话看情况学，底层还是要继续的</p><h5 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h5><p>1.计网看完第三章节，然后复习一下之前的两章<br>2.蓝桥杯复习<br>3.CS系列课程，记得更新就好<br>4.看点面向对象的语言</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;第五周总结&quot;&gt;&lt;a href=&quot;#第五周总结&quot; class=&quot;headerlink&quot; title=&quot;第五周总结&quot;&gt;&lt;/a&gt;第五周总结&lt;/h4&gt;&lt;p&gt;其实本周内容还是把最最主要的计网完成了，不过看起来计网后面的题目相对来说还是比较难的。得认真地的看一下对应的题目。&lt;</summary>
      
    
    
    
    <category term="大二下" scheme="https://primeluoqiu.github.io/categories/%E5%A4%A7%E4%BA%8C%E4%B8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>2.9 UDP套接字编程 + 本章小节</title>
    <link href="https://primeluoqiu.github.io/2024/04/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.9/"/>
    <id>https://primeluoqiu.github.io/2024/04/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.9/</id>
    <published>2024-04-07T03:50:18.322Z</published>
    <updated>2024-04-07T03:50:54.070Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/04/07/E2uC02S0.jpg"                      alt="59.jpg"                ><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/04/07/m8szHXnc.jpg"                      alt="60.jpg"                ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;https://img2.imgtp.com</summary>
      
    
    
    
    <category term="计网" scheme="https://primeluoqiu.github.io/categories/%E8%AE%A1%E7%BD%91/"/>
    
    
  </entry>
  
  <entry>
    <title>2.8 TCP套接字编程</title>
    <link href="https://primeluoqiu.github.io/2024/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.8/"/>
    <id>https://primeluoqiu.github.io/2024/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.8/</id>
    <published>2024-04-06T13:57:31.127Z</published>
    <updated>2024-04-06T13:59:01.246Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/04/06/uMODHIAC.jpg"                      alt="56.jpg"                ><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/04/06/ZW10ZehE.jpg"                      alt="57.jpg"                ><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/04/06/MBxZIUZg.jpg"                      alt="58.jpg"                ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;https://img2.imgtp.com</summary>
      
    
    
    
    <category term="计网" scheme="https://primeluoqiu.github.io/categories/%E8%AE%A1%E7%BD%91/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://primeluoqiu.github.io/2024/04/06/Algorithm/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/%E7%AC%AC%E4%B8%80%E7%AB%A0/"/>
    <id>https://primeluoqiu.github.io/2024/04/06/Algorithm/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/%E7%AC%AC%E4%B8%80%E7%AB%A0/</id>
    <published>2024-04-06T13:55:22.142Z</published>
    <updated>2024-04-06T13:54:09.345Z</updated>
    
    <content type="html"><![CDATA[<h3 id="深度优先搜索-DFS"><a href="#深度优先搜索-DFS" class="headerlink" title="深度优先搜索(DFS)"></a>深度优先搜索(DFS)</h3><p>很执着，尽可能的往深搜。当搜不到的时候回溯，然后回溯完之后看看，当前是不是所有的路径都遍历过了。</p><p>对于数据结构来讲：使用的是栈</p><p>空间：O(n)</p><p>不具有最短性</p><p>第一次搜索完之后不一定具备最短性</p><p>存在两个概念</p><h4 id="概念1：回溯"><a href="#概念1：回溯" class="headerlink" title="概念1：回溯"></a>概念1：回溯</h4><h4 id="概念2：剪枝"><a href="#概念2：剪枝" class="headerlink" title="概念2：剪枝"></a>概念2：剪枝</h4><p>DFS最重要的是顺序，要考虑是用一个什么样的顺序来比遍历整个方案。想不清楚的话画棵树考虑一下。</p><p>对于本题而言，顺序有很多种，这里的搜索顺序是假设我们已经有n个空位了，从第一位开始填，从前往后填，每次填的时候数字不能和前面一样就可以了。最开始状态是n个空，第一位有三种填法，分别对应三个不同的分支。深搜的话会继续往下搜，也就是搜第二个位置，第二个位置也有三种方案。但是深搜的时候不会把方案先画出来，直接走到黑。第二位枚举一下，第一位确定了是1，那第二位肯定不能是1，因为重复了，第二位只能先填2，优先往下走，就只剩第三位，那么第三位就只剩下3了，这个时候分支对应的就是123，已经无路可走，然后回退一步。回到填写第二位的时候，发现第二位还有一条路可以走，还可以填3，那么就填上3，就是有3的分支，那么132，再回溯，无路可走，在回溯，回到根节点，这个时候就要枚举2这个分支。</p><p>求全排列的过程，是可以用DFS来做的。搜索顺序可以看成一棵树。当然只是看成一棵树，每次存的时候存储的都是路径，回溯的时候就没了，不需要存数和栈。在回溯的时候一定要记得回复现场。下去的时候是什么样子，回溯回来的话还得是那个样子。走的时候分支看到的状态是一样的。</p><p>看一下代码怎么写：</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> path[N]; <span class="comment">//状态用一个全局数组来存,存储的是方案 </span></span><br><span class="line"><span class="type">bool</span> st[N]; <span class="comment">//true表示点被用过了</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> u)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//当完美走到n,说明全部填满了</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n;i ++) <span class="built_in">cout</span> &lt;&lt; path[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!st[i])</span><br><span class="line">        &#123;</span><br><span class="line">            path[u] = i; <span class="comment">//i放到当前位置上</span></span><br><span class="line">            st[i] = <span class="literal">true</span>; <span class="comment">//记录i已经被用过了</span></span><br><span class="line">            dfs(u + <span class="number">1</span>); <span class="comment">//状态处理好之后递归到下一层</span></span><br><span class="line">            st[i] = <span class="literal">false</span>; <span class="comment">//恢复现场 path不需要回复，会覆盖，递归函数结束之后一定要记得恢复。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    dfs(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>还有一个经典的N皇后问题，有很多种搜索方式</p><p>​在n*n的棋盘上放n个皇后，皇后可以横竖斜着走，让任何两个皇后不能互相攻击到，给定一个n，输出所有的方案</p><p>比如说：搜索全排列的思路是一样的，搜索顺序是：先看一下同一行同一列只放一个皇后，先看第一行皇后可以放在那一列。枚举每一行皇后可以放到哪里去。从第一位开始枚举。递归枚举第二行皇后放到那…这里要注意<strong>剪枝</strong>。这是按照全排列的方法来枚举。</p><p>也可以先生成一个全排列，然后再判断。也是可以的。</p><p>蛋柿呢，也可以边做边判断，假设枚举了一个4，直接判断有没有冲突，如果有冲突，就不用再往下走，直接停止了。可以看作是把枝剪掉，直接回溯，这就是剪枝了。</p><p>那么这种方法对应的解决方案是</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">20</span>;</span><br><span class="line"><span class="type">bool</span> col[N], dg[N], udg[N];</span><br><span class="line"><span class="type">char</span> g[N][N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u == n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) <span class="built_in">puts</span>(g[i]);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!col[i] &amp;&amp; !dg[u + i] &amp;&amp; !udg[n - u + i])</span><br><span class="line">        &#123;</span><br><span class="line">            g[u][i] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">            col[i] = dg[u + i] = udg[n - u + i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(u + <span class="number">1</span>);</span><br><span class="line">            col[i] = dg[u + i] = udg[n - u + i] = <span class="literal">false</span>;</span><br><span class="line">            g[u][i] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++)</span><br><span class="line">            g[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>没有模板，只有顺序和思路。</p><p>除了这种方式之外，我们还可以用一种更原始的方式来解决这种问题。也就是说，对于每个点而言，都有两种状态，分别是放或者不放这两种分支，然后我们挨个枚举所有格子，当枚举到n²格子的时候，就结束了。这个更加原始，更加接近题目的选项的方式</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">20</span>;</span><br><span class="line"><span class="type">bool</span> row[N], col[N], dg[N], udg[N];</span><br><span class="line"><span class="type">char</span> g[N][N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(y == n) y = <span class="number">0</span>, x ++;</span><br><span class="line">    <span class="keyword">if</span>(x == n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s == n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n; i ++) <span class="built_in">puts</span>(g[i]);</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//不放皇后</span></span><br><span class="line">    <span class="built_in">dfs</span>(x, y + <span class="number">1</span>, s);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//放皇后</span></span><br><span class="line">    <span class="keyword">if</span>(!row[x] &amp;&amp; !col[y] &amp;&amp; !dg[x + y] &amp;&amp; !udg[x - y + n])</span><br><span class="line">    &#123;</span><br><span class="line">        g[x][y] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">        row[x] = col[y] = dg[x + y] = udg[x - y + n] = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(x, y + <span class="number">1</span>, s + <span class="number">1</span>);</span><br><span class="line">        row[x] = col[y] = dg[x + y] = udg[x - y + n] = <span class="literal">false</span>;</span><br><span class="line">        g[x][y] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++)</span><br><span class="line">            g[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="宽度优先搜索-BFS"><a href="#宽度优先搜索-BFS" class="headerlink" title="宽度优先搜索(BFS)"></a>宽度优先搜索(BFS)</h3><p>按层搜索。同时看很多条路，第一次看第一层，第二次看第二层。第二层搜完之后再搜第三层。每次只扩展一层。</p><p>数据结构：队列</p><p>空间：O(n^2)</p><p>有最短路的概念，第一次扩展到的点，一定是离他最近的点</p><p>为什么可以呢？是一圈一圈往外扩展，可以搜到的点是离起点越来越远的。第一次搜到的一定是距离最小的。前提是图里的边权重必须都得是1.</p><h3 id="树与图的存储"><a href="#树与图的存储" class="headerlink" title="树与图的存储"></a>树与图的存储</h3><h3 id="树与图的深度优先遍历"><a href="#树与图的深度优先遍历" class="headerlink" title="树与图的深度优先遍历"></a>树与图的深度优先遍历</h3><h3 id="树与图的宽度优先遍历"><a href="#树与图的宽度优先遍历" class="headerlink" title="树与图的宽度优先遍历"></a>树与图的宽度优先遍历</h3><h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;深度优先搜索-DFS&quot;&gt;&lt;a href=&quot;#深度优先搜索-DFS&quot; class=&quot;headerlink&quot; title=&quot;深度优先搜索(DFS)&quot;&gt;&lt;/a&gt;深度优先搜索(DFS)&lt;/h3&gt;&lt;p&gt;很执着，尽可能的往深搜。当搜不到的时候回溯，然后回溯完之后看看，当前是不</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Ts快速入门</title>
    <link href="https://primeluoqiu.github.io/2024/04/06/HarmonyOsDeveloper/Ts%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
    <id>https://primeluoqiu.github.io/2024/04/06/HarmonyOsDeveloper/Ts%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</id>
    <published>2024-04-05T16:37:05.386Z</published>
    <updated>2024-04-05T16:42:07.571Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h3><p>赋值语句:<code>let 变量名: 变量类型  = 值</code></p><p>变量类型还是布尔值、数字、字符串(单引号双引号都可以)、数组、元组、枚举、Unknown、Void和Undefined以及联合类型</p><p>数字：</p><p>所有数字全部都是浮点数，类型是<code>number</code>。支持标准进制</p><div class="highlight-container" data-rel="Ts"><figure class="iseeu highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">decLiteral</span>: <span class="built_in">number</span> = <span class="number">2023</span>;</span><br></pre></td></tr></table></figure></div><p>两种定义方式:</p><p>元素后+[]，表示由此类型元素组成的一个数组</p><div class="highlight-container" data-rel="Typescript"><figure class="iseeu highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">list</span>: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure></div><p>第二种:使用数组泛型，Array&lt;元素类型&gt;</p><div class="highlight-container" data-rel="Ts"><figure class="iseeu highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">list</span>: <span class="title class_">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure></div><p>元组：元组类型允许表示一个已知元素数量和类型的数组。各元素的类型不必相同。比如，可以定义一对值分别为<code>string</code>和<code>number</code>类型的元组，顺序不可相反</p><div class="highlight-container" data-rel="Ts"><figure class="iseeu highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">x</span>: [<span class="built_in">string</span>, <span class="built_in">number</span>];</span><br><span class="line">x = [<span class="string">&#x27;hello&#x27;</span>, <span class="number">10</span>];</span><br></pre></td></tr></table></figure></div><p>枚举：</p><p><code>enum</code>类型是对js标准数据类型的一个补充，使用枚举类型可以为一组数值赋予友好的名字</p><div class="highlight-container" data-rel="Ts"><figure class="iseeu highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;<span class="title class_">Red</span>, <span class="title class_">Green</span>, <span class="title class_">Blue</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">c</span>: <span class="title class_">Color</span> = <span class="title class_">Color</span>.<span class="property">Green</span>; </span><br></pre></td></tr></table></figure></div><p>Unknow:为编程阶段还尚不清楚类型的变量指定一个类型。在这种情况下，不希望类型检查器对这些值进行检查而实直接通过编译阶段的检查。便可以使用Unknown</p><p>Void还是出现在函数返回值类型。</p><p>在ts中，undefined和null各自有自己的类型分别叫做undefined和null</p><p>联合类型(Union Type): 取值可以为多种类型中的一种</p><div class="highlight-container" data-rel="Ts"><figure class="iseeu highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">myFavouriteNumver</span>: <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line">myFavouriteNumber = <span class="string">&#x27;seven&#x27;</span>;</span><br><span class="line">myFavouriteNumber = <span class="number">7</span>;</span><br></pre></td></tr></table></figure></div><hr><h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><p>通过一条或者多条的执行结果来决定执行的代码块</p><h4 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h4><div class="highlight-container" data-rel="Ts"><figure class="iseeu highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="attr">num</span>: <span class="built_in">number</span> = <span class="number">5</span></span><br><span class="line"><span class="keyword">if</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;数字是正数&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>其他的和C语言类似</p><h4 id="switch…case语句"><a href="#switch…case语句" class="headerlink" title="switch…case语句"></a>switch…case语句</h4><div class="highlight-container" data-rel="Ts"><figure class="iseeu highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="attr">grade</span>: <span class="built_in">string</span> = <span class="string">&#x27;A&#x27;</span></span><br><span class="line"><span class="keyword">switch</span>(grade) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>: &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;优秀&#x27;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span>: &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;良&#x27;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span>: &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;及格&#x27;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attr">default</span>: &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;非法输入&#x27;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><hr><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>是一组一起执行一个任务的语句，函数声明要告诉编译器函数的名称、返回类型和参数。Ts可以创建有名的函数和匿名函数，创建方法如下</p><div class="highlight-container" data-rel="Ts"><figure class="iseeu highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//有名函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//匿名函数</span></span><br><span class="line"><span class="keyword">let</span> myAdd = <span class="keyword">function</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><h4 id="为函数定义类型"><a href="#为函数定义类型" class="headerlink" title="为函数定义类型"></a>为函数定义类型</h4><p>为了确保输入输出的准确性，我们可以为函数添加类型:</p><div class="highlight-container" data-rel="Ts"><figure class="iseeu highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有名函数: 给变量设置为number类型</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匿名函数: 给变量设置为number类型</span></span><br><span class="line"><span class="keyword">let</span> myAdd = <span class="keyword">function</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h4><p>在Ts里可以在参数名旁边使用<code>?</code>实现可选参数的功能。比如，我们想让lastName是可选的:</p><div class="highlight-container" data-rel="Ts"><figure class="iseeu highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">buildName</span>(<span class="params">firstName: <span class="built_in">string</span>, lastName?: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(lastName)</span><br><span class="line">        <span class="keyword">return</span> firstName + <span class="string">&#x27; &#x27;</span> + lastName;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> firstName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = <span class="title function_">buildName</span>(<span class="string">&#x27;Bob&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> result2 = <span class="title function_">buildName</span>(<span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Adams&#x27;</span>);</span><br></pre></td></tr></table></figure></div><h4 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h4><p>剩余参数会被当做个数不限的可选参数，可以一个都没有，同样也可以有任意个。可以使用省略号(…)进行定义:</p><div class="highlight-container" data-rel="Ts"><figure class="iseeu highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getEmployeeName</span>(<span class="params">firstName: <span class="built_in">string</span>, ...restOfName: <span class="built_in">string</span>[]</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> firstName + <span class="string">&#x27; &#x27;</span> + restOfName.<span class="title function_">join</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> employeeName = <span class="title function_">getEmployeeName</span>(<span class="string">&#x27;Joseph&#x27;</span>, <span class="string">&#x27;Samuel&#x27;</span>, <span class="string">&#x27;Luces&#x27;</span>, <span class="string">&#x27;MacKinzie&#x27;</span>);</span><br></pre></td></tr></table></figure></div><h4 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h4><p>es6版本的ts提供了一个箭头函数，它是定义匿名函数的简写语法，用于函数表达式，省略了function关键字。箭头函数的定义如下，其函数是一个语句块:</p><div class="highlight-container" data-rel="Ts"><figure class="iseeu highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">( [param1, param2, ... param n] ) =&gt; &#123;</span><br><span class="line">    <span class="comment">//代码块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>其中，括号内是函数的入参，可以有0到多个参数，箭头后是函数的代码块。我们可以将这个箭头函数赋值给一个变量，如下所示</p><div class="highlight-container" data-rel="Ts"><figure class="iseeu highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">arrowFun</span> = (<span class="params"> [param1, param2, ... param n] </span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">//代码块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>如何要主动调用这个箭头函数，可以按如下方法调用:</p><div class="highlight-container" data-rel="Ts"><figure class="iseeu highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">arrowFun</span>(param1, param2, ... param n)</span><br></pre></td></tr></table></figure></div><p>那么如何将熟悉的函数定义方式转换成箭头函数</p><div class="highlight-container" data-rel="Ts"><figure class="iseeu highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">testNumber</span>(<span class="params">num: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">testArrowFun</span> = (<span class="params">num: <span class="built_in">number</span></span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">//函数体内容一致</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>后面在开发HarmonyOS时会经常用到箭头函数。例如，给一个按钮添加点击事件，其中onClick事件中的函数就是箭头函数</p><div class="highlight-container" data-rel="Ts"><figure class="iseeu highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Button</span>(<span class="string">&quot;Click Now&quot;</span>)</span><br><span class="line">.<span class="title function_">onClick</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">info</span>(<span class="string">&quot;Button is click&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div><hr><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>Ts支持基于类的面向对象的编程方式，定义类的关键字为class，后面紧跟类名。类描述了所创建的对象共同的属性和方法。</p><h4 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h4><p>例如，我们可以声明一个Person类，这个类有三个成员：一个是属性(包含name和age)，一个是构造函数，一个是getPersonInfo方法，其定义如下所示</p><div class="highlight-container" data-rel="Ts"><figure class="iseeu highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">    <span class="keyword">private</span> <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">    </span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">getPersonInfo</span>(): <span class="built_in">string</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;My name is $&#123;this.name&#125; and age is $&#123;this.age&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>继承就是子类继承父类的特征和行为，使得子类具有父亲相同的行为。Ts中允许使用继承来扩展现有的类，对应的关键字为extend。</p><div class="highlight-container" data-rel="Ts"><figure class="iseeu highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="attr">department</span>: <span class="built_in">string</span></span><br><span class="line">    </span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span>, department: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>(name, age);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">department</span> = department;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">getEmployeeInfo</span>(): <span class="built_in">string</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">getPersonInfo</span>() + <span class="string">`and work in <span class="subst">$&#123;<span class="variable language_">this</span>.department&#125;</span>`</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>通过上面的Employee类，可以定义一个人物并获取他的基本信息，具体使用场景参考相关学习资料。</p><h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p>随着应用越来越大，通常要将代码拆分成多个文件，即所谓的模块（module）。模块可以相互加载，并可以使用特殊的指令 export 和 import 来交换功能，从另一个模块调用一个模块的函数。</p><p>两个模块之间的关系是通过在文件级别上使用 import 和 export 建立的。模块里面的变量、函数和类等在模块外部是不可见的，除非明确地使用 export 导出它们。类似地，我们必须通过 import 导入其他模块导出的变量、函数、类等。</p><h4 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h4><p>任何声明(比如变量、函数、类、类型别名和接口)都能通过添加export关键字来导出，例如要导出一个类</p><div class="highlight-container" data-rel="Ts"><figure class="iseeu highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">NewsData</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h4><div class="highlight-container" data-rel="Ts"><figure class="iseeu highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;<span class="title class_">NewsData</span>&#125; <span class="keyword">from</span> <span class="string">&#x27;../common/bean/NewsData&#x27;</span>;</span><br></pre></td></tr></table></figure></div><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>当一个对象实现了Symbol.iterator属性时，我们认为它是可迭代的。一些内置的类型如Array，Map，Set，String，Int32Array，Uint32Array等都具有可迭代性。</p><h4 id="for…of语句"><a href="#for…of语句" class="headerlink" title="for…of语句"></a>for…of语句</h4><p>for..of会遍历可迭代的对象，调用对象上的Symbol.iterator方法。下面是在数组上使用for..of的简单例子:</p><div class="highlight-container" data-rel="Ts"><figure class="iseeu highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> someArray = [<span class="number">1</span>, <span class="string">&quot;string&quot;</span>, <span class="literal">false</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> entry <span class="keyword">of</span> someArray) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(entry); <span class="comment">// 1, &quot;string&quot;, false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="for…in语句"><a href="#for…in语句" class="headerlink" title="for…in语句"></a>for…in语句</h4><p>上述两种方式均可迭代一个列表，但是用于迭代的值却不同:for…in迭代的是对象的键，而for..of则迭代的是对象的值</p><div class="highlight-container" data-rel="Ts"><figure class="iseeu highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> list = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> list) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i) <span class="comment">// &quot;0&quot;, &quot;1&quot;, &quot;2&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> <span class="keyword">in</span> <span class="keyword">of</span> list) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">//&quot;4&quot;, &quot;5&quot;, &quot;6&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>TypeScript是一个开源的编程语言，本章节只有TypeScript的基础语法知识，更多内容参考TypeScript的官方教程（<a class="link"   href="https://www.typescriptlang.org/docs/%EF%BC%89%E3%80%82" >https://www.typescriptlang.org/docs/）。 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;基础类型&quot;&gt;&lt;a href=&quot;#基础类型&quot; class=&quot;headerlink&quot; title=&quot;基础类型&quot;&gt;&lt;/a&gt;基础类型&lt;/h3&gt;&lt;p&gt;赋值语句:&lt;code&gt;let 变量名: 变量类型  = 值&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;变量类型还是布尔值、数字、字符串(单</summary>
      
    
    
    
    <category term="OpenHarmonyDeveloper" scheme="https://primeluoqiu.github.io/categories/OpenHarmonyDeveloper/"/>
    
    
  </entry>
  
  <entry>
    <title>2.7 CDN(内容分发网络)</title>
    <link href="https://primeluoqiu.github.io/2024/04/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.7/"/>
    <id>https://primeluoqiu.github.io/2024/04/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.7/</id>
    <published>2024-04-05T06:31:06.791Z</published>
    <updated>2024-04-05T06:33:13.372Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/04/05/FoZrhkS8.jpg"                      alt="54.jpg"                ><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/04/05/QvnBufgw.jpg"                      alt="55.jpg"                ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;https://img2.imgtp.com</summary>
      
    
    
    
    <category term="计网" scheme="https://primeluoqiu.github.io/categories/%E8%AE%A1%E7%BD%91/"/>
    
    
  </entry>
  
  <entry>
    <title>2.6 P2P</title>
    <link href="https://primeluoqiu.github.io/2024/04/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.6/"/>
    <id>https://primeluoqiu.github.io/2024/04/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.6/</id>
    <published>2024-04-04T15:29:50.750Z</published>
    <updated>2024-04-04T15:30:55.076Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/04/04/R3X2Nco5.jpg"                      alt="50.jpg"                ><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/04/04/TFIyogDt.jpg"                      alt="51.jpg"                ><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/04/04/CUZMPxTG.jpg"                      alt="52.jpg"                ><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/04/04/ayBVCH5r.jpg"                      alt="53.jpg"                ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;https://img2.imgtp.com</summary>
      
    
    
    
    <category term="计网" scheme="https://primeluoqiu.github.io/categories/%E8%AE%A1%E7%BD%91/"/>
    
    
  </entry>
  
  <entry>
    <title>2.5 DNS</title>
    <link href="https://primeluoqiu.github.io/2024/04/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.5/"/>
    <id>https://primeluoqiu.github.io/2024/04/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.5/</id>
    <published>2024-04-03T14:32:46.454Z</published>
    <updated>2024-04-03T14:42:13.470Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/04/03/eDDtt0xR.jpg"                      alt="45.jpg"                ><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/04/03/7QasoPyg.jpg"                      alt="46.jpg"                ><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/04/03/rQvuGoqE.jpg"                      alt="47.jpg"                ><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/04/03/dXTAhcmR.jpg"                      alt="48.jpg"                ><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/04/03/GXV38DGF.jpg"                      alt="49.jpg"                ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;https://img2.imgtp.com</summary>
      
    
    
    
    <category term="计网" scheme="https://primeluoqiu.github.io/categories/%E8%AE%A1%E7%BD%91/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://primeluoqiu.github.io/2024/04/02/Algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(%E4%B8%89)/"/>
    <id>https://primeluoqiu.github.io/2024/04/02/Algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(%E4%B8%89)/</id>
    <published>2024-04-02T14:10:44.252Z</published>
    <updated>2024-04-02T14:11:48.550Z</updated>
    
    <content type="html"><![CDATA[<hr><p>title: 哈希表和STL</p><p>categories: Algorithm</p><hr><h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><p>哈希表实际上就是把一个很大范围的数据结构映射成为一个很小的数据范围的东西。举例来说，比如说想把从0-10的9次方这些数映射到从0到10的五次方左右的一些数。</p><p>比如现在有一批数的范围是-10九次方到+10的九次方，然后通过一个哈希函数把它们放进一个很小的(10的五次方)的范围之内。</p><p>哈希函数的一些问题，例如：</p><ol><li><p>哈希函数一般怎么写：就是直接模一个数，例如可以直接模10^5。</p></li><li><p>冲突定义域比较大，映射的结果比较小，那么必然会产生冲突，把两个不一样的数映射到同一个数。按照处理冲突的方式分为开放寻址法和拉链法。</p></li></ol><h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><h3 id="开放寻址法"><a href="#开放寻址法" class="headerlink" title="开放寻址法"></a>开放寻址法</h3><p>通俗来讲的话，也叫蹲坑法，什么意思呢，就是说，我们只需要一个数组就可以了，但是这个数组的大小一般要开到题目范围的2-3倍，然后就像大家上厕所一样，当一个坑位被占了的时候，只能去找下一个坑位，然后下一个坑位被占了再找下一个，也就意味着说，我们先通过函数来寻找到k，但是如果那个k被占用了的话，那么就去k+1，如果k+1被占用了，就去k+2…</p><p>然后这个方法主要就是find函数的实现，然后插入的话，就是通过find找到对应的位置，然后把x放进去就可以了，而查找的话就是如果对应的位置不是空的，那么就是有的，不然就是没有。删除其实也可以看做另外一种形式的查找，因为并不是真正的删除，而是对那个点做一个标记</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e6</span> + <span class="number">3</span>, null = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> h[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k = (x % N + N) % N;</span><br><span class="line">    <span class="keyword">while</span>(h[k] != null &amp;&amp; h[k] != x)</span><br><span class="line">    &#123;</span><br><span class="line">        k ++;</span><br><span class="line">        <span class="keyword">if</span>(k == N) k = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(h));</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(n --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d&quot;</span>, op, &amp;x);</span><br><span class="line">        <span class="type">int</span> k = <span class="built_in">find</span>(x);</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">&#x27;I&#x27;</span>) h[k] = x;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(h[k] != null)</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h3><p>简单来讲，就是说，先开出来一个空间，然后例如我们把h(11)映射到了3，h(23)也映射到了3，这个时候，我们就在3的下面拉一个线，类似拉链一样。多一个点就多一个线。然后一般哈希表只会存在两种操作，分别是添加和查找，添加很简单，只需要通过对应的哈希函数找到它的位置，然后添加一条拉链就可以了，查找的话，就是先看出来这个数值哈希完之后是什么，如果是某个点，然后顺着那个点去查找是不是有那个值。一般不会有删除操作的，就算有，也不是真的把那个数值删了，而是给那个点打个标记，例如布尔变量，然后就删除掉了。</p><p>这里要注意一个点，我们的哈希函数模的那个值最好是一个质数，而且距离2的多少次方比较远，这样能够保证冲突的概率是最小的。</p><p>接下来，看一下我们拉链法的模板</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> h[N], e[N], ne[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k = (x % N + N) % N;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    ne[idx] = h[k];</span><br><span class="line">    h[k] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k = (x % N + N) % N;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[k]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(e[i] == x)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="built_in">sizeof</span>(h));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(n --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d&quot;</span>, op, &amp;x);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">&#x27;I&#x27;</span>) <span class="built_in">insert</span>(x);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(x)) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="字符串哈希方式"><a href="#字符串哈希方式" class="headerlink" title="字符串哈希方式"></a>字符串哈希方式</h2><p>一种特殊的方式：字符串前缀哈希法。</p><p>求哈希之前，先预处理出来所有前缀的哈希。</p><p>那么如何处理出来所有前缀的哈希呢？</p><p>我们可以把每个字符串看成是一个<code>P</code>进制的数，例如”ABCD”是一个p进制的数，然后我们将它转化成为一个十进制的数，那么”ABCD”如果分别代表第一位第二位第三位和第四位的话，那么它可以转化成<br>$$<br>1<em>p^3+2</em>p^2+3<em>p^1+4</em>p^0<br>$$<br>那么当这个字符串比较长的时候，这个数值就会变得很大，那么我们不妨给它模一个<code>Q</code>让他变小，然后我们就把范围缩小到了0-<code>Q-1</code></p><p>不过有两个值得注意的点</p><ol><li>首先是任何一个字母都不能映射成0，毕竟0在任何进制上转换成十进制的时候都是0。</li><li>这个是建立在我们rp(人品)足够好的前提下，也就是说不存在冲突的情况。</li></ol><p>不过这倒是有个经验值可以保证在99.99%的前提下不会出现冲突，就是指当p &#x3D; 131&#x2F;13331，且Q &#x3D; 2^64的时候，就可以了</p><p>这么处理的好处是什么呢？</p><p>就是说我们可以通过一个公式来计算出所有子串的哈希值。</p><p>那么，具体是什么公式呢？</p><p>就是说，有一个线段，例如从L-R，那么我们把从1-L这一段让它和L-R这一段对齐，那么用这两段相减就可以了。那么最后的公式就是</p><p>h[R] - h[L] * p ^ (R - L + 1)</p><p>Q是等于2^64,如果我们这个时候开一个<code>unsigned long long</code>的话，那么只要溢出的话就相当于是自动模上2^64了</p><p>预处理的话就是</p><p><code>h(i) = h(i - 1) * p + str[i]</code></p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ULL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>, P = <span class="number">131</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">char</span> str[N];</span><br><span class="line">ULL h[N], p[N]; <span class="comment">//p[N]用来存储公式中的L-R+1</span></span><br><span class="line"></span><br><span class="line"><span class="function">ULL <span class="title">get</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h[r] - h[l - <span class="number">1</span>] * p[r - l + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%s&quot;</span>, &amp;n, &amp;m, str + <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        p[i] = p[i - <span class="number">1</span>] * P;</span><br><span class="line">        h[i] = h[i - <span class="number">1</span>] * P + str[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (m --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l1, r1, l2, r2;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;l1, &amp;r1, &amp;l2, &amp;r2);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">get</span>(l1, r1) == <span class="built_in">get</span>(l2, r2)) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h1 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h1><h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><p>实际上就是一个变长数组，倍增的思想。</p><p>有这样的一些函数</p><p><code>size()</code>返回元素个数</p><p><code>empty()</code>返回是否为空</p><p><code>clean()</code>清空这个vector</p><p><code>front()/ back()</code>最前面的和最后面的</p><p><code>push_back() / pop_back()</code>在最后插入和把最后一个删掉</p><p><code>begin() / end()</code>第0个和最后一个的后一个，也就是迭代器。</p><h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><p>字符串，一些常用的函数例如<code>substr()</code>、<code>c_str()</code></p><h3 id="queue-priority-queue"><a href="#queue-priority-queue" class="headerlink" title="queue, priority_queue"></a>queue, priority_queue</h3><p>队列,<code>push()</code>, <code>pop()</code> ,<code>front()</code></p><h3 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h3><p>栈,<code>push()</code>, <code>pop()</code>, <code>front()</code></p><h3 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h3><p>双端队列，也就是在队列的基础上让队列的头和尾都可以插入和删除</p><h3 id="set-map-multiset-multimap"><a href="#set-map-multiset-multimap" class="headerlink" title="set, map, multiset, multimap"></a>set, map, multiset, multimap</h3><p>基于平衡二叉树(红黑树)，动态维护有序序列</p><h3 id="unordered-map-unordered-set-unordered-multiset-unordered-multimap"><a href="#unordered-map-unordered-set-unordered-multiset-unordered-multimap" class="headerlink" title="unordered_map, unordered_set, unordered_multiset, unordered_multimap"></a>unordered_map, unordered_set, unordered_multiset, unordered_multimap</h3><p>哈希表</p><h3 id="bitset"><a href="#bitset" class="headerlink" title="bitset"></a>bitset</h3><p>压位</p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;p&gt;title: 哈希表和STL&lt;/p&gt;
&lt;p&gt;categories: Algorithm&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;哈希表&quot;&gt;&lt;a href=&quot;#哈希表&quot; class=&quot;headerlink&quot; title=&quot;哈希表&quot;&gt;&lt;/a&gt;哈希表&lt;/h1&gt;&lt;p&gt;哈希表实际</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>2.3 &amp; 2.4 FTP &amp; Email</title>
    <link href="https://primeluoqiu.github.io/2024/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.3.4/"/>
    <id>https://primeluoqiu.github.io/2024/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.3.4/</id>
    <published>2024-04-02T11:50:04.609Z</published>
    <updated>2024-04-02T11:51:37.209Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/04/02/eQAl7p0k.jpg"                      alt="42.jpg"                ><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/04/02/qbJOFAiA.jpg"                      alt="43.jpg"                ><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/04/02/rW9brCrU.jpg"                      alt="44.jpg"                ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;https://img2.imgtp.com</summary>
      
    
    
    
    <category term="计网" scheme="https://primeluoqiu.github.io/categories/%E8%AE%A1%E7%BD%91/"/>
    
    
  </entry>
  
  <entry>
    <title>Week5 and Daily Schedule</title>
    <link href="https://primeluoqiu.github.io/2024/04/01/%E6%AF%8F%E5%91%A8%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/Week5/"/>
    <id>https://primeluoqiu.github.io/2024/04/01/%E6%AF%8F%E5%91%A8%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/Week5/</id>
    <published>2024-04-01T13:54:40.572Z</published>
    <updated>2024-04-07T13:41:25.771Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Daily-Schedule"><a href="#Daily-Schedule" class="headerlink" title="Daily Schedule"></a>Daily Schedule</h1><h2 id="Total-Schedule"><a href="#Total-Schedule" class="headerlink" title="Total Schedule"></a>Total Schedule</h2><ol><li>《计算机网络》-郑铨老师的 2.3-2.10(第二章看完)</li><li>CS61A 看完第一章</li><li>每天更新一点算法内容</li></ol><p>每天任务的话，先看周一吧，周一相对来说课不算多，下午有一节毛概，毛概课的话得补半节课的数电笔记和作业</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Daily-Schedule&quot;&gt;&lt;a href=&quot;#Daily-Schedule&quot; class=&quot;headerlink&quot; title=&quot;Daily Schedule&quot;&gt;&lt;/a&gt;Daily Schedule&lt;/h1&gt;&lt;h2 id=&quot;Total-Schedule&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="大二下" scheme="https://primeluoqiu.github.io/categories/%E5%A4%A7%E4%BA%8C%E4%B8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>Week4 总结</title>
    <link href="https://primeluoqiu.github.io/2024/04/01/%E6%AF%8F%E5%91%A8%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/Week4%E6%80%BB%E7%BB%93/"/>
    <id>https://primeluoqiu.github.io/2024/04/01/%E6%AF%8F%E5%91%A8%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/Week4%E6%80%BB%E7%BB%93/</id>
    <published>2024-04-01T13:51:52.141Z</published>
    <updated>2024-04-01T13:54:24.593Z</updated>
    
    <content type="html"><![CDATA[<p>本周内容学习的不多，不过计网内容算是比较完美的达成了，就是昨天身体不大舒服，不然熬一下基本上任务就完成了。这种每周都有任务的感觉还是蛮爽的。然后其实还是很喜欢这种每天都有一定的任务量的感觉，这样的话完成之后内心也会收获一份成就感。</p><p>CS61A的进度不算很快，也不知道是不是学习方法的问题，现在进展速度奇慢，61B也没来得及看，更别提61C和CSAPP了，下周还有蓝桥杯要准备。加油吧，还要再重温一下算法的相关知识。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本周内容学习的不多，不过计网内容算是比较完美的达成了，就是昨天身体不大舒服，不然熬一下基本上任务就完成了。这种每周都有任务的感觉还是蛮爽的。然后其实还是很喜欢这种每天都有一定的任务量的感觉，这样的话完成之后内心也会收获一份成就感。&lt;/p&gt;
&lt;p&gt;CS61A的进度不算很快，也</summary>
      
    
    
    
    <category term="大二下" scheme="https://primeluoqiu.github.io/categories/%E5%A4%A7%E4%BA%8C%E4%B8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>哈希表</title>
    <link href="https://primeluoqiu.github.io/2024/04/01/Algorithm/hashtable/"/>
    <id>https://primeluoqiu.github.io/2024/04/01/Algorithm/hashtable/</id>
    <published>2024-04-01T13:51:04.389Z</published>
    <updated>2024-04-01T13:51:37.676Z</updated>
    
    <content type="html"><![CDATA[<h3 id="模拟堆"><a href="#模拟堆" class="headerlink" title="模拟堆"></a>模拟堆</h3><p>接下来看模拟堆，模拟堆比起之前就是多了两个数组，这两个数组属于互为反函数的类型。例如 <code>hp[k] = j</code>那么<code>ph[j] = k</code>，一个是对应着在堆里的下标，另一个对应的是下标对应的值。 那么对应的，在进行交换的时候，就不能只考虑值之间的交换了，就还得考虑数组之间的交换。这个时候，就需要一个全新的函数了</p><p>因为题目中要考虑第k个数，那么就需要两个数组来存储第k个数是什么<br>ph[k]存的是第k个插入的数在堆里的下标是什么,还需要一个hp[k],用来存的是堆的某个点是第几个插入的点。</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap_head</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="built_in">swap</span>(ph[hp[a]], ph[hp[b]]);  </span><br><span class="line">    <span class="built_in">swap</span>(hp[a], hp[b]);  </span><br><span class="line">    <span class="built_in">swap</span>(a, b);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>然后就是把所有的<code>swap</code>函数进行更换为堆里面特有的<code>swap</code>。<br>这个方法不常用，但是djikstra堆优化是常用的，所以要了解一下</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, a, b;</span><br><span class="line"><span class="type">int</span> h[N], cnt, ph[N], hp[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heap_swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">swap</span>(ph[hp[a]], ph[hp[b]]);</span><br><span class="line">    <span class="built_in">swap</span>(hp[a], hp[b]);</span><br><span class="line">    <span class="built_in">swap</span>(h[a], h[b]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = u;</span><br><span class="line">    <span class="keyword">if</span>(u * <span class="number">2</span> &lt;= cnt &amp;&amp; h[u * <span class="number">2</span>] &lt; h[t]) t = u * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(u * <span class="number">2</span> + <span class="number">1</span> &lt;= cnt &amp;&amp; h[u * <span class="number">2</span> + <span class="number">1</span>] &lt; h[t]) t = u * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(u != t)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">heap_swap</span>(u, t);</span><br><span class="line">        <span class="built_in">down</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(u / <span class="number">2</span> &amp;&amp; h[u / <span class="number">2</span>] &gt; h[u])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">heap_swap</span>(u, u / <span class="number">2</span>);</span><br><span class="line">        u &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(n --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> op[<span class="number">10</span>];</span><br><span class="line">        <span class="type">int</span> k, x;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, op);</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(op, <span class="string">&quot;I&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">            cnt ++;</span><br><span class="line">            m ++;</span><br><span class="line">            ph[m] = cnt, hp[cnt] = m;</span><br><span class="line">            h[cnt] = x;</span><br><span class="line">            <span class="built_in">up</span>(cnt);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(op, <span class="string">&quot;PM&quot;</span>)) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, h[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(op, <span class="string">&quot;DM&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">heap_swap</span>(<span class="number">1</span>, cnt);</span><br><span class="line">            cnt --;</span><br><span class="line">            <span class="built_in">down</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(op, <span class="string">&quot;D&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;k);</span><br><span class="line">            k = ph[k];</span><br><span class="line">            <span class="built_in">heap_swap</span>(k, cnt);</span><br><span class="line">            cnt --;</span><br><span class="line">            <span class="built_in">down</span>(k), <span class="built_in">up</span>(k);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;k, &amp;x);</span><br><span class="line">            k = ph[k], h[k] = x;</span><br><span class="line">            <span class="built_in">down</span>(k), <span class="built_in">up</span>(k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><p>哈希表实际上就是把一个很大范围的数据结构映射成为一个很小的数据范围的东西。举例来说，比如说想把从0-10的9次方这些数映射到从0到10的五次方左右的一些数。</p><p>比如现在有一批数的范围是-10九次方到+10的九次方，然后通过一个哈希函数把它们放进一个很小的(10的五次方)的范围之内。</p><p>哈希函数的一些问题，例如：</p><ol><li><p>哈希函数一般怎么写：就是直接模一个数，例如可以直接模10^5。</p></li><li><p>冲突定义域比较大，映射的结果比较小，那么必然会产生冲突，把两个不一样的数映射到同一个数。按照处理冲突的方式分为开放寻址法和拉链法。</p></li></ol><h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><h3 id="开放寻址法"><a href="#开放寻址法" class="headerlink" title="开放寻址法"></a>开放寻址法</h3><p>通俗来讲的话，也叫蹲坑法，什么意思呢，就是说，我们只需要一个数组就可以了，但是这个数组的大小一般要开到题目范围的2-3倍，然后就像大家上厕所一样，当一个坑位被占了的时候，只能去找下一个坑位，然后下一个坑位被占了再找下一个，也就意味着说，我们先通过函数来寻找到k，但是如果那个k被占用了的话，那么就去k+1，如果k+1被占用了，就去k+2…</p><p>然后这个方法主要就是find函数的实现，然后插入的话，就是通过find找到对应的位置，然后把x放进去就可以了，而查找的话就是如果对应的位置不是空的，那么就是有的，不然就是没有。删除其实也可以看做另外一种形式的查找，因为并不是真正的删除，而是对那个点做一个标记</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e6</span> + <span class="number">3</span>, null = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> h[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k = (x % N + N) % N;</span><br><span class="line">    <span class="keyword">while</span>(h[k] != null &amp;&amp; h[k] != x)</span><br><span class="line">    &#123;</span><br><span class="line">        k ++;</span><br><span class="line">        <span class="keyword">if</span>(k == N) k = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(h));</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(n --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d&quot;</span>, op, &amp;x);</span><br><span class="line">        <span class="type">int</span> k = <span class="built_in">find</span>(x);</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">&#x27;I&#x27;</span>) h[k] = x;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(h[k] != null)</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h3><p>简单来讲，就是说，先开出来一个空间，然后例如我们把h(11)映射到了3，h(23)也映射到了3，这个时候，我们就在3的下面拉一个线，类似拉链一样。多一个点就多一个线。然后一般哈希表只会存在两种操作，分别是添加和查找，添加很简单，只需要通过对应的哈希函数找到它的位置，然后添加一条拉链就可以了，查找的话，就是先看出来这个数值哈希完之后是什么，如果是某个点，然后顺着那个点去查找是不是有那个值。一般不会有删除操作的，就算有，也不是真的把那个数值删了，而是给那个点打个标记，例如布尔变量，然后就删除掉了。</p><p>这里要注意一个点，我们的哈希函数模的那个值最好是一个质数，而且距离2的多少次方比较远，这样能够保证冲突的概率是最小的。</p><p>接下来，看一下我们拉链法的模板</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> h[N], e[N], ne[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k = (x % N + N) % N;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    ne[idx] = h[k];</span><br><span class="line">    h[k] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k = (x % N + N) % N;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[k]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(e[i] == x)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="built_in">sizeof</span>(h));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(n --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d&quot;</span>, op, &amp;x);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">&#x27;I&#x27;</span>) <span class="built_in">insert</span>(x);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(x)) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="字符串哈希方式"><a href="#字符串哈希方式" class="headerlink" title="字符串哈希方式"></a>字符串哈希方式</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;模拟堆&quot;&gt;&lt;a href=&quot;#模拟堆&quot; class=&quot;headerlink&quot; title=&quot;模拟堆&quot;&gt;&lt;/a&gt;模拟堆&lt;/h3&gt;&lt;p&gt;接下来看模拟堆，模拟堆比起之前就是多了两个数组，这两个数组属于互为反函数的类型。例如 &lt;code&gt;hp[k] = j&lt;/code&gt;那</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://primeluoqiu.github.io/categories/Algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>2.2 Web &amp; HTTP</title>
    <link href="https://primeluoqiu.github.io/2024/04/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.2/"/>
    <id>https://primeluoqiu.github.io/2024/04/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.2/</id>
    <published>2024-04-01T09:17:42.879Z</published>
    <updated>2024-04-01T11:08:04.359Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/04/01/2rzwqWwz.jpg"                      alt="37.jpg"                ><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/04/01/B3XokmUT.jpg"                      alt="38.jpg"                ><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/04/01/40radGgU.jpg"                      alt="39.jpg"                ><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/04/01/CDSUceBp.jpg"                      alt="40.jpg"                ><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/04/01/nSBajZgM.jpg"                      alt="41.jpg"                ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;https://img2.imgtp.com</summary>
      
    
    
    
    <category term="计网" scheme="https://primeluoqiu.github.io/categories/%E8%AE%A1%E7%BD%91/"/>
    
    
  </entry>
  
  <entry>
    <title>0401日记</title>
    <link href="https://primeluoqiu.github.io/2024/04/01/Dairy/0401/"/>
    <id>https://primeluoqiu.github.io/2024/04/01/Dairy/0401/</id>
    <published>2024-04-01T09:17:30.561Z</published>
    <updated>2024-04-01T15:10:33.935Z</updated>
    
    <content type="html"><![CDATA[<p>今天到目前为止似乎有一点点恢复，但是嗓子还是时不时的痛一会，早上花了110块钱报了软考，网络工程师，得等到蓝桥杯结束之后再看情况准备这个了。不过好在今天状态还行，学习的内容也不算很多。不过感觉也还好，该学习的时候学习，该放松的时候就好好放松一下。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天到目前为止似乎有一点点恢复，但是嗓子还是时不时的痛一会，早上花了110块钱报了软考，网络工程师，得等到蓝桥杯结束之后再看情况准备这个了。不过好在今天状态还行，学习的内容也不算很多。不过感觉也还好，该学习的时候学习，该放松的时候就好好放松一下。&lt;/p&gt;
</summary>
      
    
    
    
    <category term="Dairy" scheme="https://primeluoqiu.github.io/categories/Dairy/"/>
    
    
  </entry>
  
  <entry>
    <title>3月31号日记</title>
    <link href="https://primeluoqiu.github.io/2024/03/31/Dairy/0331/"/>
    <id>https://primeluoqiu.github.io/2024/03/31/Dairy/0331/</id>
    <published>2024-03-31T15:27:26.331Z</published>
    <updated>2024-03-31T15:36:28.667Z</updated>
    
    <content type="html"><![CDATA[<pre><code>今天身体不大舒服，早上起来之后就直接嗓子痛，很难受，然后晚上的话嗓子似乎好了一些，但是头有点晕，然后右胳膊也不是很舒服，一种酸痛的感觉。然后想学感觉脑子也跟不上了，这周任务还是没有完成，身体还是要好好养着的，不能太累，也不能太慵懒。也许是最近喝水不太多，也许是这两天做裁判有点累，今天还没休息的过来。然后就出去玩了一天，下午还洗了个澡。应该问题不大，下周有一个清明节，除了复习蓝桥杯之外应该还可以多学一点别的东西，任务应该是可以完成了。本周真的蛮可惜的，就差半个小时就把这周的任务做完了。但是身体实在是扛不住了，早点休息为好。剩下的下周任务的明天早上看看能不能早点起来写吧。还是要加油。希望的曙光就在眼前了。加油！五一还是想回家把驾照考了。然后就没什么事情了，主要是考完之后就没什么事情了，还可以早过实习期。只要从学校跑出去，学校的事情就不管了，虽然不一定。但是还是要试试。</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;pre&gt;&lt;code&gt;今天身体不大舒服，早上起来之后就直接嗓子痛，很难受，然后晚上的话嗓子似乎好了一些，但是头有点晕，然后右胳膊也不是很舒服，一种酸痛的感觉。然后想学感觉脑子也跟不上了，这周任务还是没有完成，身体还是要好好养着的，不能太累，也不能太慵懒。也许是最近喝水不太多，也许</summary>
      
    
    
    
    <category term="Dairy" scheme="https://primeluoqiu.github.io/categories/Dairy/"/>
    
    
  </entry>
  
  <entry>
    <title>3月30号日记</title>
    <link href="https://primeluoqiu.github.io/2024/03/30/Dairy/0330/"/>
    <id>https://primeluoqiu.github.io/2024/03/30/Dairy/0330/</id>
    <published>2024-03-30T13:22:10.277Z</published>
    <updated>2024-03-30T13:47:23.634Z</updated>
    
    <content type="html"><![CDATA[<p>今天的志愿工作做的还不错，就是上午第一次给他们做评分的时候因为紧张，还有一些没注意过得地方出了不少差错。有两个组因为因为不小心的失误都少扣了十分，然后还好有一组没什么影响，但是有一组还是不得不扣了，不然的话名词会发生变化。这样的话就没有公平性可言了。不过这一上午的裁判工作还算是比较完善，没出什么大的差错，也没有遇见那种喜欢叨叨的同学和家长以及指导老师，大家都很不错，不过比起高中那边，听说有很多都在抬杠，包括指导老师。学生抬杠就算了，指导老师也跟着一起抬，这就没啥意思了。为人师长，自己不好好看看规则，然后就带着学生来比赛了。还带着学生一起抬杠，咱这也不是抬杠大赛，不是你声音大就可以赢了。以至于最后初中这边的比赛结束之后，高中那边的还没结束。然后就到了中午吃饭，这个饭啊，emm，只能说和昨天是天壤之别了。不过好歹也算是对付了两口，不至于大下午空着肚子执裁。下午的小学生组确实相对来说轻松一点，不过中间还是出现了一点小插曲，例如有一个小同学还是比较心急的想要碰一下，但是我们提醒到位，再加上也就是轻微碰了一下器材，也没有对实验造成什么实质上的印象，于是我们就没有让他重置了。当时在场的所有人都没有吭声，一直到结束之后换了下一组那个男人才开始说起来，这会已经没有时间再处理了。那个男人还在那里口若悬河的说说说。我们和主裁说了很多话，就是不听。对此只有一句话，就是菜就多练，输不起就别玩。换做是他的学生他是不是就不会吭声了，这个时候如果有别人像他一样，他是会觉得那个人不太行呢，还是怎么说呢？这就不好评价了。不过执裁的路途中还是学到了很多的。包括如何执裁，如何让同学和老师们信服执裁过程而没有意义，面对小朋友的时候该凶一点就要凶一点，该温柔的时候就应该温柔一点。都要有个度，例如，像下午小学场的小孩子们总是完美的结束之后不知道喊停，为了公平起见，我都是按照大概接触的时间给他们算的，这样也是一种相对来说的公平。然后比赛的时候有一次我就比较严声的跟他们说，我说你们不说，我给你们按什么时间算呢，是按照你喊的时间呢，还是按照结束的时间呢，结束之后一定要自己喊停。有的孩子喊早了，我还是一样的，我说你喊早了我应该怎么给你算呢，是按照早一点的算呢，还是等到了终点之后再算呢。希望他们可以记得住这次经历，并在以后的比赛中不要再犯这样的错误了。</p><p>不过有一说一今天是真的累，已经没有任何心力再学下去了，目前的任务其实也就是计网的2.2，不过这周的任务完成情况还得看明天结束这一周之后的任务状态。也不知道明天早上会睡到几点，因为今天实在是太累了，从早上执裁到下午。真的是做了一天的事情，走来走去，还要耗费精力去做这些事情，一不留神可能就漏掉了一个问题，然后就容易导致一些差错。下午的过程明显相对来说要顺利很多。晚上吃完饭回新工科之后，可能身体还好，但是思想是真的懈怠了，一点力气都没有了，或许这就是耗费了一天精力之后的感受吧。不过这一趟的收获还真的是蛮多的。而且在上午制裁的过程中，还无意中注意到了有一个正在做介绍的好像是体育馆的老师还是科技馆的老师，给那些领导讲解的时候，那个领导说他讲的还不错，然后问他在哪工作，那个人就说在科技馆这边工作，然后领导说他干得还不错，问之前怎么没见过他。他说好像是今天要接待领导，然后专门好好收拾了一下自己。看来这哥们的仕途应该要稍微往上一点点了，多少也是给领导留下来了一个好印象，没准哪天之后就会因为一些原因被提拔起来。哈哈哈哈</p><p>这两天嗓子似乎不大舒服，可能是扁桃体有点发炎，得多喝点水了。好好休息一下，也比较累，少熬会夜。加油吧</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天的志愿工作做的还不错，就是上午第一次给他们做评分的时候因为紧张，还有一些没注意过得地方出了不少差错。有两个组因为因为不小心的失误都少扣了十分，然后还好有一组没什么影响，但是有一组还是不得不扣了，不然的话名词会发生变化。这样的话就没有公平性可言了。不过这一上午的裁判工作还</summary>
      
    
    
    
    <category term="Dairy" scheme="https://primeluoqiu.github.io/categories/Dairy/"/>
    
    
  </entry>
  
  <entry>
    <title>1.5 控制</title>
    <link href="https://primeluoqiu.github.io/2024/03/29/ClassesFormUCBerkely/CS61A/1.5%E6%8E%A7%E5%88%B6/"/>
    <id>https://primeluoqiu.github.io/2024/03/29/ClassesFormUCBerkely/CS61A/1.5%E6%8E%A7%E5%88%B6/</id>
    <published>2024-03-29T13:50:16.549Z</published>
    <updated>2024-03-29T13:50:53.432Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-5-控制"><a href="#1-5-控制" class="headerlink" title="1.5 控制"></a>1.5 控制</h3><p>现在可以定义的函数能力十分有限，因为还没有引入一种方法来进行比较，并根据比较的结果执行不同的操作。控制语句将赋予我们这种能力，就是根据逻辑比较的结果来控制执行流程的语句。</p><p>语句与我们目前研究过的表达式有着根本的不同，<strong>他们没有值</strong>。执行一个控制语句决定了解释器接下来应该做什么，而不是计算某些东西</p><hr><h3 id="1-5-1-语句"><a href="#1-5-1-语句" class="headerlink" title="1.5.1 语句"></a>1.5.1 语句</h3><p>到目前为止，虽然思考的是如何计算表达式，但我们已经见过了三种语句：赋值(assignment)、<code>def</code>和<code>return</code>语句。尽管这些Python代码都包含表达式作为他们的一部分，但它们本身并不是表达式。</p><p>语句不会被求解，而会被执行。每个语句都描述了对解释器状态的一些更改，并且执行语句就会应用该更改。正如在<code>return</code>和赋值语句中看到的那样，执行语句可能涉及求解其包含的子表达式。</p><p>表达式也可以作为语句执行，在这种情况下，它们会被求值，但是它们的值会被丢弃。执行纯函数没有效果，但执行非纯函数会因为调用函数而产生效果。</p><p>思考一下，例如:</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">square</span>(<span class="params">x</span>):</span><br><span class="line">    mul(x, x)</span><br></pre></td></tr></table></figure></div><p>这个例子是有效的Python代码，但是不能达到预期。表达式本身是一个有效的语句，但语句的效果是调用<code>mul</code>函数，然后把结果丢弃。如果想对表达式的结果做什么，需要用赋值语句存储它或用<code>return</code>语句返回它：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">square</span>(<span class="params">x</span>)</span><br><span class="line">    <span class="keyword">return</span> mul(x, x)</span><br></pre></td></tr></table></figure></div><p>有时，在调用<code>print</code>等非纯函数时，拥有一个主体为表达式的函数确实有意义。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">print_square</span>(<span class="params">x</span>)</span><br><span class="line">    <span class="built_in">print</span>(square(x))</span><br></pre></td></tr></table></figure></div><p>在最高层级上，Python解释器的工作是执行由语句组成的程序。然而，很多有趣的计算工作都来自对表达式的求值。语句用来管理程序中不同表达式之间的关系，以及它们产生的结果。</p><hr><h3 id="1-5-2-复合语句"><a href="#1-5-2-复合语句" class="headerlink" title="1.5.2 复合语句"></a>1.5.2 复合语句</h3><p>通常，Python代码是一系列语句。简单语句是不以冒号结尾的单行，而由其他语句(简单语句和复合语句)组成被称为复合语句。复合语句通常跨越多行，以单行头部(header)开始，并以冒号结尾，其中冒号标识语句的类型。头部和缩进的句体(suite)一起称为子句。复合语句由一个或多个子句组成：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;header&gt;:</span><br><span class="line">    &lt;statement&gt;</span><br><span class="line">    &lt;statement&gt;</span><br><span class="line">    ...</span><br><span class="line">&lt;separating header&gt;</span><br><span class="line">    &lt;statement&gt;</span><br><span class="line">    &lt;statement&gt;</span><br><span class="line">    ...</span><br><span class="line">...</span><br></pre></td></tr></table></figure></div><p>我们可以用这些术语来理解我们之前介绍过的语句。</p><ul><li>表达式、返回语句和赋值语句都是简单语句。</li><li><code>def</code>语句是复合语句，<code>def</code>头后面的句体定义了函数体。<br>对每类header 都有专门的求值规则来规定其何时执行以及是否执行其句体中的语句。我们说”the header controls its suite”, 例如，在<code>def</code>语句中，<code>return</code>表达式不会立即求值，而是存储起来供以后调用该函数时使用。</li></ul><p>我们现在也可以理解多行程序了。</p><ul><li>要执行一系列语句，会先执行第一个语句，如果不重定向控制，那么就继续执行其余部分<br>这个定义解释了递归定义序列(sequence)的基本结构：一个序列可以分解成它的第一个元素和其余元素。语句序列的”其余部分”本身也是语句序列!因此，我们可以递归地应用这个执行规则。这就是将递归视为数据结构的观点</li></ul><p>此规则的重要结论时语句会按顺序执行，但由于重定向控制(redirected control),后面的语句可能永远不会被执行到。</p><p>缩进必须要缩进相同的量。</p><hr><h3 id="1-5-3-定义函数II-局部赋值"><a href="#1-5-3-定义函数II-局部赋值" class="headerlink" title="1.5.3 定义函数II:局部赋值"></a>1.5.3 定义函数II:局部赋值</h3><p>函数的主体不仅仅是包含单个返回语句的<code>return</code>组成，事实上，还可以定义超出单个表达式的一系列操作。</p><p>每当用户定义的函数被调用时，其具体中的子句序列将会在局部环境中执行-&gt;该环境通过调用函数创建的局部帧开始。<code>return</code>语句会重定向控制：每当执行一个<code>return</code>语句时，函数应用程序就会终止，<code>return</code>表达式的值会被作为被调用函数的返回值。</p><p>赋值语句可以出现在函数体中，例如</p><div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">percent_difference</span>(<span class="params">x, y</span>):</span><br><span class="line">    difference = <span class="built_in">abs</span>(x - y)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">100</span> * difference / x</span><br><span class="line">result = percent_difference(<span class="number">40</span>, <span class="number">50</span>)</span><br></pre></td></tr></table></figure></div><p>这个函数利用了两步计算，首先计算两个数的差的绝对值，然后求出它与第一个数的百分比并返回</p><p>赋值语句的作用是将名称和当前环境中的第一帧的值绑定。因此，函数体内的赋值语句不会影响全局帧。”函数只能操纵其局部帧”是创建模块化程序的关键，而在模块化程序中，纯函数仅通过它们接收和返回的值与外界交互。</p><p>当然，上述函数也可以只用一条赋值语句实现，但是返回表达式会更复杂</p><p><code>return 100 * abs(x - y)</code></p><p>到目前为止，局部赋值并没有增强函数定义的表达能力，而当它与其他控制语句结合时，就会增强。此外，局部赋值在”通过中间量赋名来解释复杂表达式的含义”方面也起着至关重要的作用。</p><hr><h3 id="1-5-4-条件语句"><a href="#1-5-4-条件语句" class="headerlink" title="1.5.4 条件语句"></a>1.5.4 条件语句</h3><p>Python有一个用于计算绝对值的内置函数。</p><div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">abs</span>(-<span class="number">2</span>)</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure></div><p>我们希望可以实现这样一个函数。但是我们想清楚我们要表达的是，如果x为正，就为正，为负取反。那么可以用条件语句来表示</p><div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">absolute_value</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">if</span>(x &gt;= <span class="number">0</span>):</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">return</span> -x</span><br><span class="line">result = absolute_value(x)    </span><br></pre></td></tr></table></figure></div><p>这个<code>absolute_value</code>函数的实现提出了几个重要问题：</p><p>条件语句(Condition statement):Python中的条件语句是由一系列头部和句体组成的：必须的<code>if</code>子句、可选的<code>elif</code>子句序列，最后是可选的<code>else</code>子句：</p><div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> &lt;expression&gt;:</span><br><span class="line">    &lt;suite&gt;</span><br><span class="line"><span class="keyword">elif</span> &lt;expression&gt;:</span><br><span class="line">    &lt;suite&gt;</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    &lt;suite&gt;</span><br></pre></td></tr></table></figure></div><p>执行条件语句的时候，每个子句都会按顺序被考虑。执行条件子句的计算过程如下。</p><ol><li>求解头部的表达式</li><li>如果它是真值，则执行该句体。然后跳过条件语句中的所有后续子句。</li></ol><p>如果达到<code>else</code>语句(仅当所有<code>if</code>和<code>elif</code>表达式的计算结果为假值时才会发生),则执行其句体。</p><p>布尔上下文(Boolean contexts)：上面，执行过程提到了”假值 a false value”和”真值 a true value”。<strong>条件块头部语句内的表达式</strong>被称为布尔上下文：它们值的真假对控制流很重要，另外，它们的值不会被赋值或返回。Python包含多个假值，包括**0, <code>None</code>, 和布尔值<code>false</code>**，所有其他数字都是真值。</p><p>布尔值(Boolean Value)：Python中有两个布尔值:<code>True</code>和<code>False</code>。布尔值表示逻辑表达式中的真值。内置的比较运算符&gt;,&lt;,&gt;&#x3D;,&lt;&#x3D;,&#x3D;&#x3D;, !&#x3D;会返回这些值。</p><div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">4</span> &gt; <span class="number">2</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">5</span> &gt;= <span class="number">5</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure></div><p>第二个例子在<code>operator</code>模块中的<code>ge</code></p><div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">0</span> == -<span class="number">0</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure></div><p>这个对应的是<code>operator</code>中的<code>eq</code>。Python会区分赋值和相等比较符号，许多语言都是这样</p><p>布尔运算符(Boolean operator):Python中还内置了三个基本的逻辑运算符：</p><div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">True</span> <span class="keyword">and</span> <span class="literal">False</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">True</span> <span class="keyword">or</span> <span class="literal">False</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">not</span> <span class="literal">False</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure></div><p>逻辑表达式具有相应的求值过程。而这些过程利用了这样的一个理论-&gt;有时，逻辑表达式的真值可以在不对其所有子表达式求值的情况下确定，这一特性称为短路，例如(or)</p><hr><p>求解表达式 <code>&lt;left&gt; and &lt;right&gt;</code> 的步骤如下：</p><ol><li>求解子表达式  <code>&lt;left&gt;</code>。</li><li>如果左边的结果为假值 v，则表达式的计算结果就是 v。</li><li>否则，表达式的计算结果为子表达式 <code>&lt;right&gt;</code> 的值。</li></ol><hr><p>求解表达式  <code>&lt;left&gt; or &lt;right&gt;</code> 的步骤如下：</p><ol><li>求解子表达式  <code>&lt;left&gt;</code>。</li><li>如果左边的结果为真值 v，则表达式的计算结果就是 v。</li><li>否则，表达式的计算结果为子表达式 <code>&lt;right&gt;</code> 的值。</li></ol><hr><p>求解表达式  <code>not &lt;exp&gt;</code> 的步骤如下：</p><ol><li>求解  <code>&lt;exp&gt;</code>，如果结果为假值，则值为 <code>True</code> ，否则为 <code>False</code>。</li></ol><hr><p>这些值、规则和运算符为我们提供了一种组合比较结果的方法。<strong>执行比较并返回布尔值的函数通常以 <code>is</code> 开头，后面不跟下划线</strong>（例如 <code>isfinite, isdigit, isinstance</code> 等）。</p><hr><h3 id="1-5-5-迭代"><a href="#1-5-5-迭代" class="headerlink" title="1.5.5 迭代"></a>1.5.5 迭代</h3><p>除了选择要执行的语句外，控制语句还用于重复。如果我们编写的每一行代码只执行一次，那么编程将是一项非常低效的工作只有通过重复执行语句，我们才能释放计算机的全部潜力。我们之前已经见过了一种重复形式:一种函数只用定义一次，就可以被多次调用。迭代控制(Iterative control)结构是另一种多次执行相同语句的机制。</p><p>思考一下之前学过的斐波那契数列，其中每个数都是前两个数的和。<br>$$<br>0, 1, 1, 2, 3, 5, 8, 13, 21 …<br>$$<br>每个值都是通过重复应用<code>sum-previous-two</code>的规则构建的，第一个和第二个值固定为0和1.</p><p>我们可以使用<code>while</code>语句来枚举n项斐波那契数列。我们需要跟踪已经创建了多少个值(k),和第k个值(<code>curr</code>)及其前身(<code>pred</code>)。单步执行此函数并观察斐波那契数列如何一个一个的演化，并绑定到<code>curr</code></p><div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fib</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Compute the nth Fibonacci number, for n &gt;= 2</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    pred, curr = <span class="number">0</span>, <span class="number">1</span> <span class="comment">#Fibonacci numbers 1 and 2</span></span><br><span class="line">    k = <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> k &lt; n:</span><br><span class="line">        pred, curr = curr, pred + curr</span><br><span class="line">        k = k + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> curr</span><br><span class="line">    result = fib(<span class="number">8</span>)</span><br></pre></td></tr></table></figure></div><p>请记住，单行赋值语句可以用逗号分隔多个名称和值同时赋值。该行：</p><p><code>pred, curr = curr, pred + curr</code></p><p>在更新左侧的绑定之前求出所有 <code>=</code> 右侧的内容 → 这种事件顺序对于此函数的正确性至关重要。</p><p><code>while</code> 子句包含一个头部表达式，后跟一个句体：</p><div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> &lt;expression&gt;:</span><br><span class="line">    &lt;suite&gt;</span><br></pre></td></tr></table></figure></div><p>要执行 <code>while</code> 子句：</p><ol><li>求解头部的表达式。</li><li>如果是真值，则执行后面的句体，然后返回第 1 步。</li></ol><p>在第 2 步中，<code>while</code> 子句的整个句体在再次计算头部表达式之前执行。</p><p>为了防止 <code>while</code> 子句的句体无限期地执行，句体应该总是在每次循环中更改一些绑定。</p><p>不会终止的 <code>while</code> 语句被称为无限循环（infinite loop）。按 <code>&lt;Control&gt;-C</code> 可以强制 Python 停止循环。</p><h3 id="1-5-6-测试"><a href="#1-5-6-测试" class="headerlink" title="1.5.6 测试"></a>1.5.6 测试</h3><p>测试一个函数就是去验证函数的行为是否符合预期。</p><p>测试是一种系统地执行验证的机制。它通常采用另一个函数的形式，其中包含对一个或多个对被测试函数的调用样例，然后根据预期结果验证其返回值。与大多数旨在通用的函数不同，测试需要选择特定参数值，并使用它们验证函数调用。测试也可用作文档：去演示如何调用函数，以及如何选取合适的参数值。</p><p>断言（Assertions）：程序员使用 <code>assert</code> 语句来验证是否符合预期，例如验证被测试函数的输出。<code>assert</code> 语句在布尔上下文中有一个表达式，后面是一个带引号的文本行（单引号或双引号都可以，但要保持一致），如果表达式的计算结果为假值，则显示该行。</p><div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">assert</span> fib(<span class="number">8</span>) == <span class="number">13</span>, <span class="string">&#x27;第八个斐波那契数应该是 13&#x27;</span></span><br></pre></td></tr></table></figure></div><p>当被断言的表达式的计算结果为真值时，执行断言语句无效。而当它是假值时，<code>assert</code> 会导致错误，使程序停止执行。</p><p>fib 的测试函数应该测试几个参数，包括 n 的极限值。</p><div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">fib_test</span>():</span><br><span class="line">        <span class="keyword">assert</span> fib(<span class="number">2</span>) == <span class="number">1</span>, <span class="string">&#x27;第二个斐波那契数应该是 1&#x27;</span></span><br><span class="line">        <span class="keyword">assert</span> fib(<span class="number">3</span>) == <span class="number">1</span>, <span class="string">&#x27;第三个斐波那契数应该是 1&#x27;</span></span><br><span class="line">        <span class="keyword">assert</span> fib(<span class="number">50</span>) == <span class="number">7778742049</span>, <span class="string">&#x27;在第五十个斐波那契数发生 Error&#x27;</span></span><br></pre></td></tr></table></figure></div><p>当在文件中而不是直接在解释器中编写 Python 时，测试通常是在同一个文件或带有后缀 <code>_test.py</code> 的相邻文件中编写的。</p><p>文档测试（Doctests）：Python 提供了一种方便的方法，可以将简单的测试直接放在函数的文档字符串中。文档字符串的第一行应该包含函数的单行描述，接着是一个空行，下面可能是参数和函数意图的详细描述。此外，文档字符串可能包含调用该函数的交互式会话示例：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">sum_naturals</span>(<span class="params">n</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;返回前 n 个自然数的和。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; sum_naturals(10)</span></span><br><span class="line"><span class="string">        55</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; sum_naturals(100)</span></span><br><span class="line"><span class="string">        5050</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        total, k = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> k &lt;= n:</span><br><span class="line">            total, k = total + k, k + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> total</span><br></pre></td></tr></table></figure></div><p>然后，可以通过 <a class="link"   href="http://docs.python.org/py3k/library/doctest.html" >doctest 模块 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 来验证交互，如下。</p><div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> doctest <span class="keyword">import</span> testmod</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>testmod()</span><br><span class="line">TestResults(failed=<span class="number">0</span>, attempted=<span class="number">2</span>)</span><br></pre></td></tr></table></figure></div><p>如果仅想验证单个函数的 doctest 交互，我们可以使用名为 <code>run_docstring_examples</code> 的 <code>doctest</code> 函数。不幸的是，这个函数调用起来有点复杂。第一个参数是要测试的函数；第二个参数应该始终是表达式 <code>globals()</code> 的结果，这是一个用于返回全局环境的内置函数；第三个参数 <code>True</code> 表示我们想要“详细”输出：所有测试运行的目录。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> doctest <span class="keyword">import</span> run_docstring_examples</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>run_docstring_examples(sum_naturals, <span class="built_in">globals</span>(), <span class="literal">True</span>)</span><br><span class="line">Finding tests <span class="keyword">in</span> NoName</span><br><span class="line">Trying:</span><br><span class="line">    sum_naturals(<span class="number">10</span>)</span><br><span class="line">Expecting:</span><br><span class="line">    <span class="number">55</span></span><br><span class="line">ok</span><br><span class="line">Trying:</span><br><span class="line">    sum_naturals(<span class="number">100</span>)</span><br><span class="line">Expecting:</span><br><span class="line">    <span class="number">5050</span></span><br><span class="line">ok</span><br></pre></td></tr></table></figure></div><p>当函数的返回值与预期结果不匹配时，<code>run_docstring_examples</code> 函数会将此问题报告为测试失败。</p><p>当你在文件中编写 Python 时，可以通过使用 doctest 命令行选项启动 Python 来运行文件中的所有 doctest：</p><div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -m doctest &lt;python_source_file&gt;</span><br></pre></td></tr></table></figure></div><p>有效测试的关键是在实现新功能后立即编写（并运行）测试。在实现之前编写一些测试也是一种很好的做法，以便在你的脑海中有一些示例输入和输出。调用单个函数的测试称为单元测试（unit test）。详尽的单元测试是良好程序设计的标志。</p><p>总结来看，本节的主要内容是对于函数的控制，函数不仅包含了能够返回值的<code>return</code>语句，还可以对函数进行多种复杂的语句，例如复合语句。然后就是有关局部赋值，也就是在函数内部定义一个变量用来进行赋值的操作。接下来就是有关条件的<code>if-else</code>语句和布尔值，在这里，要对逻辑表达式的求值过程中的短路有所了解。接下来就是函数内部的迭代，这里利用到了<code>while</code>语句，通过<code>while</code>语句来更新斐波那契数列的<code>pred</code>和<code>curr</code>，最后就是对于函数的测试，我们要看我们写的函数是不是满足我们的心理预期。测试的方式有很多种，包括但不限于断言和文档测试。最后，我们了解到有效测试的关键是在实现新功能后立即编写(并运行)测试。在实验之前编写一些测试也是一种很好的做法。详尽的单元测试是良好程序设计的标志。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-5-控制&quot;&gt;&lt;a href=&quot;#1-5-控制&quot; class=&quot;headerlink&quot; title=&quot;1.5 控制&quot;&gt;&lt;/a&gt;1.5 控制&lt;/h3&gt;&lt;p&gt;现在可以定义的函数能力十分有限，因为还没有引入一种方法来进行比较，并根据比较的结果执行不同的操作。控制语句将</summary>
      
    
    
    
    <category term="CS61A" scheme="https://primeluoqiu.github.io/categories/CS61A/"/>
    
    
  </entry>
  
</feed>
