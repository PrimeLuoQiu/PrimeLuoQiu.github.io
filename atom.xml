<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>秋过冬漫长</title>
  
  <subtitle>没有比脚更长的路,走过去就好了</subtitle>
  <link href="https://primeluoqiu.github.io/atom.xml" rel="self"/>
  
  <link href="https://primeluoqiu.github.io/"/>
  <updated>2024-04-01T13:56:12.641Z</updated>
  <id>https://primeluoqiu.github.io/</id>
  
  <author>
    <name>LuoQiu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Week4 and Daily Schedule</title>
    <link href="https://primeluoqiu.github.io/2024/04/01/%E6%AF%8F%E5%91%A8%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/Week5/"/>
    <id>https://primeluoqiu.github.io/2024/04/01/%E6%AF%8F%E5%91%A8%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/Week5/</id>
    <published>2024-04-01T13:54:40.572Z</published>
    <updated>2024-04-01T13:56:12.641Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Daily-Schedule"><a href="#Daily-Schedule" class="headerlink" title="Daily Schedule"></a>Daily Schedule</h1><h2 id="Total-Schedule"><a href="#Total-Schedule" class="headerlink" title="Total Schedule"></a>Total Schedule</h2><ol><li>《计算机网络》-郑铨老师的 2.3-2.10(第二章看完)</li><li>CS61A 看完第一章</li><li>每天更新一点算法内容</li></ol><p>每天任务的话，先看周一吧，周一相对来说课不算多，下午有一节毛概，毛概课的话得补半节课的数电笔记和作业</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Daily-Schedule&quot;&gt;&lt;a href=&quot;#Daily-Schedule&quot; class=&quot;headerlink&quot; title=&quot;Daily Schedule&quot;&gt;&lt;/a&gt;Daily Schedule&lt;/h1&gt;&lt;h2 id=&quot;Total-Schedule&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="大二下" scheme="https://primeluoqiu.github.io/categories/%E5%A4%A7%E4%BA%8C%E4%B8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>Week4 总结</title>
    <link href="https://primeluoqiu.github.io/2024/04/01/%E6%AF%8F%E5%91%A8%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/Week4%E6%80%BB%E7%BB%93/"/>
    <id>https://primeluoqiu.github.io/2024/04/01/%E6%AF%8F%E5%91%A8%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/Week4%E6%80%BB%E7%BB%93/</id>
    <published>2024-04-01T13:51:52.141Z</published>
    <updated>2024-04-01T13:54:24.593Z</updated>
    
    <content type="html"><![CDATA[<p>本周内容学习的不多，不过计网内容算是比较完美的达成了，就是昨天身体不大舒服，不然熬一下基本上任务就完成了。这种每周都有任务的感觉还是蛮爽的。然后其实还是很喜欢这种每天都有一定的任务量的感觉，这样的话完成之后内心也会收获一份成就感。</p><p>CS61A的进度不算很快，也不知道是不是学习方法的问题，现在进展速度奇慢，61B也没来得及看，更别提61C和CSAPP了，下周还有蓝桥杯要准备。加油吧，还要再重温一下算法的相关知识。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本周内容学习的不多，不过计网内容算是比较完美的达成了，就是昨天身体不大舒服，不然熬一下基本上任务就完成了。这种每周都有任务的感觉还是蛮爽的。然后其实还是很喜欢这种每天都有一定的任务量的感觉，这样的话完成之后内心也会收获一份成就感。&lt;/p&gt;
&lt;p&gt;CS61A的进度不算很快，也</summary>
      
    
    
    
    <category term="大二下" scheme="https://primeluoqiu.github.io/categories/%E5%A4%A7%E4%BA%8C%E4%B8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>哈希表</title>
    <link href="https://primeluoqiu.github.io/2024/04/01/Algorithm/hashtable/"/>
    <id>https://primeluoqiu.github.io/2024/04/01/Algorithm/hashtable/</id>
    <published>2024-04-01T13:51:04.389Z</published>
    <updated>2024-04-01T13:51:37.676Z</updated>
    
    <content type="html"><![CDATA[<h3 id="模拟堆"><a href="#模拟堆" class="headerlink" title="模拟堆"></a>模拟堆</h3><p>接下来看模拟堆，模拟堆比起之前就是多了两个数组，这两个数组属于互为反函数的类型。例如 <code>hp[k] = j</code>那么<code>ph[j] = k</code>，一个是对应着在堆里的下标，另一个对应的是下标对应的值。 那么对应的，在进行交换的时候，就不能只考虑值之间的交换了，就还得考虑数组之间的交换。这个时候，就需要一个全新的函数了</p><p>因为题目中要考虑第k个数，那么就需要两个数组来存储第k个数是什么<br>ph[k]存的是第k个插入的数在堆里的下标是什么,还需要一个hp[k],用来存的是堆的某个点是第几个插入的点。</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap_head</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="built_in">swap</span>(ph[hp[a]], ph[hp[b]]);  </span><br><span class="line">    <span class="built_in">swap</span>(hp[a], hp[b]);  </span><br><span class="line">    <span class="built_in">swap</span>(a, b);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>然后就是把所有的<code>swap</code>函数进行更换为堆里面特有的<code>swap</code>。<br>这个方法不常用，但是djikstra堆优化是常用的，所以要了解一下</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, a, b;</span><br><span class="line"><span class="type">int</span> h[N], cnt, ph[N], hp[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heap_swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">swap</span>(ph[hp[a]], ph[hp[b]]);</span><br><span class="line">    <span class="built_in">swap</span>(hp[a], hp[b]);</span><br><span class="line">    <span class="built_in">swap</span>(h[a], h[b]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = u;</span><br><span class="line">    <span class="keyword">if</span>(u * <span class="number">2</span> &lt;= cnt &amp;&amp; h[u * <span class="number">2</span>] &lt; h[t]) t = u * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(u * <span class="number">2</span> + <span class="number">1</span> &lt;= cnt &amp;&amp; h[u * <span class="number">2</span> + <span class="number">1</span>] &lt; h[t]) t = u * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(u != t)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">heap_swap</span>(u, t);</span><br><span class="line">        <span class="built_in">down</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(u / <span class="number">2</span> &amp;&amp; h[u / <span class="number">2</span>] &gt; h[u])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">heap_swap</span>(u, u / <span class="number">2</span>);</span><br><span class="line">        u &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(n --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> op[<span class="number">10</span>];</span><br><span class="line">        <span class="type">int</span> k, x;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, op);</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(op, <span class="string">&quot;I&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">            cnt ++;</span><br><span class="line">            m ++;</span><br><span class="line">            ph[m] = cnt, hp[cnt] = m;</span><br><span class="line">            h[cnt] = x;</span><br><span class="line">            <span class="built_in">up</span>(cnt);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(op, <span class="string">&quot;PM&quot;</span>)) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, h[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(op, <span class="string">&quot;DM&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">heap_swap</span>(<span class="number">1</span>, cnt);</span><br><span class="line">            cnt --;</span><br><span class="line">            <span class="built_in">down</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(op, <span class="string">&quot;D&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;k);</span><br><span class="line">            k = ph[k];</span><br><span class="line">            <span class="built_in">heap_swap</span>(k, cnt);</span><br><span class="line">            cnt --;</span><br><span class="line">            <span class="built_in">down</span>(k), <span class="built_in">up</span>(k);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;k, &amp;x);</span><br><span class="line">            k = ph[k], h[k] = x;</span><br><span class="line">            <span class="built_in">down</span>(k), <span class="built_in">up</span>(k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><p>哈希表实际上就是把一个很大范围的数据结构映射成为一个很小的数据范围的东西。举例来说，比如说想把从0-10的9次方这些数映射到从0到10的五次方左右的一些数。</p><p>比如现在有一批数的范围是-10九次方到+10的九次方，然后通过一个哈希函数把它们放进一个很小的(10的五次方)的范围之内。</p><p>哈希函数的一些问题，例如：</p><ol><li><p>哈希函数一般怎么写：就是直接模一个数，例如可以直接模10^5。</p></li><li><p>冲突定义域比较大，映射的结果比较小，那么必然会产生冲突，把两个不一样的数映射到同一个数。按照处理冲突的方式分为开放寻址法和拉链法。</p></li></ol><h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><h3 id="开放寻址法"><a href="#开放寻址法" class="headerlink" title="开放寻址法"></a>开放寻址法</h3><p>通俗来讲的话，也叫蹲坑法，什么意思呢，就是说，我们只需要一个数组就可以了，但是这个数组的大小一般要开到题目范围的2-3倍，然后就像大家上厕所一样，当一个坑位被占了的时候，只能去找下一个坑位，然后下一个坑位被占了再找下一个，也就意味着说，我们先通过函数来寻找到k，但是如果那个k被占用了的话，那么就去k+1，如果k+1被占用了，就去k+2…</p><p>然后这个方法主要就是find函数的实现，然后插入的话，就是通过find找到对应的位置，然后把x放进去就可以了，而查找的话就是如果对应的位置不是空的，那么就是有的，不然就是没有。删除其实也可以看做另外一种形式的查找，因为并不是真正的删除，而是对那个点做一个标记</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e6</span> + <span class="number">3</span>, null = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> h[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k = (x % N + N) % N;</span><br><span class="line">    <span class="keyword">while</span>(h[k] != null &amp;&amp; h[k] != x)</span><br><span class="line">    &#123;</span><br><span class="line">        k ++;</span><br><span class="line">        <span class="keyword">if</span>(k == N) k = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(h));</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(n --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d&quot;</span>, op, &amp;x);</span><br><span class="line">        <span class="type">int</span> k = <span class="built_in">find</span>(x);</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">&#x27;I&#x27;</span>) h[k] = x;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(h[k] != null)</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h3><p>简单来讲，就是说，先开出来一个空间，然后例如我们把h(11)映射到了3，h(23)也映射到了3，这个时候，我们就在3的下面拉一个线，类似拉链一样。多一个点就多一个线。然后一般哈希表只会存在两种操作，分别是添加和查找，添加很简单，只需要通过对应的哈希函数找到它的位置，然后添加一条拉链就可以了，查找的话，就是先看出来这个数值哈希完之后是什么，如果是某个点，然后顺着那个点去查找是不是有那个值。一般不会有删除操作的，就算有，也不是真的把那个数值删了，而是给那个点打个标记，例如布尔变量，然后就删除掉了。</p><p>这里要注意一个点，我们的哈希函数模的那个值最好是一个质数，而且距离2的多少次方比较远，这样能够保证冲突的概率是最小的。</p><p>接下来，看一下我们拉链法的模板</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> h[N], e[N], ne[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k = (x % N + N) % N;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    ne[idx] = h[k];</span><br><span class="line">    h[k] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k = (x % N + N) % N;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[k]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(e[i] == x)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="built_in">sizeof</span>(h));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(n --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d&quot;</span>, op, &amp;x);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">&#x27;I&#x27;</span>) <span class="built_in">insert</span>(x);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(x)) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="字符串哈希方式"><a href="#字符串哈希方式" class="headerlink" title="字符串哈希方式"></a>字符串哈希方式</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;模拟堆&quot;&gt;&lt;a href=&quot;#模拟堆&quot; class=&quot;headerlink&quot; title=&quot;模拟堆&quot;&gt;&lt;/a&gt;模拟堆&lt;/h3&gt;&lt;p&gt;接下来看模拟堆，模拟堆比起之前就是多了两个数组，这两个数组属于互为反函数的类型。例如 &lt;code&gt;hp[k] = j&lt;/code&gt;那</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://primeluoqiu.github.io/categories/Algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>2.2 Web &amp; HTTP</title>
    <link href="https://primeluoqiu.github.io/2024/04/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.2/"/>
    <id>https://primeluoqiu.github.io/2024/04/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.2/</id>
    <published>2024-04-01T09:17:42.879Z</published>
    <updated>2024-04-01T11:08:04.359Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/04/01/2rzwqWwz.jpg"                      alt="37.jpg"                ><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/04/01/B3XokmUT.jpg"                      alt="38.jpg"                ><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/04/01/40radGgU.jpg"                      alt="39.jpg"                ><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/04/01/CDSUceBp.jpg"                      alt="40.jpg"                ><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/04/01/nSBajZgM.jpg"                      alt="41.jpg"                ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;https://img2.imgtp.com</summary>
      
    
    
    
    <category term="计网" scheme="https://primeluoqiu.github.io/categories/%E8%AE%A1%E7%BD%91/"/>
    
    
  </entry>
  
  <entry>
    <title>0401日记</title>
    <link href="https://primeluoqiu.github.io/2024/04/01/Dairy/0401/"/>
    <id>https://primeluoqiu.github.io/2024/04/01/Dairy/0401/</id>
    <published>2024-04-01T09:17:30.561Z</published>
    <updated>2024-04-01T14:49:04.367Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="567e325351e39c480571a2f28ed5178b56ae1af03084703e823bb23b634aaac4">3e2b76b963d92b0fdbf28f4bdea5b924522bc82850b193f40d9db81dd54faafac4b8b936f375c68e5ac264870f6d040735bbb6ed6f402265905cf412a1fbc40f2f7be3d8a5a6540a1c773d661c6351ef0114e43f5786264be473cafd03a825f8f9d88a24ea18e6741faec06d1fc26b5c68f411f85d9d4b913226480661145758f6fadca6a61afcf3824fc16fdba078269f05a231e9d9068f69a8ce5d4517e02ef23a53e7209a93b398b008462492b95758ed2e9bc25ce671d31aaf5af0c197c299a9a5fb7a1076549a16244be962cfa533b29cfa8744bb2e865f32ee22d7af08d5f50dfdb870107df321a48216badf5116e399f90b6870b78e64a569035526de52fbfb2db17384d8029ef25e15c408fdbe19e65fc9fe47ad8052740608f799a8ee7d5dce1fe2949f6340e842259d377e39826c952491874d3d9d47e889bcca96665ae22d87f61dcf0add84a4bd3aaef51bdea53f9028b683b3d967f21a5201dce82ba7b5af1cb7f33ae47262a19eef272e3edb69acb4fab5b1e3c66c3f452dd49bc65c54a640bdf83a7cddb7de06be5bac82d2d317b3afbbbac92202e39efab975210313466f0124e6e920ae9adfa139f044492dfbed09032f7d318993b5057f1c4b637547f0f180badcadb6b4d331438b92cff53eb7073404e02fd555f9ee78784da1414d987dca9792946ad031ea7ba71056cb9052e4f146f566ee578749e651c8bef42651b06f22d42c220254eea521c03536b65eb73e2ed17939615423a39ca902408848f195119e8426f7d21d51882a5fa3cc84f098b0e2ec337d7dd35f961b5de1be9cbb2707d8727959407cec2b01bbf64762ebdbf26b558abf5ff1ea5e391c48433c915a39d2133a091492dfc5f06e0a3b065d34c2e197a7fd23fd97b1ad8688d671e7f11d81680729c20889b1e583db4975173b30c4920e1096672f26ca3ae2f4f90eb72a925882db2fd7e35628184f6e76c6e64c3a6981b3928b036664f434c7f4d6d870fcc67554d830bf84e2b1a1141ab237eac3f24c0f64f0d1b71b1b5855d239005626534855393d1ab33e8c818f7d7a33fba20471ed5275eea1b4f04641fed331e68eb3e88e4e2b643066250a5ef4c4bff8638cb90c53c6f5b34c2bb044efa6b69ba35625f7c175e7d12f3ed32e56c145f5f6d52682bf0588b84d822411993c0ec31ad8c54a06db6e73799f299e9281d4029369b00835850228eb8789ab393c371c89147af5a31201e0e96c15f7c8c10fc0b445cc9258d6e979056f1305542b37bbacb2d37bfd81351a377a860ade271b26a9045cbaa5ea3af07d912bb85eb38b7096db804f1fc044fd7ba1dbbe276a9d15b93bf89c10a39609ac60e57b6c7a38b1744cd763188a23f449047bb6cd1ad4a464ba479da14a5527b5d6d972e294acdc0658e01d5fa9fc617a0ad2dfb0591e843937c983d4cad88d8ff48c610ce61536cac66c103cf478133ab22ff1e5a43a3d05dd583a822d22477327ef81ca08e08666de7560a40ae7be7b5e1a142e6905b0342e8cb7e662198ad5be500a099661d9b01d7ec729957600ede93c0de02eb88d6f2a1a397466511f2b81e695e85bf8682ced4a17f8dfa9c79a33aac5b3d08fcb1063cd627d589ba1ceb7c564d26aca6dac95f8227f0b0c1fc83994db18171d3972d0be696707a54841c2b099684b533580416d281e273305bc7741e1ac1fcad44aeeeaea706f88288fbab71687f58d0d674778d86664f796454e6bfcd2026bf54e08ec79cb611ac45048fc673aa44deef4ac1dad20ac83560853973c872d52879568a079d94cb5911c190f7ee6711fd291079342557d23c4221cc213f9bc917cc6cb4f793cbaeeadb9c23443d69ed4f636192b184c8208b784d360d51873794a23402a14764d8343ead0b108abbc9b9d499a7f172f8bc9f5bdf3b6cc027488decb7465bc7d8200d58bf674f840c2268bd6fd5f096f3c2ba673ef06e08387c658c5494540d0bae7bb2ca2e7027eaf76bfeb30138e4141aa81a9ab3930b54abcd12b51b98b454ece5969ec9c9dbc15cfcb5ecd26adaf446133bd9744a1920657737745d05d6f03e112cc21320cf2a99cf0c975145993f4b8ef970e008fc0cb41df978a7223c820450e81b241cf6d882983c022be16f9279bf968bf8b15dd32b5334aba4d5cba78318fe2d3abe8d9e9245241a22c3754cdc407d70dbb036619d88344c242a811362f01f8ed6c64db7c9925e12d8830a00e0b87009ce1ab922a72afa06ec98ea281da979bdda2b45dd214d1b9869ad1127aa18040b134309708b1b0307eaa36ea0ea2b94570c4695922093baf4c6f43b8c73bf8f03ab64822a051ecee7558d64245a5fc1df6d0f29632a77f52191aef86e1a3e0988d13d039ce060158c537f3133dcd492b4025550c38c5e01e358689a1e94583c057f0fdfd8fb7b27825ea22cd81a2b9cca2b742df2b4fff2320bc707a76dc605139e5b884b5807a9f624bea6c5a01d0a46f1a34d12c308b00fb3753372aec0edd806b2b406c5a176ba480122c930e159370bf0f870b64da3a6d5cf5750e8730d1c99a62d07936acae0b9e696e256c2aefdaaae235e51a2849bb7a46b8616239361e4a0ae76567687484ae23886f490036de53fe9e49c9b81b76a51223978ddeccc0c9e5139039e3113231caec54b99a9e4e9cfbfca29cc6fab590c577cf0f13086f5544de06c8e2717171f7660028669c41aa1370329fc8a139eed00619879d964e81b23b17f1c3fefe3eca2a9b99940e3bd685652da4ba0195461ea1c749f07265a8db1b9a31fdfa6ded288c58f56f6cc5468bc4405d2bc71b862b86ed5df4e091a97793030cc2ca49ece4a5542cc2c0d22797ebd031556f277d49dd2cec8212a06ddb67b484e7ddb4fc5d66840a95a4169e520ad26299ded3409eb830ab938891078b832f4ca07838c2675e72300c7fd575a37803ce7142aa5b25d457ddab6b205247195cf644ae7ffc6f1a5e9f0758ba0505bd4d9fb4e8bf8aab35389f8b3caa118cfcf29d93a3632b35c1f9ac809dd6517fdc78cfa3d0edf15d45849ee7dcb7e526b9985a8bcd5bc0921442e3534558f0ce5867a81d19806be79873aad2ec0a623f914ac4e3d52d6a618196753877a721e0eaa6392f94fda28ae83af7f4f3047b21a0fe57ebf3aeb036b2950259e22d5dbc9d38d9e195b68de060d397cefd89a853ec8394e83174adf9faae4d5e53f4ee9961c3324dc6c76b68cd3ef88e92fbe143c96c57830d3db6ef9335ab9af0c22c358598b339c4278afe321332db37136cbab8d7e1bf8a5b4f137e6d245fa100a4649d6b28e8e61fb405996cf9da1607b864486642c80addd99203b464e1b355219aa147ee227c96a95186698723e7d89a86009bead16b94d579418470e35d87cb91491ca3b1067495a1a08aae8c8edb18d538f12fbc68b2f39a76f15eca482368fa9780dd9738064bbad69e8976803c90558c29ef80969c169770ba8362edc129c888d161e7273f6d42c0788503fc990636c76a69f806c29059e87670c505ec4bd080100c7ef947596773e683ef6a01338c524b642eecfe4e97fe75510b31ffef0a38a3d0fb33d0eb9dab88328ef259e3f5efc0e0a77de109d14bc1669766c72c1ce4cb6e15a84b2a8817f18ed43deeb70f57cc430918caa765e25093189bfb084834c5870e2cb247d948147ac1d1af95ed885dd94e084862c30f13e6f07d71319330d3d2ad88b1049d3b13bfe4ac2e40e5e217b8a31a2184361534f1a5c9fddf8056d7ec5aea235bc48840f52dabf844447af3840ab8aa3a2ba52f1c3519a84f296822a483684bfb028ad1b88a13846844131c5984dd83b830c253e5cd284bb6996def28628600f43855edbd8fea9652bdaab802d053dfc3242a7d7635cc7217ce6cff81a2324296697ebda6f8c16c36bff46d04186c0ab99136f75c6b293b83ac5e905406889677671354df1a2e5851bf43af558149f3f65e28f4f533377a9f661128c10dc47455ddb1e10af28c455ce2828188bb5866574c3821437c1c08af93f7b0970617aa0f0262881af06ca492dca14c47b8a58bf8719f01fbdf4dccde139bfdc2e832152ec93fca469df21028a286235f618b2fc0aaba59c509ed7a6d1d5dd78dc0febdb30ee5aa0fde9dd772e7f219d6d3375d7e79737d8b67fe4c76cca66a05cf1308acb8194a2bc0ebe8afa55d8ce3e044db239ac240a458dda9d8c07a3120c2c255726bbfb084202311ac4f2ce95e036e31600f3822bbfda417c0ac4b9123a2229a45b67be552695826b08edec8ac9660c88af48e3139a8283f97733db4725096a021612e6ee71d5912a522649219583472e0b59aaedf82616452da57ce0a54d18f9c26c50680ae4da2e8e7177dd872bc81f8bdb69e2451bd27af1f4a05084dda901356296e067318511de573ef5ab090962fee490275e801f9168aa47d6c1389fb40d6f6e319569e41afd61f376c7cf764f9fe4c3b2025674bb54d644409547b5f4fae83b9310400756846086665691d9d7333f93afb66c22c88a3b8df4843b85798f3ad7cd1864a0fdd1a17cd0f8d0d812c7405b1bb7bddb40e648a4f1128e6651608053aa0799ee1bf52f7e8ee18dc7159dc74817e6d91c0c7900fd6625e365dd65c61364817d01ed2c7d32e5ddd17c2696ae573a1c6e572683f43405b183bc49b28dfc0de6eb808dc1e1224e0a4abdbee5dddf9bf8fcd66e360c8e855ce6ae3012553b6f488893d5550353f6b17fc2dbe1ccf1406afd263562d9044a05d8e7632a86e9b8e88d3bdc1ba6ed7fc145c3d3661ecde1e097257d195ffab4d73b9873f47280edbd75e5ddaff6613abab94050145cd7a656764baacb012225c70b06b051da56c4a408e5bf89a34ce683fc2f6f2eaf52e1e4cebf49ccbae5fc8701eab7c9c58f276d71d861cb71fa75dad06605b898d6c8462d77b2707f38aa55ba07f98bb1f38c78cd96693ee601f4077d1c8a106523245eb46d41942fa7906c7e9b8f7e675fc1a9ca94330989231d74cb0e1755fa6ccd793af16c6ce6ceac9defc80e8a28424f7cb65fb6e18cf6880024e5cee3b5b23c037aa2813af04ddc6192296b249338abff94a2770a8075865937cce556aa22947451ef03a87ace3aba90e4d251ae367b2e97103bb87a8b12302d0d999468d52956fda11d0add2f5b75654b58c9ccbeb75e377d6c49011c008b10c4f14aef2603cbc396d5a87dae33b9ee74bfd1c062ca5ad6951806fe16290eb6180fc8307d0407be9fae269f946d546eed88bc2c67ae8d9493414fa9c3ffdfe52b1b9adafa16a71badacebbe1316a098f6646272438ea3453bf6d14ca2f828aa9c462fb5a894eb5c74a0f440ee6a5ca33bd1e5c52f9ec9c22ffee77a2770f74c95c48b1c731d494f43a128529824a64df8215d2e4e5fa6feccb5df5228dabe660a234b3f0ee979baf86531eadd8755db9e673e2ae8be910667a4f0016bee964632ddd51fd8083cd61c615f3146074687f01ed478881842f2cfcdbc15200f69539e9a1f086abe7f4ae90561dd283ee2ee158ffa0f2bae1e5ab25cf4aac2495b80d5fa2bca52dcc3b272e12121240d46088b60f51c4bb8c8ad7aa1f467ff336eb94d0a0e00ba4a7848e6c19ec463aca63c12b87b7c82b8437a874ed43c5d3202bf058eee01a67027cac4772417e63fb2d3610540d21ccc3ed8cbe8505bc7915438fb618f1b45a7761da35317959992a0ca24af8a71233ebab2834abd97d01fde2cbe964329ae6f32603fee2a38dc9e0101ed85061b2e05cce702e24a385faf62fa2e1bb0551c4ff8a5942068cb4184bed68f6af2a927ecaed779921360019431094aa4022a29a778eaa7cb82a1621f48539dde993be3e5943f9fb2b15bab1b4bf9aef7f3ec327b73f0d8f103481d6e334d25c31f696f9de5090ad1d40bed65bf4eb7b3382b87f62aea6f4a675b5d37359ec492b255378b78a5c1fdc231f9a6f86fd9de53379c8580bd32a59dd3d9e658b4a1b156eef190c58c8ddcea0bdf8eaaa8aa23a0ae08c0c094ef333b7b044c11b36248863b094f8558a53bf61da5dfa0eed140e16b2e211d0c2f287de3e2ba0aab14d24dc4c1a6c22e1115ba0ed2520cc7055b38c00d1e71ac984ef3a9ba4efe550cc79b4df64d04808973fccdd2346c6a1682546b687b64db1d46d559e0a6985ba4680dc36fc47255736d598acfcd5c2c199c5fd19326220437fe3f4901ddda5b59609281775d104c94306b5166c2f8d6c9863036de2698096065ba958da02dbdfb1437e1c2814574f645d444bd206b61b0428911045a05da502b0bc6ae030622ec0d933e26bcb961c15b8198b5c62085bef6c911cb8ebda40c669438fbf5505259433ad8d11b409808251252de7eb64407922de0d378942946b7b1c16d7867e8a193051ce4435b5ee636317e3414869666c77fd3385dd1c4e23f9fc604bf33e65045f91b182cbeffde3bae3f96f5cd472f3117f54f4773494c16cf279de725b5fc5eb96adeb80c42227c6d29770c4dbb974eb390d6a835377dc2cfdacd9ccd47f7095f63ab619371e901229a1308dd9589aa3fcd99745d0181f53ef5cbbaa14723a94ad4175f143003b2771ddd62fffdf7b2c7cca5a91931eb0caa7f393048cef4f3c0252ae2d9b08116a26a4ed52517ae6ca784b7f455567907a45b86626faa7cc0558668f326b97a73dd2c9dfe0e6aeda1fa43aec2de3139da70e10911e4f272368747915b5039455b4c233a3013ed2eddf7096a36dd258b8dafcdd0f14e95104f4083c9736f73f57608188bd44223b7ce42d61aef4ccee6d5f293ba68ed9dc79e32b2a40110faf10dbf265465b2663f9d5eb900c5ed6b958e2e5abb8e93df3260116b82f5e93b4d8540999d0f8f792207be909ccc0ee7fca3b176ec3ddbca9129e6d67f24342dbad9484f8688bb96c8e69b165abd5b476baa20dde1d79a3267072e7459f62aba67771df85ccd75dc51a1b0cb7a0b4aec591af8ddcbd7b7d99bad2bcc5bc1cf27dcd17185c7cc0e557cc99afaa6c2c23da9c16152b4cc5fa428ccebf0b8aaa0b2025c48523251a9f24a895b5533172a17139944a70b2b42037f74edec2feb1dcaffeadba0320e3e9ae03e6475e47926ce66c17a19760155d311b9245463375</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-swup-reload-script src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">Here&#39;s something encrypted, password is required to continue reading.</summary>
    
    
    
    <category term="Dairy" scheme="https://primeluoqiu.github.io/categories/Dairy/"/>
    
    
  </entry>
  
  <entry>
    <title>3月31号日记</title>
    <link href="https://primeluoqiu.github.io/2024/03/31/Dairy/0331/"/>
    <id>https://primeluoqiu.github.io/2024/03/31/Dairy/0331/</id>
    <published>2024-03-31T15:27:26.331Z</published>
    <updated>2024-03-31T15:36:28.667Z</updated>
    
    <content type="html"><![CDATA[<pre><code>今天身体不大舒服，早上起来之后就直接嗓子痛，很难受，然后晚上的话嗓子似乎好了一些，但是头有点晕，然后右胳膊也不是很舒服，一种酸痛的感觉。然后想学感觉脑子也跟不上了，这周任务还是没有完成，身体还是要好好养着的，不能太累，也不能太慵懒。也许是最近喝水不太多，也许是这两天做裁判有点累，今天还没休息的过来。然后就出去玩了一天，下午还洗了个澡。应该问题不大，下周有一个清明节，除了复习蓝桥杯之外应该还可以多学一点别的东西，任务应该是可以完成了。本周真的蛮可惜的，就差半个小时就把这周的任务做完了。但是身体实在是扛不住了，早点休息为好。剩下的下周任务的明天早上看看能不能早点起来写吧。还是要加油。希望的曙光就在眼前了。加油！五一还是想回家把驾照考了。然后就没什么事情了，主要是考完之后就没什么事情了，还可以早过实习期。只要从学校跑出去，学校的事情就不管了，虽然不一定。但是还是要试试。</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;pre&gt;&lt;code&gt;今天身体不大舒服，早上起来之后就直接嗓子痛，很难受，然后晚上的话嗓子似乎好了一些，但是头有点晕，然后右胳膊也不是很舒服，一种酸痛的感觉。然后想学感觉脑子也跟不上了，这周任务还是没有完成，身体还是要好好养着的，不能太累，也不能太慵懒。也许是最近喝水不太多，也许</summary>
      
    
    
    
    <category term="Dairy" scheme="https://primeluoqiu.github.io/categories/Dairy/"/>
    
    
  </entry>
  
  <entry>
    <title>3月30号日记</title>
    <link href="https://primeluoqiu.github.io/2024/03/30/Dairy/0330/"/>
    <id>https://primeluoqiu.github.io/2024/03/30/Dairy/0330/</id>
    <published>2024-03-30T13:22:10.277Z</published>
    <updated>2024-03-30T13:47:23.634Z</updated>
    
    <content type="html"><![CDATA[<p>今天的志愿工作做的还不错，就是上午第一次给他们做评分的时候因为紧张，还有一些没注意过得地方出了不少差错。有两个组因为因为不小心的失误都少扣了十分，然后还好有一组没什么影响，但是有一组还是不得不扣了，不然的话名词会发生变化。这样的话就没有公平性可言了。不过这一上午的裁判工作还算是比较完善，没出什么大的差错，也没有遇见那种喜欢叨叨的同学和家长以及指导老师，大家都很不错，不过比起高中那边，听说有很多都在抬杠，包括指导老师。学生抬杠就算了，指导老师也跟着一起抬，这就没啥意思了。为人师长，自己不好好看看规则，然后就带着学生来比赛了。还带着学生一起抬杠，咱这也不是抬杠大赛，不是你声音大就可以赢了。以至于最后初中这边的比赛结束之后，高中那边的还没结束。然后就到了中午吃饭，这个饭啊，emm，只能说和昨天是天壤之别了。不过好歹也算是对付了两口，不至于大下午空着肚子执裁。下午的小学生组确实相对来说轻松一点，不过中间还是出现了一点小插曲，例如有一个小同学还是比较心急的想要碰一下，但是我们提醒到位，再加上也就是轻微碰了一下器材，也没有对实验造成什么实质上的印象，于是我们就没有让他重置了。当时在场的所有人都没有吭声，一直到结束之后换了下一组那个男人才开始说起来，这会已经没有时间再处理了。那个男人还在那里口若悬河的说说说。我们和主裁说了很多话，就是不听。对此只有一句话，就是菜就多练，输不起就别玩。换做是他的学生他是不是就不会吭声了，这个时候如果有别人像他一样，他是会觉得那个人不太行呢，还是怎么说呢？这就不好评价了。不过执裁的路途中还是学到了很多的。包括如何执裁，如何让同学和老师们信服执裁过程而没有意义，面对小朋友的时候该凶一点就要凶一点，该温柔的时候就应该温柔一点。都要有个度，例如，像下午小学场的小孩子们总是完美的结束之后不知道喊停，为了公平起见，我都是按照大概接触的时间给他们算的，这样也是一种相对来说的公平。然后比赛的时候有一次我就比较严声的跟他们说，我说你们不说，我给你们按什么时间算呢，是按照你喊的时间呢，还是按照结束的时间呢，结束之后一定要自己喊停。有的孩子喊早了，我还是一样的，我说你喊早了我应该怎么给你算呢，是按照早一点的算呢，还是等到了终点之后再算呢。希望他们可以记得住这次经历，并在以后的比赛中不要再犯这样的错误了。</p><p>不过有一说一今天是真的累，已经没有任何心力再学下去了，目前的任务其实也就是计网的2.2，不过这周的任务完成情况还得看明天结束这一周之后的任务状态。也不知道明天早上会睡到几点，因为今天实在是太累了，从早上执裁到下午。真的是做了一天的事情，走来走去，还要耗费精力去做这些事情，一不留神可能就漏掉了一个问题，然后就容易导致一些差错。下午的过程明显相对来说要顺利很多。晚上吃完饭回新工科之后，可能身体还好，但是思想是真的懈怠了，一点力气都没有了，或许这就是耗费了一天精力之后的感受吧。不过这一趟的收获还真的是蛮多的。而且在上午制裁的过程中，还无意中注意到了有一个正在做介绍的好像是体育馆的老师还是科技馆的老师，给那些领导讲解的时候，那个领导说他讲的还不错，然后问他在哪工作，那个人就说在科技馆这边工作，然后领导说他干得还不错，问之前怎么没见过他。他说好像是今天要接待领导，然后专门好好收拾了一下自己。看来这哥们的仕途应该要稍微往上一点点了，多少也是给领导留下来了一个好印象，没准哪天之后就会因为一些原因被提拔起来。哈哈哈哈</p><p>这两天嗓子似乎不大舒服，可能是扁桃体有点发炎，得多喝点水了。好好休息一下，也比较累，少熬会夜。加油吧</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天的志愿工作做的还不错，就是上午第一次给他们做评分的时候因为紧张，还有一些没注意过得地方出了不少差错。有两个组因为因为不小心的失误都少扣了十分，然后还好有一组没什么影响，但是有一组还是不得不扣了，不然的话名词会发生变化。这样的话就没有公平性可言了。不过这一上午的裁判工作还</summary>
      
    
    
    
    <category term="Dairy" scheme="https://primeluoqiu.github.io/categories/Dairy/"/>
    
    
  </entry>
  
  <entry>
    <title>1.5 控制</title>
    <link href="https://primeluoqiu.github.io/2024/03/29/ClassesFormUCBerkely/CS61A/1.5%E6%8E%A7%E5%88%B6/"/>
    <id>https://primeluoqiu.github.io/2024/03/29/ClassesFormUCBerkely/CS61A/1.5%E6%8E%A7%E5%88%B6/</id>
    <published>2024-03-29T13:50:16.549Z</published>
    <updated>2024-03-29T13:50:53.432Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-5-控制"><a href="#1-5-控制" class="headerlink" title="1.5 控制"></a>1.5 控制</h3><p>现在可以定义的函数能力十分有限，因为还没有引入一种方法来进行比较，并根据比较的结果执行不同的操作。控制语句将赋予我们这种能力，就是根据逻辑比较的结果来控制执行流程的语句。</p><p>语句与我们目前研究过的表达式有着根本的不同，<strong>他们没有值</strong>。执行一个控制语句决定了解释器接下来应该做什么，而不是计算某些东西</p><hr><h3 id="1-5-1-语句"><a href="#1-5-1-语句" class="headerlink" title="1.5.1 语句"></a>1.5.1 语句</h3><p>到目前为止，虽然思考的是如何计算表达式，但我们已经见过了三种语句：赋值(assignment)、<code>def</code>和<code>return</code>语句。尽管这些Python代码都包含表达式作为他们的一部分，但它们本身并不是表达式。</p><p>语句不会被求解，而会被执行。每个语句都描述了对解释器状态的一些更改，并且执行语句就会应用该更改。正如在<code>return</code>和赋值语句中看到的那样，执行语句可能涉及求解其包含的子表达式。</p><p>表达式也可以作为语句执行，在这种情况下，它们会被求值，但是它们的值会被丢弃。执行纯函数没有效果，但执行非纯函数会因为调用函数而产生效果。</p><p>思考一下，例如:</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">square</span>(<span class="params">x</span>):</span><br><span class="line">    mul(x, x)</span><br></pre></td></tr></table></figure></div><p>这个例子是有效的Python代码，但是不能达到预期。表达式本身是一个有效的语句，但语句的效果是调用<code>mul</code>函数，然后把结果丢弃。如果想对表达式的结果做什么，需要用赋值语句存储它或用<code>return</code>语句返回它：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">square</span>(<span class="params">x</span>)</span><br><span class="line">    <span class="keyword">return</span> mul(x, x)</span><br></pre></td></tr></table></figure></div><p>有时，在调用<code>print</code>等非纯函数时，拥有一个主体为表达式的函数确实有意义。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">print_square</span>(<span class="params">x</span>)</span><br><span class="line">    <span class="built_in">print</span>(square(x))</span><br></pre></td></tr></table></figure></div><p>在最高层级上，Python解释器的工作是执行由语句组成的程序。然而，很多有趣的计算工作都来自对表达式的求值。语句用来管理程序中不同表达式之间的关系，以及它们产生的结果。</p><hr><h3 id="1-5-2-复合语句"><a href="#1-5-2-复合语句" class="headerlink" title="1.5.2 复合语句"></a>1.5.2 复合语句</h3><p>通常，Python代码是一系列语句。简单语句是不以冒号结尾的单行，而由其他语句(简单语句和复合语句)组成被称为复合语句。复合语句通常跨越多行，以单行头部(header)开始，并以冒号结尾，其中冒号标识语句的类型。头部和缩进的句体(suite)一起称为子句。复合语句由一个或多个子句组成：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;header&gt;:</span><br><span class="line">    &lt;statement&gt;</span><br><span class="line">    &lt;statement&gt;</span><br><span class="line">    ...</span><br><span class="line">&lt;separating header&gt;</span><br><span class="line">    &lt;statement&gt;</span><br><span class="line">    &lt;statement&gt;</span><br><span class="line">    ...</span><br><span class="line">...</span><br></pre></td></tr></table></figure></div><p>我们可以用这些术语来理解我们之前介绍过的语句。</p><ul><li>表达式、返回语句和赋值语句都是简单语句。</li><li><code>def</code>语句是复合语句，<code>def</code>头后面的句体定义了函数体。<br>对每类header 都有专门的求值规则来规定其何时执行以及是否执行其句体中的语句。我们说”the header controls its suite”, 例如，在<code>def</code>语句中，<code>return</code>表达式不会立即求值，而是存储起来供以后调用该函数时使用。</li></ul><p>我们现在也可以理解多行程序了。</p><ul><li>要执行一系列语句，会先执行第一个语句，如果不重定向控制，那么就继续执行其余部分<br>这个定义解释了递归定义序列(sequence)的基本结构：一个序列可以分解成它的第一个元素和其余元素。语句序列的”其余部分”本身也是语句序列!因此，我们可以递归地应用这个执行规则。这就是将递归视为数据结构的观点</li></ul><p>此规则的重要结论时语句会按顺序执行，但由于重定向控制(redirected control),后面的语句可能永远不会被执行到。</p><p>缩进必须要缩进相同的量。</p><hr><h3 id="1-5-3-定义函数II-局部赋值"><a href="#1-5-3-定义函数II-局部赋值" class="headerlink" title="1.5.3 定义函数II:局部赋值"></a>1.5.3 定义函数II:局部赋值</h3><p>函数的主体不仅仅是包含单个返回语句的<code>return</code>组成，事实上，还可以定义超出单个表达式的一系列操作。</p><p>每当用户定义的函数被调用时，其具体中的子句序列将会在局部环境中执行-&gt;该环境通过调用函数创建的局部帧开始。<code>return</code>语句会重定向控制：每当执行一个<code>return</code>语句时，函数应用程序就会终止，<code>return</code>表达式的值会被作为被调用函数的返回值。</p><p>赋值语句可以出现在函数体中，例如</p><div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">percent_difference</span>(<span class="params">x, y</span>):</span><br><span class="line">    difference = <span class="built_in">abs</span>(x - y)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">100</span> * difference / x</span><br><span class="line">result = percent_difference(<span class="number">40</span>, <span class="number">50</span>)</span><br></pre></td></tr></table></figure></div><p>这个函数利用了两步计算，首先计算两个数的差的绝对值，然后求出它与第一个数的百分比并返回</p><p>赋值语句的作用是将名称和当前环境中的第一帧的值绑定。因此，函数体内的赋值语句不会影响全局帧。”函数只能操纵其局部帧”是创建模块化程序的关键，而在模块化程序中，纯函数仅通过它们接收和返回的值与外界交互。</p><p>当然，上述函数也可以只用一条赋值语句实现，但是返回表达式会更复杂</p><p><code>return 100 * abs(x - y)</code></p><p>到目前为止，局部赋值并没有增强函数定义的表达能力，而当它与其他控制语句结合时，就会增强。此外，局部赋值在”通过中间量赋名来解释复杂表达式的含义”方面也起着至关重要的作用。</p><hr><h3 id="1-5-4-条件语句"><a href="#1-5-4-条件语句" class="headerlink" title="1.5.4 条件语句"></a>1.5.4 条件语句</h3><p>Python有一个用于计算绝对值的内置函数。</p><div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">abs</span>(-<span class="number">2</span>)</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure></div><p>我们希望可以实现这样一个函数。但是我们想清楚我们要表达的是，如果x为正，就为正，为负取反。那么可以用条件语句来表示</p><div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">absolute_value</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">if</span>(x &gt;= <span class="number">0</span>):</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">return</span> -x</span><br><span class="line">result = absolute_value(x)    </span><br></pre></td></tr></table></figure></div><p>这个<code>absolute_value</code>函数的实现提出了几个重要问题：</p><p>条件语句(Condition statement):Python中的条件语句是由一系列头部和句体组成的：必须的<code>if</code>子句、可选的<code>elif</code>子句序列，最后是可选的<code>else</code>子句：</p><div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> &lt;expression&gt;:</span><br><span class="line">    &lt;suite&gt;</span><br><span class="line"><span class="keyword">elif</span> &lt;expression&gt;:</span><br><span class="line">    &lt;suite&gt;</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    &lt;suite&gt;</span><br></pre></td></tr></table></figure></div><p>执行条件语句的时候，每个子句都会按顺序被考虑。执行条件子句的计算过程如下。</p><ol><li>求解头部的表达式</li><li>如果它是真值，则执行该句体。然后跳过条件语句中的所有后续子句。</li></ol><p>如果达到<code>else</code>语句(仅当所有<code>if</code>和<code>elif</code>表达式的计算结果为假值时才会发生),则执行其句体。</p><p>布尔上下文(Boolean contexts)：上面，执行过程提到了”假值 a false value”和”真值 a true value”。<strong>条件块头部语句内的表达式</strong>被称为布尔上下文：它们值的真假对控制流很重要，另外，它们的值不会被赋值或返回。Python包含多个假值，包括**0, <code>None</code>, 和布尔值<code>false</code>**，所有其他数字都是真值。</p><p>布尔值(Boolean Value)：Python中有两个布尔值:<code>True</code>和<code>False</code>。布尔值表示逻辑表达式中的真值。内置的比较运算符&gt;,&lt;,&gt;&#x3D;,&lt;&#x3D;,&#x3D;&#x3D;, !&#x3D;会返回这些值。</p><div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">4</span> &gt; <span class="number">2</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">5</span> &gt;= <span class="number">5</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure></div><p>第二个例子在<code>operator</code>模块中的<code>ge</code></p><div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">0</span> == -<span class="number">0</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure></div><p>这个对应的是<code>operator</code>中的<code>eq</code>。Python会区分赋值和相等比较符号，许多语言都是这样</p><p>布尔运算符(Boolean operator):Python中还内置了三个基本的逻辑运算符：</p><div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">True</span> <span class="keyword">and</span> <span class="literal">False</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">True</span> <span class="keyword">or</span> <span class="literal">False</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">not</span> <span class="literal">False</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure></div><p>逻辑表达式具有相应的求值过程。而这些过程利用了这样的一个理论-&gt;有时，逻辑表达式的真值可以在不对其所有子表达式求值的情况下确定，这一特性称为短路，例如(or)</p><hr><p>求解表达式 <code>&lt;left&gt; and &lt;right&gt;</code> 的步骤如下：</p><ol><li>求解子表达式  <code>&lt;left&gt;</code>。</li><li>如果左边的结果为假值 v，则表达式的计算结果就是 v。</li><li>否则，表达式的计算结果为子表达式 <code>&lt;right&gt;</code> 的值。</li></ol><hr><p>求解表达式  <code>&lt;left&gt; or &lt;right&gt;</code> 的步骤如下：</p><ol><li>求解子表达式  <code>&lt;left&gt;</code>。</li><li>如果左边的结果为真值 v，则表达式的计算结果就是 v。</li><li>否则，表达式的计算结果为子表达式 <code>&lt;right&gt;</code> 的值。</li></ol><hr><p>求解表达式  <code>not &lt;exp&gt;</code> 的步骤如下：</p><ol><li>求解  <code>&lt;exp&gt;</code>，如果结果为假值，则值为 <code>True</code> ，否则为 <code>False</code>。</li></ol><hr><p>这些值、规则和运算符为我们提供了一种组合比较结果的方法。<strong>执行比较并返回布尔值的函数通常以 <code>is</code> 开头，后面不跟下划线</strong>（例如 <code>isfinite, isdigit, isinstance</code> 等）。</p><hr><h3 id="1-5-5-迭代"><a href="#1-5-5-迭代" class="headerlink" title="1.5.5 迭代"></a>1.5.5 迭代</h3><p>除了选择要执行的语句外，控制语句还用于重复。如果我们编写的每一行代码只执行一次，那么编程将是一项非常低效的工作只有通过重复执行语句，我们才能释放计算机的全部潜力。我们之前已经见过了一种重复形式:一种函数只用定义一次，就可以被多次调用。迭代控制(Iterative control)结构是另一种多次执行相同语句的机制。</p><p>思考一下之前学过的斐波那契数列，其中每个数都是前两个数的和。<br>$$<br>0, 1, 1, 2, 3, 5, 8, 13, 21 …<br>$$<br>每个值都是通过重复应用<code>sum-previous-two</code>的规则构建的，第一个和第二个值固定为0和1.</p><p>我们可以使用<code>while</code>语句来枚举n项斐波那契数列。我们需要跟踪已经创建了多少个值(k),和第k个值(<code>curr</code>)及其前身(<code>pred</code>)。单步执行此函数并观察斐波那契数列如何一个一个的演化，并绑定到<code>curr</code></p><div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fib</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Compute the nth Fibonacci number, for n &gt;= 2</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    pred, curr = <span class="number">0</span>, <span class="number">1</span> <span class="comment">#Fibonacci numbers 1 and 2</span></span><br><span class="line">    k = <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> k &lt; n:</span><br><span class="line">        pred, curr = curr, pred + curr</span><br><span class="line">        k = k + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> curr</span><br><span class="line">    result = fib(<span class="number">8</span>)</span><br></pre></td></tr></table></figure></div><p>请记住，单行赋值语句可以用逗号分隔多个名称和值同时赋值。该行：</p><p><code>pred, curr = curr, pred + curr</code></p><p>在更新左侧的绑定之前求出所有 <code>=</code> 右侧的内容 → 这种事件顺序对于此函数的正确性至关重要。</p><p><code>while</code> 子句包含一个头部表达式，后跟一个句体：</p><div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> &lt;expression&gt;:</span><br><span class="line">    &lt;suite&gt;</span><br></pre></td></tr></table></figure></div><p>要执行 <code>while</code> 子句：</p><ol><li>求解头部的表达式。</li><li>如果是真值，则执行后面的句体，然后返回第 1 步。</li></ol><p>在第 2 步中，<code>while</code> 子句的整个句体在再次计算头部表达式之前执行。</p><p>为了防止 <code>while</code> 子句的句体无限期地执行，句体应该总是在每次循环中更改一些绑定。</p><p>不会终止的 <code>while</code> 语句被称为无限循环（infinite loop）。按 <code>&lt;Control&gt;-C</code> 可以强制 Python 停止循环。</p><h3 id="1-5-6-测试"><a href="#1-5-6-测试" class="headerlink" title="1.5.6 测试"></a>1.5.6 测试</h3><p>测试一个函数就是去验证函数的行为是否符合预期。</p><p>测试是一种系统地执行验证的机制。它通常采用另一个函数的形式，其中包含对一个或多个对被测试函数的调用样例，然后根据预期结果验证其返回值。与大多数旨在通用的函数不同，测试需要选择特定参数值，并使用它们验证函数调用。测试也可用作文档：去演示如何调用函数，以及如何选取合适的参数值。</p><p>断言（Assertions）：程序员使用 <code>assert</code> 语句来验证是否符合预期，例如验证被测试函数的输出。<code>assert</code> 语句在布尔上下文中有一个表达式，后面是一个带引号的文本行（单引号或双引号都可以，但要保持一致），如果表达式的计算结果为假值，则显示该行。</p><div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">assert</span> fib(<span class="number">8</span>) == <span class="number">13</span>, <span class="string">&#x27;第八个斐波那契数应该是 13&#x27;</span></span><br></pre></td></tr></table></figure></div><p>当被断言的表达式的计算结果为真值时，执行断言语句无效。而当它是假值时，<code>assert</code> 会导致错误，使程序停止执行。</p><p>fib 的测试函数应该测试几个参数，包括 n 的极限值。</p><div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">fib_test</span>():</span><br><span class="line">        <span class="keyword">assert</span> fib(<span class="number">2</span>) == <span class="number">1</span>, <span class="string">&#x27;第二个斐波那契数应该是 1&#x27;</span></span><br><span class="line">        <span class="keyword">assert</span> fib(<span class="number">3</span>) == <span class="number">1</span>, <span class="string">&#x27;第三个斐波那契数应该是 1&#x27;</span></span><br><span class="line">        <span class="keyword">assert</span> fib(<span class="number">50</span>) == <span class="number">7778742049</span>, <span class="string">&#x27;在第五十个斐波那契数发生 Error&#x27;</span></span><br></pre></td></tr></table></figure></div><p>当在文件中而不是直接在解释器中编写 Python 时，测试通常是在同一个文件或带有后缀 <code>_test.py</code> 的相邻文件中编写的。</p><p>文档测试（Doctests）：Python 提供了一种方便的方法，可以将简单的测试直接放在函数的文档字符串中。文档字符串的第一行应该包含函数的单行描述，接着是一个空行，下面可能是参数和函数意图的详细描述。此外，文档字符串可能包含调用该函数的交互式会话示例：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">sum_naturals</span>(<span class="params">n</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;返回前 n 个自然数的和。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; sum_naturals(10)</span></span><br><span class="line"><span class="string">        55</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; sum_naturals(100)</span></span><br><span class="line"><span class="string">        5050</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        total, k = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> k &lt;= n:</span><br><span class="line">            total, k = total + k, k + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> total</span><br></pre></td></tr></table></figure></div><p>然后，可以通过 <a class="link"   href="http://docs.python.org/py3k/library/doctest.html" >doctest 模块 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 来验证交互，如下。</p><div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> doctest <span class="keyword">import</span> testmod</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>testmod()</span><br><span class="line">TestResults(failed=<span class="number">0</span>, attempted=<span class="number">2</span>)</span><br></pre></td></tr></table></figure></div><p>如果仅想验证单个函数的 doctest 交互，我们可以使用名为 <code>run_docstring_examples</code> 的 <code>doctest</code> 函数。不幸的是，这个函数调用起来有点复杂。第一个参数是要测试的函数；第二个参数应该始终是表达式 <code>globals()</code> 的结果，这是一个用于返回全局环境的内置函数；第三个参数 <code>True</code> 表示我们想要“详细”输出：所有测试运行的目录。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> doctest <span class="keyword">import</span> run_docstring_examples</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>run_docstring_examples(sum_naturals, <span class="built_in">globals</span>(), <span class="literal">True</span>)</span><br><span class="line">Finding tests <span class="keyword">in</span> NoName</span><br><span class="line">Trying:</span><br><span class="line">    sum_naturals(<span class="number">10</span>)</span><br><span class="line">Expecting:</span><br><span class="line">    <span class="number">55</span></span><br><span class="line">ok</span><br><span class="line">Trying:</span><br><span class="line">    sum_naturals(<span class="number">100</span>)</span><br><span class="line">Expecting:</span><br><span class="line">    <span class="number">5050</span></span><br><span class="line">ok</span><br></pre></td></tr></table></figure></div><p>当函数的返回值与预期结果不匹配时，<code>run_docstring_examples</code> 函数会将此问题报告为测试失败。</p><p>当你在文件中编写 Python 时，可以通过使用 doctest 命令行选项启动 Python 来运行文件中的所有 doctest：</p><div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -m doctest &lt;python_source_file&gt;</span><br></pre></td></tr></table></figure></div><p>有效测试的关键是在实现新功能后立即编写（并运行）测试。在实现之前编写一些测试也是一种很好的做法，以便在你的脑海中有一些示例输入和输出。调用单个函数的测试称为单元测试（unit test）。详尽的单元测试是良好程序设计的标志。</p><p>总结来看，本节的主要内容是对于函数的控制，函数不仅包含了能够返回值的<code>return</code>语句，还可以对函数进行多种复杂的语句，例如复合语句。然后就是有关局部赋值，也就是在函数内部定义一个变量用来进行赋值的操作。接下来就是有关条件的<code>if-else</code>语句和布尔值，在这里，要对逻辑表达式的求值过程中的短路有所了解。接下来就是函数内部的迭代，这里利用到了<code>while</code>语句，通过<code>while</code>语句来更新斐波那契数列的<code>pred</code>和<code>curr</code>，最后就是对于函数的测试，我们要看我们写的函数是不是满足我们的心理预期。测试的方式有很多种，包括但不限于断言和文档测试。最后，我们了解到有效测试的关键是在实现新功能后立即编写(并运行)测试。在实验之前编写一些测试也是一种很好的做法。详尽的单元测试是良好程序设计的标志。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-5-控制&quot;&gt;&lt;a href=&quot;#1-5-控制&quot; class=&quot;headerlink&quot; title=&quot;1.5 控制&quot;&gt;&lt;/a&gt;1.5 控制&lt;/h3&gt;&lt;p&gt;现在可以定义的函数能力十分有限，因为还没有引入一种方法来进行比较，并根据比较的结果执行不同的操作。控制语句将</summary>
      
    
    
    
    <category term="CS61A" scheme="https://primeluoqiu.github.io/categories/CS61A/"/>
    
    
  </entry>
  
  <entry>
    <title>3月29日日记</title>
    <link href="https://primeluoqiu.github.io/2024/03/29/Dairy/0329/"/>
    <id>https://primeluoqiu.github.io/2024/03/29/Dairy/0329/</id>
    <published>2024-03-29T13:37:01.094Z</published>
    <updated>2024-03-29T13:49:58.154Z</updated>
    
    <content type="html"><![CDATA[<p>今天下午去做了志愿之前的准备工作，虽然似乎并没有干什么，但是还是感觉到身体有一阵疲惫的感觉。晚上回来的路上甚至靠在车的座位的背部小憩了一会。这个志愿工作也签署了保密协议，不过感觉跟之前的在严谨性上差了好多。晚上的餐食还不错，小小的炫了点饭。也是没想到居然会拿蒜薹炒一点牛肉。这个是没想到的。</p><p>一下午基本上过去之后就是在那边坐着，然后开了个预备大会，然后就是吃饭啥的，然后在吃饭之前的比赛场馆里面看到有一些看起来比较高科技的所谓的能够通过脑电波来测试专注力，虽然但是，我还是觉得是有一定的技术成分，但是似乎也并不高。有参考意义，但不多。就像手上带的手表和购买的体脂秤所评价出来的心率道理是一样的。两个数据基本上就从来都没有对准过。</p><p>还是在减肥的路上，但是目前好像又涨了一些，体重目前保持在了95附近，但是也不知道下个月能不能到90左右，是有在坚持运动和锻炼，但是主要还是早上起不来，起得来的话早上出去走两圈还是很舒服的，晚上睡的也晚，其实是可以早点休息的，不过主要似乎也不是很困，然后熬着熬着夜就深起来了，倒也没什么办法。晚上上床之后还是看看书，有啥好一点的电子书看着看着应该也就困了。</p><p>希望明天的志愿活动不要出什么差错，完完整整的度过这一整天就好</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天下午去做了志愿之前的准备工作，虽然似乎并没有干什么，但是还是感觉到身体有一阵疲惫的感觉。晚上回来的路上甚至靠在车的座位的背部小憩了一会。这个志愿工作也签署了保密协议，不过感觉跟之前的在严谨性上差了好多。晚上的餐食还不错，小小的炫了点饭。也是没想到居然会拿蒜薹炒一点牛肉。</summary>
      
    
    
    
    <category term="Dairy" scheme="https://primeluoqiu.github.io/categories/Dairy/"/>
    
    
  </entry>
  
  <entry>
    <title>2.0-2.1应用层概述及应用层原理</title>
    <link href="https://primeluoqiu.github.io/2024/03/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.0.1/"/>
    <id>https://primeluoqiu.github.io/2024/03/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.0.1/</id>
    <published>2024-03-28T15:08:54.880Z</published>
    <updated>2024-03-28T15:22:22.428Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/28/jP11UBQt.jpg"                      alt="31.jpg"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/28/VmylFgdU.jpg"                      alt="32.jpg"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/28/u1KArs2u.jpg"                      alt="33.jpg"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/28/qyFjL5eT.jpg"                      alt="34.jpg"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/28/gxDfjYvy.jpg"                      alt="35.jpg"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/28/gcWxPUxg.jpg"                      alt="36.jpg"                ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;https://img2.imgtp.com</summary>
      
    
    
    
    <category term="计网" scheme="https://primeluoqiu.github.io/categories/%E8%AE%A1%E7%BD%91/"/>
    
    
  </entry>
  
  <entry>
    <title>1.4设计函数</title>
    <link href="https://primeluoqiu.github.io/2024/03/27/ClassesFormUCBerkely/CS61A/1.4%20%E8%AE%BE%E8%AE%A1%E5%87%BD%E6%95%B0/"/>
    <id>https://primeluoqiu.github.io/2024/03/27/ClassesFormUCBerkely/CS61A/1.4%20%E8%AE%BE%E8%AE%A1%E5%87%BD%E6%95%B0/</id>
    <published>2024-03-27T14:06:19.040Z</published>
    <updated>2024-03-27T14:07:07.517Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-4-设计函数"><a href="#1-4-设计函数" class="headerlink" title="1.4 设计函数"></a>1.4 设计函数</h1><p>函数是所有程序(无论大小)的基本组成部分，并且是我们使用编程语言来表达计算过程的主要媒介。本节内容是如何设计一个好的函数。</p><p>那么好函数共有的品质就是：它们都强化了”函数就是抽象”理念。</p><ul><li>每个函数应该只负责一个任务，且该任务要用一个简短的名称来识别，并在一行文本中进行描述。按顺序执行多个任务的函数应该分为多个函数。</li><li>不要重复自己(Don’t repeat yourself)是软件工程的核心原则。这个所谓的DRY原则直出，多个代码片段不应该描述重复的逻辑。相反，逻辑应该只实现一次，为其指定一个名称后多次使用。</li><li>定义通用函数。比如作为<code>pow</code>函数的一个特例的平方函数就不在<code>Python</code>库中，因为<code>pow</code>函数可以将数字计算为任意次方。</li></ul><p>这些准则提高了代码的可读性，减少了错误的数量，并且通常最大限度地减少了便携的代码总量。将复杂的任务分解为简洁的功能是一项需要经验才能掌握的技能。不过好在Python提供了多种特性来支持工作</p><h3 id="1-4-1-文档"><a href="#1-4-1-文档" class="headerlink" title="1.4.1 文档"></a>1.4.1 文档</h3><p>函数定义通常包括描述函数的文档，称为”文档字符串 docstring”，它必须在函数体中缩进。文档字符串通常使用三个引号，第一行描述函数的任务，随后的几行可以描述参数并解释函数的意图</p><div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">pressure</span>(<span class="params">v, t, n</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    计算理想气体的压力，单位为帕斯卡</span></span><br><span class="line"><span class="string">     v -- 气体体积，单位为立方米</span></span><br><span class="line"><span class="string">        t -- 绝对温度，单位为开尔文</span></span><br><span class="line"><span class="string">        n -- 气体粒子</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    k = <span class="number">1.38</span>e - <span class="number">23</span>  <span class="comment">#玻尔兹曼常数</span></span><br><span class="line">    <span class="keyword">return</span> n * k * t / v </span><br></pre></td></tr></table></figure></div><p>当你使用函数名称作为参数调用<code>help</code>时，你会看到它的文档字符串(键入<code>q</code>以退出Python help)。</p><div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">help</span>(pressure)</span><br></pre></td></tr></table></figure></div><p>编写Python程序时，除了最简单的函数之外，都要包含文档字符串。要记住，虽然代码只编写一次，但是会在之后阅读多次。Python文档包含了文档字符串准则，它会在不同的Python项目中保持一致。</p><p>注释：Python中的注释可以附加到<code>#</code>号后的行尾。例如，上面代码中的<code>#</code>后面的注释描述了k变量的含义。这些注释不会出现在Python的<code>help</code>中，而且会被解释器忽略，它们只为了注释而出现</p><hr><h3 id="1-4-2-参数默认值"><a href="#1-4-2-参数默认值" class="headerlink" title="1.4.2 参数默认值"></a>1.4.2 参数默认值</h3><p>定义通用函数的结果是引入了额外的参数。具有许多参数的函数可能调用起来很麻烦并且难以阅读。</p><p>在Python中，我们可以为函数的参数提供默认值。当调用该函数时，具有默认值的参数是可选的。如果未提供，则将默认值绑定到形参上。例如，如果程序通常用于计算”一摩尔”粒子的压力，则可以提供此值作为默认值</p><div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">pressure</span>(<span class="params">v, t, n = <span class="number">6.022e23</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    计算理想气体的压力，单位为帕斯卡</span></span><br><span class="line"><span class="string">     v -- 气体体积，单位为立方米</span></span><br><span class="line"><span class="string">        t -- 绝对温度，单位为开尔文</span></span><br><span class="line"><span class="string">        n -- 气体粒子</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    k = <span class="number">1.38</span>e - <span class="number">23</span>  <span class="comment">#玻尔兹曼常数</span></span><br><span class="line">    <span class="keyword">return</span> n * k * t / v </span><br></pre></td></tr></table></figure></div><p><code>=</code>符号在此等示例中表示两种不同的含义，具体取决于使用它的上下文。在def语句中,<code>=</code>不执行赋值，而是指示调用<code>pressure</code>函数时使用的默认值。相比之下，函数体中对<code>k</code>的赋值语句中将名称<code>k</code>与玻尔兹曼常数的近似值进行了绑定。</p><div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>pressure(<span class="number">1</span>, <span class="number">273.15</span>)</span><br><span class="line"><span class="number">2269.974834</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pressure(<span class="number">1</span>, <span class="number">237.15</span>, <span class="number">3</span> * <span class="number">6.022e23</span>)</span><br><span class="line"><span class="number">6809.924502</span></span><br></pre></td></tr></table></figure></div><p><code>pressure</code>函数的定义接受三个参数，但上面的第一个调用表达式中值提供了两个。在这种情况下，n的值取自<code>def</code>语句的默认值。如果提供了，那么默认值就会被忽略</p><p>作为准则，函数主体中使用的大多数数据值都应该表示为具名参数(named arguments)的默认值，这样会使他们更易于检查，并且可以被函数调用者更改。一些永远不会改变的值，例如基本常量k可以绑定在函数体或全局帧中。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-4-设计函数&quot;&gt;&lt;a href=&quot;#1-4-设计函数&quot; class=&quot;headerlink&quot; title=&quot;1.4 设计函数&quot;&gt;&lt;/a&gt;1.4 设计函数&lt;/h1&gt;&lt;p&gt;函数是所有程序(无论大小)的基本组成部分，并且是我们使用编程语言来表达计算过程的主要媒介。本</summary>
      
    
    
    
    <category term="CS61A" scheme="https://primeluoqiu.github.io/categories/CS61A/"/>
    
    
  </entry>
  
  <entry>
    <title>1.8历史</title>
    <link href="https://primeluoqiu.github.io/2024/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.8/"/>
    <id>https://primeluoqiu.github.io/2024/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.8/</id>
    <published>2024-03-27T12:03:09.041Z</published>
    <updated>2024-03-27T12:10:08.736Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/27/aeIYP5H3.jpg"                      alt="26.jpg"                ><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/27/O4212m1R.jpg"                      alt="27.jpg"                ><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/27/4wlj58Tf.jpg"                      alt="29.jpg"                ><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/27/9i4NYHEt.jpg"                      alt="30.jpg"                ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;https://img2.imgtp.com</summary>
      
    
    
    
    <category term="计网" scheme="https://primeluoqiu.github.io/categories/%E8%AE%A1%E7%BD%91/"/>
    
    
  </entry>
  
  <entry>
    <title>1.3定义新函数</title>
    <link href="https://primeluoqiu.github.io/2024/03/26/ClassesFormUCBerkely/CS61A/1.3%20%E5%AE%9A%E4%B9%89%E6%96%B0%E5%87%BD%E6%95%B0/"/>
    <id>https://primeluoqiu.github.io/2024/03/26/ClassesFormUCBerkely/CS61A/1.3%20%E5%AE%9A%E4%B9%89%E6%96%B0%E5%87%BD%E6%95%B0/</id>
    <published>2024-03-26T05:47:33.393Z</published>
    <updated>2024-03-27T14:07:05.154Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-3定义新函数"><a href="#1-3定义新函数" class="headerlink" title="1.3定义新函数"></a>1.3定义新函数</h1><p>通过对Python的了解，我们确定了强大的编程语言中会有一些必须出现的元素</p><ol><li>原始的内置数据和函数：数字和算术运算</li><li>组合方式：嵌套函数</li><li>受限的抽象方式：将名称与值绑定</li></ol><p>接下来的内容是函数定义，这是一种更强大的抽象技术，通过它可以将名称与复合操作绑定为一个单元。</p><p>首先来研究一下平方的概念。因为平方就是一个数乘它本身。这在Python中可以表示为</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">square</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> mul(x, x)</span><br></pre></td></tr></table></figure></div><p>上述定义了一个名为square的新函数，这个用户定义的函数并不会内置到解释器中，它表示将一个值和自身相乘的复合运算，定义时的括号里的x是作为被乘的东西的名称，称为<strong>形式参数</strong>， 同时也将此函数与<code>square</code>绑定。</p><p><strong>如何定义函数</strong>：函数定义包含<code>def</code>语句、<code>&lt;name 函数名&gt;</code>和一个以逗号分隔的<code>&lt;formal parameters形式参数&gt;</code>列表，然后是一个被称为函数体的<code>return</code>语句，它指定了调用函数时要计算的表达式，也就是函数的<code>&lt;return expression 返回表达式&gt;</code>：</p><div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> &lt;name&gt;(&lt;formal parameters&gt;):</span><br><span class="line">    <span class="keyword">return</span> &lt;<span class="keyword">return</span> expression&gt;</span><br></pre></td></tr></table></figure></div><p>函数的第二行<strong>必须</strong>进行缩进，大多数程序员使用四个空格。返回表达式会作为新定义的函数的一部分存储，并且在最终调用该函数时才进行求值。</p><p>定义了<code>square</code>之后，我们可以调用它：</p><div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>square(<span class="number">21</span>)</span><br><span class="line"><span class="number">441</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>square(add(<span class="number">2</span>, <span class="number">5</span>))</span><br><span class="line"><span class="number">49</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>square(square(<span class="number">3</span>))</span><br><span class="line"><span class="number">81</span></span><br></pre></td></tr></table></figure></div><p>我们还可以将<code>square</code>作为一个建构单元来定义其他函数。例如，我们可以很容易地定义一个函数<code>sum_squares</code>, 给定任意两个数字作为参数，返回他们的平方和：</p><div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">sum_squares</span>(<span class="params">x, y</span>)</span><br><span class="line"><span class="keyword">return</span> add(square(x), square(y))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sum_squares(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="number">25</span></span><br></pre></td></tr></table></figure></div><p>用户定义函数的使用方式与内置函数完全相同。实际上，从<code>sum_square</code>的定义中我们不能判断<code>square</code>是内置于解释器中，还是从模块中导入的，又或是用户定义的。</p><p><code>def</code>语句和赋值语句都将名称与值绑定，并且绑定后对于之前绑定的东西就会直接失效，也就是throw掉了，例如下述的<code>g</code>首先指的是一个没有参数的函数，然后是指一个数字，最后是一个含有两个参数的函数。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">g</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g()</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g = <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">g</span>(<span class="params">h, i</span>)</span><br><span class="line">reurn h + i</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g(<span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure></div><hr><h3 id="1-3-1-环境"><a href="#1-3-1-环境" class="headerlink" title="1.3.1 环境"></a>1.3.1 环境</h3><p>Python子集已经蛮复杂的，但是程序的含义还并不明显，如果形参与内置函数同名怎么办？两个函数可以共享名称而不混淆么？</p><p>求解表达式的环境由<strong>帧</strong>序列组成，他们可以被描述为一些盒子，每个帧都包含了一些<strong>绑定</strong>，他们将名称和对应的值相关联。<strong>全局帧(global frame)</strong> 只有一个。赋值和导入语句会将条目添加到当前环境的第一帧。目前，我们的环境仅由全局帧组成。<br>![[..&#x2F;..&#x2F;Pasted image 20240326211337.png]]<br>这个环境图显示了当前环境中的绑定，还有名称和值的绑定。(OnlinePythonTutor)[<a class="link"   href="https://www.composingprograms.com/tutor.html]%E4%B8%AD%E6%BC%94%E7%A4%BA%EF%BC%8C%E5%8F%AF%E4%BB%A5%E7%94%A8%E6%9D%A5%E6%9F%A5%E7%9C%8B%E7%8E%AF%E5%A2%83%E5%9B%BE" >https://www.composingprograms.com/tutor.html]中演示，可以用来查看环境图 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p>函数也会出现在环境图中。<code>import</code>语句将名称和内置函数绑定。<code>def</code>语句将名称与用户自定义的函数绑定。导入<code>mul</code>并定义<code>square</code>后的结果环境如下图所示：<br>![[..&#x2F;..&#x2F;Pasted image 20240326211659.png]]<br>每个函数都是一行，以<code>func</code>开头，后面是函数名称和形式参数。<code>mul</code>等内置函数没有正式的参数名称，所以都是使用<code>...</code>代替。<br>函数名称重复两次，一次在环境帧中，另一次是作为函数定义的一部分。函数定义中出现的名称叫做**内在名称(intrinsic name)<strong>，帧中的名称叫做</strong>绑定名称(bound name)**。两者之间有一个区别：不同的名称可能指的是同一个函数，但函数本身只有一个内在名称。</p><p>绑定到帧中的函数名称是在求值过程中使用，而内在名称在求职中不起作用。如下面的实例</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="built_in">max</span></span><br><span class="line"><span class="built_in">max</span> = <span class="number">3</span></span><br><span class="line">result = f(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="built_in">max</span>(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">#casue an error</span></span><br></pre></td></tr></table></figure></div><p>当<code>max</code>函数和数值3绑定之后，它就不能再用作函数<br>错误信息是<code>&quot;TypeError: &#39;int&#39; object is not callable&quot;</code>,报告了名称<code>max</code>(当前绑定到数字3)是一个整数而不是函数，所以它不能用作调用表达式中的运算符。</p><p><strong>函数签名</strong>：每个函数允许采用的参数数量有所不同。为了跟踪这些要求，我们绘制了每个函数的名称及其形式参数。用户定义的<code>square</code>只需要<code>x</code>一个参数，提供或多或少的参数都将导致错误。对函数形式参数的描述被称为函数的签名。</p><p>函数<code>max</code>可以接收任意数量的参数，所以它被呈现为<code>max(...)</code>。因为原始函数从未明确定义，所以无论采用多少个参数，所有的内置函数都将呈现为<code>&lt;name&gt;(...)</code></p><hr><h3 id="1-3-2调用用户定义的函数"><a href="#1-3-2调用用户定义的函数" class="headerlink" title="1.3.2调用用户定义的函数"></a>1.3.2调用用户定义的函数</h3><p>为了求出操作符为用户定义函数的调用表达式，Python解释器遵循了以下计算过程。与其他调用表达式一样，解释器将对操作符和操作数表达式求值，然后用生成的实参调用具名函数。</p><p>调用用户定义的函数会引入<code>局部帧(local frame)</code>，它只能访问该函数。通过一些实参调用用户定义的函数：</p><ol><li>在新的局部帧中，将实参绑定到函数的形参上。</li><li>在此以帧开始的环境中执行函数体。<br>求值函数体的环境由两个帧组成：一是包含形式参数绑定的局部帧，然后是包含其他所有内容的全局帧。函数的每个实例都有自己独立的局部帧。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-3定义新函数&quot;&gt;&lt;a href=&quot;#1-3定义新函数&quot; class=&quot;headerlink&quot; title=&quot;1.3定义新函数&quot;&gt;&lt;/a&gt;1.3定义新函数&lt;/h1&gt;&lt;p&gt;通过对Python的了解，我们确定了强大的编程语言中会有一些必须出现的元素&lt;/p&gt;
&lt;ol&gt;</summary>
      
    
    
    
    <category term="CS61A" scheme="https://primeluoqiu.github.io/categories/CS61A/"/>
    
    
  </entry>
  
  <entry>
    <title>1.7 协议层次和服务模型</title>
    <link href="https://primeluoqiu.github.io/2024/03/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.7/"/>
    <id>https://primeluoqiu.github.io/2024/03/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.7/</id>
    <published>2024-03-25T14:08:13.610Z</published>
    <updated>2024-03-27T12:10:17.105Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/25/N72p3fKJ.jpg"                      alt="21.jpg"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/25/Wi1mIyuc.jpg"                      alt="22.jpg"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/25/sSH1q9SA.jpg"                      alt="23.jpg"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/25/sSH1q9SA.jpg"                      alt="24.jpg"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/26/1i5XQqWi.jpg"                      alt="25.jpg"                ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;https://img2.imgtp.com</summary>
      
    
    
    
    <category term="计网" scheme="https://primeluoqiu.github.io/categories/%E8%AE%A1%E7%BD%91/"/>
    
    
  </entry>
  
  <entry>
    <title>计网第二个实验</title>
    <link href="https://primeluoqiu.github.io/2024/03/25/SchoolHomework/%E8%AE%A1%E7%BD%91/Experiment2/"/>
    <id>https://primeluoqiu.github.io/2024/03/25/SchoolHomework/%E8%AE%A1%E7%BD%91/Experiment2/</id>
    <published>2024-03-25T05:46:43.090Z</published>
    <updated>2024-03-27T12:10:45.128Z</updated>
    
    <content type="html"><![CDATA[<p>五、实验步骤                                      </p><p>1.数据规划（课程目标1）</p><p>表1-交换机VLAN划分及端口</p><table><thead><tr><th>设备名</th><th>VLAN编号</th><th>VLAN名称</th><th>端口范围</th><th>连接计算机</th></tr></thead><tbody><tr><td>LSW1</td><td>vlan 10</td><td>技术部</td><td>E 0&#x2F;0&#x2F;1 - E 0&#x2F;0&#x2F;2</td><td>PC1, PC3</td></tr><tr><td>LSW2</td><td>vlan 20</td><td>财务部</td><td>E 0&#x2F;0&#x2F;1 - E 0&#x2F;0&#x2F;2</td><td>PC2, PC4</td></tr></tbody></table><p>表2-PC计算机IP地址及端口信息</p><table><thead><tr><th>设备名</th><th>端口</th><th>IP地址信息</th><th>网关</th></tr></thead><tbody><tr><td>PC1</td><td>E 0&#x2F;0&#x2F;1</td><td>10.10.1.1</td><td>255.255.255.0</td></tr><tr><td>PC2</td><td>E 0&#x2F;0&#x2F;2</td><td>10.10.1.2</td><td>255.255.255.0</td></tr><tr><td>PC3</td><td>E 0&#x2F;0&#x2F;3</td><td>10.10.1.3</td><td>255.255.255.0</td></tr><tr><td>PC4</td><td>E 0&#x2F;0&#x2F;4</td><td>10.10.1.4</td><td>255.255.255.0</td></tr></tbody></table><p> 2.启动有eNSP模拟器，按实验要求和规划，搭建网络拓扑。（课程目标3）<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/25/trp0rx6s.png"                      alt="Pasted image 20240325105802.png"                ><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/25/zXYjCsX3.png"                      alt="Pasted image 20240325105819.png"                ><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/25/BT39huMp.png"                      alt="Pasted image 20240325105918.png"                ></p><p><strong>上图IP地址应为10.10.1.3，当时打错了，后面有纠正</strong></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/25/YWoj26hw.png"                      alt="Pasted image 20240325105929.png"                ></p><p>3.设备配置。（课程目标3）<br>本次配置比起实验一来说，就是多了对于两个交换机的控制，其余的配置都是一样的，当我们配置完每台PC的IP之后，我们就可以进入交换机进行配置了。<br>首先我们进入LSW(交换机1)，然后我们首先关闭之后可能会出现的提示信息</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">undo info-center enable</span><br></pre></td></tr></table></figure></div><p>接下来，我们首先配置第一个交换机所连接的两台PC和对应连接的一台交换机的端口。<br>操作还是和之前一样的操作</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sys</span><br><span class="line">vlan batch 10 20</span><br></pre></td></tr></table></figure></div><p>首先进入sys<br>然后创建两个vlan 10和20</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface G 0/0/1 //G是一种端口的名称，指千兆以太网端口，而上个实验的E指的是普通以太网端口</span><br><span class="line">port link-type access</span><br><span class="line">port default vlan 10</span><br></pre></td></tr></table></figure></div><p>这是第一台PC的配置</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface G 0/0/2</span><br><span class="line">port link-type access</span><br><span class="line">port default vlan 20</span><br></pre></td></tr></table></figure></div><p>这是第二台PC的配置<br>接下来是本实验的核心内容，就是配置24端口的两台交换机，使得他们可以通过vlan10 和 vlan20这两个线路。这样的话就可以连接起来这两台交换机了。</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface G 0/0/24</span><br><span class="line">port link-type trunk</span><br><span class="line">port trunk allow-pass vlan 10 20</span><br></pre></td></tr></table></figure></div><p>这样的话，这个交换机和交换机之间的线缆就可以通过10和20的接口了。<br>剩下的就是配置第二台交换机的配置，方法和上述方法一样，重复一下即可。</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">undo info-center enable</span><br><span class="line">sys</span><br><span class="line">vlan batch 10 20</span><br><span class="line">interface G 0/0/1 //G是一种端口的名称，指千兆以太网端口，而上个实验的E指的是普通以太网端口</span><br><span class="line">port link-type access</span><br><span class="line">port default vlan 10</span><br><span class="line">interface G 0/0/2</span><br><span class="line">port link-type access</span><br><span class="line">port default vlan 20</span><br><span class="line">interface G 0/0/24</span><br><span class="line">port link-type trunk</span><br><span class="line">port trunk allow-pass vlan 10 20</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/25/Wax8a7rI.png"                      alt="Pasted image 20240325114246.png"                ><br>我们不难看出vlan10和20这两个线路均有24接口通过。那么实验就完成了，接下来验证实验就可以了。</p><p>4.验证。（课程目标3）<br>PC2验证<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/25/nGHjP7zq.png"                      alt="Pasted image 20240325114548.png"                ><br>PC1配置<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/25/5fgk27XM.png"                      alt="Pasted image 20240325114813.png"                ><br>由图可知，pc1可以连3，2可以连4，这样的话我们的实验目的也就完成了</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/25/Eg8vjkjM.png"                      alt="Pasted image 20240325114956.png"                ><br>拓扑图如上。<br>六、实验心得或存在的问题（课程目标1)<br>本次实验学到了有关不同楼层的两台交换机之间应该如何配置，以至于达到楼层之间的互联而不与同楼层之间的互联。<br>本次实验还学习到了有关<code>link-type trunk</code>以及trunk接口是用于交换机之间连接的端口，trunk口可以1加入多个vlan，以及接收和发送多个Vlan的Tagged帧。<br>还了解到了G口是千兆以太网口，E口是以太网口的知识点。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;五、实验步骤                                      &lt;/p&gt;
&lt;p&gt;1.数据规划（课程目标1）&lt;/p&gt;
&lt;p&gt;表1-交换机VLAN划分及端口&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;设备名&lt;/th&gt;
&lt;th&gt;VLAN编号</summary>
      
    
    
    
    <category term="Expriment" scheme="https://primeluoqiu.github.io/categories/Expriment/"/>
    
    
  </entry>
  
  <entry>
    <title>Week4 and Daily Schedule</title>
    <link href="https://primeluoqiu.github.io/2024/03/24/%E6%AF%8F%E5%91%A8%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/Week4/"/>
    <id>https://primeluoqiu.github.io/2024/03/24/%E6%AF%8F%E5%91%A8%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/Week4/</id>
    <published>2024-03-24T13:23:47.317Z</published>
    <updated>2024-04-01T13:56:17.189Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Daily-Schedule"><a href="#Daily-Schedule" class="headerlink" title="Daily Schedule"></a>Daily Schedule</h1><h2 id="Total-Schedule"><a href="#Total-Schedule" class="headerlink" title="Total Schedule"></a>Total Schedule</h2><ol><li>《计算机网络》-郑铨老师的 1.7-2.2</li><li>CS61B Week 7- 10</li><li>CS61A 看完第二章</li><li>CSAPP 看完第二章</li><li>CS61C 前两周内容</li></ol><p>每天任务的话，先看周一吧，周一相对来说课不算多，下午有一节毛概，毛概课的话得补半节课的数电笔记和作业</p><h3 id="Monday"><a href="#Monday" class="headerlink" title="Monday"></a>Monday</h3><p>《计算机网络》 1.7</p><p>CS61A</p><p>CS61B</p><p>CSAPP</p><p>还得看点算法，要不都快要蓝桥杯考试了，顶不住了</p><p>目前先准备这些，看明天的收效，希望明天早上可以起得来然后走两圈锻炼锻炼。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Daily-Schedule&quot;&gt;&lt;a href=&quot;#Daily-Schedule&quot; class=&quot;headerlink&quot; title=&quot;Daily Schedule&quot;&gt;&lt;/a&gt;Daily Schedule&lt;/h1&gt;&lt;h2 id=&quot;Total-Schedule&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="大二下" scheme="https://primeluoqiu.github.io/categories/%E5%A4%A7%E4%BA%8C%E4%B8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>第三周总结</title>
    <link href="https://primeluoqiu.github.io/2024/03/24/%E6%AF%8F%E5%91%A8%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/%E7%AC%AC%E4%B8%89%E5%91%A8%E6%80%BB%E7%BB%93/"/>
    <id>https://primeluoqiu.github.io/2024/03/24/%E6%AF%8F%E5%91%A8%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/%E7%AC%AC%E4%B8%89%E5%91%A8%E6%80%BB%E7%BB%93/</id>
    <published>2024-03-24T13:07:37.059Z</published>
    <updated>2024-03-24T13:34:07.396Z</updated>
    
    <content type="html"><![CDATA[<p>本周学习任务完成情况：</p><ol><li>郑铨《计算机网络》:已看完1.6，还差一节视频</li><li>CS61B 目标未完成，达成率 0</li><li>CS61A 仅仅看了1.4之前的，还差一章</li><li>CSAPP：差一节的知识点和两节的对于知识点的总结</li><li>CS61C：甚至还没看课</li></ol><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>怎么说呢，本周的事情相对来说比较多，很多时候为了处理一些事情不得不去花费一晌的时间。究其根本的话还是因为考虑的事情太多太繁杂，像极了酷安的那张经典图片，某物在拥有前，拥有时，以及拥有后的心情状态。</p><p>其实有的时候也是，覆水难收是肯定的事情，硬要做一些可能看起来不是那么的合常理的事情的时候，往往就会产生很多负面的因素，谁能想到收到的手机会是一个被拿去抵债的手机呢。不过其实经此一事的话，二手的市场还真的水深，得亏是那个老哥很好说话，再加上我的态度也是非常的到位，以至于目前来说似乎并没有产生什么不和平的因素。就感觉也还好。本周这种事情占得时间还是蛮多的。课程的任务量其实也还好，就是笔记和每周的作业。感觉也还OK，起码目前基本上emm也算是个应付的态势吧</p><p>有的时候还是心不静，心乱的话效率也不会很高。每次学习的时候也不妨像他们一样手机扣一下，然后就在一边放着。电脑端挂个微信就行，不过似乎我好像也不会被别人找的样子hhh</p><p>这两周的锻炼还算是有所成效，减重了一些，但不多，想要减重还是得每天坚持锻炼，然后规律作息、规律作息、规律作息，重要的事情说三遍hhh，早上倒也还是能起得来，就是太困了，归根结底还是晚上睡的太晚，十二点半左右能睡的话第二天的精神状态想必就会好很多了。早上起来之后的感觉也不会太困。</p><p>啧，其实有的时候也在想，如果我要不是天天学习，或者说如果我真的把这大学四年荒废过去会怎么样，虽然我妈对我的要求确实不高，也就是混口饭吃的程度。不过再怎么说都是要勤奋的，无论是在后面的学习上，还是之后的找工作上。去哪里，找什么样的工作，这些虽然都是后话，但是也是在茫然之中会考虑到的一些事情。</p><p>时间…时间…</p><p>还有多久呢…</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本周学习任务完成情况：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;郑铨《计算机网络》:已看完1.6，还差一节视频&lt;/li&gt;
&lt;li&gt;CS61B 目标未完成，达成率 0&lt;/li&gt;
&lt;li&gt;CS61A 仅仅看了1.4之前的，还差一章&lt;/li&gt;
&lt;li&gt;CSAPP：差一节的知识点和两节的对于知识</summary>
      
    
    
    
    <category term="大二下" scheme="https://primeluoqiu.github.io/categories/%E5%A4%A7%E4%BA%8C%E4%B8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>CSAPP Chapter1.7 硬件被谁管理啊</title>
    <link href="https://primeluoqiu.github.io/2024/03/24/CSAPP/%E7%AC%AC%E4%B8%80%E7%AB%A0/1.7%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E7%A1%AC%E4%BB%B6/"/>
    <id>https://primeluoqiu.github.io/2024/03/24/CSAPP/%E7%AC%AC%E4%B8%80%E7%AB%A0/1.7%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E7%A1%AC%E4%BB%B6/</id>
    <published>2024-03-24T02:51:49.635Z</published>
    <updated>2024-03-24T02:43:36.991Z</updated>
    
    <content type="html"><![CDATA[<p>从hello的例子可以可以看出来，当shell加载运行包括最后输出的时候，shell和hello都没有直接对硬件进行访问(包括键盘，显示器，主存或者磁盘)。取而代之的是，他们依靠操作系统提供的服务。我们可以把操作系统看成是应用程序和硬件之间插入的一层软件。所有应用程序对硬件的操作尝试都必须通过操作系统<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/24/XDgvCQG1.png"                      alt="Pasted image 20240320002837.png"                ><br>操作系统有两个基本功能，</p><ol><li>防止硬件被失控的应用程序滥用</li><li>向应用程序提供简单一致的机制来控制复杂而又通常大不相同的低级硬件设备。</li></ol><p>操作系统通过几个基本的抽象概念(<strong>进程</strong>、<strong>虚拟内存</strong>和<strong>文件</strong>)来实现这两个功能，如下图所示，文件是对I&#x2F;O设备的抽象表示，虚拟内存是对主存和磁盘I&#x2F;O设备的抽象表示，进程则是对处理器、主存和I&#x2F;O设备的抽象表示<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/24/cavhFdDj.png"                      alt="Pasted image 20240320003206.png"                ></p><h4 id="1-7-1-进程"><a href="#1-7-1-进程" class="headerlink" title="1.7.1 进程"></a>1.7.1 进程</h4><p>像hello这样的程序在现代系统上运行时，操作系统会提供一种假象，就像系统上只有这个程序在运行。程序看上去是独占地只用处理器、主存和I&#x2F;O设备。处理器看上去就像在不间断的一条接一条地执行程序中的指令，即该程序的代码和数据是系统内存中唯一的对象。这些假象是通过进程的概念来实现的，进程是计算机科学中最重要和最成功的概念之一。</p><p><strong>进程</strong>是操作系统对一个正在运行的程序的一种抽象。在一个系统上可以同时运行多个进程，而每个进程都好像在独占的使用硬件。而<strong>并发运行</strong>，则是说一个进程的指令和另一个进程的指令是交错执行的。在大多数系统中，需要运行的进程数是多于可以运行它们的CPU个数的。传统系统在一个时刻只能执行一个程序，而先进的<strong>多核</strong>处理器同时能够执行多个程序。无论是在单核还是多核系统中，一个CPU看上去都像是在并发地执行多个进程，这是通过处理器在进程间切换来实现的。操作系统实现这种操作执行的机制称为<strong>上下文交换</strong>。为了简化讨论，我们只考虑包含一个CPU的<strong>单处理器系统</strong>的情况。后面还会讨论</p><p>操作系统保持跟踪进程运行所需的所有状态信息。这种状态，也就是<strong>上下文</strong>，包括许多信息，比如PC和寄存器文件的当前值，以及主存的内容。在任何一个时刻，单处理器系统都只能执行一个进程的代码。当操作系统决定要把控制权从当前进程转移到某个新进程时，就会进行上下文切换，即保存当前进程的上下文、恢复新进程的上下文，然后将控制权传递到新进程。新进程就会从它上次停止的地方开始。那么hello程序运行场景的基本理念看下面。<br>![[<a class="link"   href="https://hansimov.gitbook.io/~gitbook/image?url=https://4154149387-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%252F-MHt_spaxGgCbp2POnfq%252F-MHzietxOnE2XCBTZHJ7%252F-MHziqrI26zhGJA9_NLL%252F01-12%2520%25E8%25BF%259B%25E7%25A8%258B%25E7%259A%2584%25E4%25B8%258A%25E4%25B8%258B%25E6%2596%2587%25E5%2588%2587%25E6%258D%25A2.png?alt=media&token=5df4420b-e3c7-46ca-8192-ba207aa49f15&width=400&dpr=3&quality=100&sign=7323c7a530eb087f04ecfa52db5f03b77529e0c73a5744a490b2389fecb6b30ehttps://hansimov.gitbook.io/~gitbook/image?url=https://4154149387-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%252F-MHt_spaxGgCbp2POnfq%252F-MHzietxOnE2XCBTZHJ7%252F-MHziqrI26zhGJA9_NLL%252F01-12%2520%25E8%25BF%259B%25E7%25A8%258B%25E7%259A%2584%25E4%25B8%258A%25E4%25B8%258B%25E6%2596%2587%25E5%2588%2587%25E6%258D%25A2.png?alt=media&token=5df4420b-e3c7-46ca-8192-ba207aa49f15&width=400&dpr=3&quality=100&sign=7323c7a530eb087f04ecfa52db5f03b77529e0c73a5744a490b2389fecb6b30e%5D%5D" >https://hansimov.gitbook.io/~gitbook/image?url=https:%2F%2F4154149387-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-legacy-files%2Fo%2Fassets%252F-MHt_spaxGgCbp2POnfq%252F-MHzietxOnE2XCBTZHJ7%252F-MHziqrI26zhGJA9_NLL%252F01-12%2520%25E8%25BF%259B%25E7%25A8%258B%25E7%259A%2584%25E4%25B8%258A%25E4%25B8%258B%25E6%2596%2587%25E5%2588%2587%25E6%258D%25A2.png%3Falt=media%26token=5df4420b-e3c7-46ca-8192-ba207aa49f15&amp;width=400&amp;dpr=3&amp;quality=100&amp;sign=7323c7a530eb087f04ecfa52db5f03b77529e0c73a5744a490b2389fecb6b30ehttps://hansimov.gitbook.io/~gitbook/image?url=https:%2F%2F4154149387-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-legacy-files%2Fo%2Fassets%252F-MHt_spaxGgCbp2POnfq%252F-MHzietxOnE2XCBTZHJ7%252F-MHziqrI26zhGJA9_NLL%252F01-12%2520%25E8%25BF%259B%25E7%25A8%258B%25E7%259A%2584%25E4%25B8%258A%25E4%25B8%258B%25E6%2596%2587%25E5%2588%2587%25E6%258D%25A2.png%3Falt=media%26token=5df4420b-e3c7-46ca-8192-ba207aa49f15&amp;width=400&amp;dpr=3&amp;quality=100&amp;sign=7323c7a530eb087f04ecfa52db5f03b77529e0c73a5744a490b2389fecb6b30e]] <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br>实例当中有两个并发的进程：shell和hello。最开始，只有shell进程在运行，也就是等待命令行上的输入。当我们让他运行hello程序时，shell通过一个专门的函数，也就是系统调用，来执行我们的请求，系统调用会将控制权传递给操作系统。操作系统保存shell进程的上下文，创建一个新的hello进程及其上下文，并将控制权传回给它，shell进程会继续等待下一个命令行输入。</p><p>如图所示，从一个进程到另一个进程的转换是由操作系统<strong>内核(kernel)</strong> 管理的。内核是操作系统代码常驻主存的部分。当应用程序需要操作系统的某些操作时，比如读写文件，它就执行一条特殊的<strong>系统调用(system call)</strong> 指令，将控制权传递给内核。然后内核执行被请求的操作并返回应用程序。注意，内核不是一个独立的进程。相反，它是系统管理全部进程所用代码和数据结构的集合。</p><p>实现进程这个抽象概念需要低级硬件和操作系统软件之间的紧密合作。</p><h4 id="1-7-2-线程"><a href="#1-7-2-线程" class="headerlink" title="1.7.2 线程"></a>1.7.2 线程</h4><p>尽管通常我们认为一个进程只有单一的控制流，但是在现在系统中，一个进程实际上可以由多个称为<strong>线程</strong>的执行单元组成，每个线程都运行在进程的上下文中，并共享的代码和全局数据。由于网络服务器中对并行处理的需求，线程称为越来越重要的编程模型，因为多线程之间比多进程之间更容易共享数据，也因为线程一般来说都比进程更高效。当有多处理器可用的时候，多线程也是一种使得程序可以运行得更快的方法，我们将在后面讨论</p><h4 id="1-7-3-虚拟内存"><a href="#1-7-3-虚拟内存" class="headerlink" title="1.7.3 虚拟内存"></a>1.7.3 虚拟内存</h4><p>虚拟内存是一个抽象概念，它为每一个进程提供了一个假象，即每个进程都在独占地使用主存。每个进程看到的内存都是一致的，称为虚拟地址空间。下图所示的Linux进程的虚拟地址空间(其他Unix系统的设计也与此类似)。在Linux中，地址空间最上面的区域是保留给操作系统中的代码和数据的，这对所有进程来说都一样。地址空间的底部区域存放用户进程定义的代码和数据。图中的地址是从下往上增大的。<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/24/s6u5UnTl.png"                      alt="Pasted image 20240322170742.png"                ><br>每个进程看到的虚拟地址空间由大量准确定义的区构成，每个区都有专门的功能。先做简单的了解，逐步向上介绍</p><ul><li><strong>程序代码和数据</strong>：对所有的进程来说，代码是从同一固定地址开始，紧接着的是C全局变量相对应的数据位置。代码和数据区是直接按照可执行目标文件的内容初始化的，在示例中就是可执行文件hello。</li><li><strong>堆</strong>：代码和数据区后紧随的是运行时堆。代码和数据区在进程一开始运行时就被指定了大小，与此不同，当调用像malloc和free这样的C标准库函数的时候，堆可以在运行时动态地扩展和收缩。</li><li><strong>共享库</strong>：大约在地址空间的中间部分是一块用来存放像C标准库和数学库这样的共享库的代码和数据的区域。共享库的概念非常强大，也相当难懂。</li><li><strong>栈</strong>：位于用户虚拟地址空间顶部的是<strong>用户栈</strong>，编译器用它来实现函数调用。和堆一样，用户栈在程序执行期间可以动态地扩展和收缩。特别的，每次我们调用一个函数时，栈就会增长；从一个函数返回时，栈就会收缩。</li><li><strong>内核虚拟内存</strong>：地址空间顶部的区域是为内核保留的。不允许应用程序读写这个区域的内容或者直接调用内核代码定义的函数。相反，它们必须调用内核来执行这些操作。</li></ul><p>虚拟内存的运作需要硬件和操作系统软件之间精密复杂的交互，包括对处理器生成的每个地址的硬件翻译。基本思想是把一个进程虚拟内存存储在磁盘上，然后用主存作为磁盘的高速缓存。</p><h4 id="1-7-4-文件"><a href="#1-7-4-文件" class="headerlink" title="1.7.4 文件"></a>1.7.4 文件</h4><p><strong>文件</strong>就是字节序列，仅此而已。每个I&#x2F;O设备，包括磁盘、键盘、显示器甚至网络，都可以看成是文件。系统中的所有输入输出都是通过使用一小组称为Unix I&#x2F;O的系统调用读写文件来实现的。</p><p>文件这个简单而精致的概念是十分强大的，因为它向应用程序提供了一个统一的视图，来看待系统中可能含有的所有各式各样的I&#x2F;O设备。例如，处理磁盘文件内容的应用程序员可以非常幸福，因为他们无需了解具体的磁盘技术。进一步说，同一个程序可以在使用不同磁盘技术的不同系统上运行。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;从hello的例子可以可以看出来，当shell加载运行包括最后输出的时候，shell和hello都没有直接对硬件进行访问(包括键盘，显示器，主存或者磁盘)。取而代之的是，他们依靠操作系统提供的服务。我们可以把操作系统看成是应用程序和硬件之间插入的一层软件。所有应用程序对硬件</summary>
      
    
    
    
    <category term="CSAPP" scheme="https://primeluoqiu.github.io/categories/CSAPP/"/>
    
    
  </entry>
  
  <entry>
    <title>CSAPP Chapter1.6 存储设备形成也是有结构的</title>
    <link href="https://primeluoqiu.github.io/2024/03/24/CSAPP/%E7%AC%AC%E4%B8%80%E7%AB%A0/1.6%E5%AD%98%E5%82%A8%E8%AE%BE%E5%A4%87%E5%BD%A2%E6%88%90%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/"/>
    <id>https://primeluoqiu.github.io/2024/03/24/CSAPP/%E7%AC%AC%E4%B8%80%E7%AB%A0/1.6%E5%AD%98%E5%82%A8%E8%AE%BE%E5%A4%87%E5%BD%A2%E6%88%90%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/</id>
    <published>2024-03-24T02:51:49.634Z</published>
    <updated>2024-03-24T02:40:48.774Z</updated>
    
    <content type="html"><![CDATA[<p>也就是说，在处理器中和一个较大较慢的设备(例如主存)之间插入要给更小更快的存储设备(例如高缓)的想法已经成为一个普遍的观念。实际上，每个计算机中的存储设备都被组织成了一个存储器层次结构，如图所示<br>![[<a class="link"   href="https://hansimov.gitbook.io/~gitbook/image?url=https://4154149387-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%252F-MHt_spaxGgCbp2POnfq%252F-MHzhX2vrq6mFP3tN9EU%252F-MHzi1Edm9hUsnQdAkkL%252F01-09%2520%25E4%25B8%2580%25E4%25B8%25AA%25E5%25AD%2598%25E5%2582%25A8%25E5%2599%25A8%25E5%25B1%2582%25E6%25AC%25A1%25E7%25BB%2593%25E6%259E%2584%25E7%259A%2584%25E7%25A4%25BA%25E4%25BE%258B.png?alt=media&token=afb8208e-17dc-475f-9f61-acf0bd0ca891&width=400&dpr=3&quality=100&sign=17fc4e7af9f4033010d24045648add7168e149dc6885e9e1a1730033b06fd7f2%5D%5D" >https://hansimov.gitbook.io/~gitbook/image?url=https:%2F%2F4154149387-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-legacy-files%2Fo%2Fassets%252F-MHt_spaxGgCbp2POnfq%252F-MHzhX2vrq6mFP3tN9EU%252F-MHzi1Edm9hUsnQdAkkL%252F01-09%2520%25E4%25B8%2580%25E4%25B8%25AA%25E5%25AD%2598%25E5%2582%25A8%25E5%2599%25A8%25E5%25B1%2582%25E6%25AC%25A1%25E7%25BB%2593%25E6%259E%2584%25E7%259A%2584%25E7%25A4%25BA%25E4%25BE%258B.png%3Falt=media%26token=afb8208e-17dc-475f-9f61-acf0bd0ca891&amp;width=400&amp;dpr=3&amp;quality=100&amp;sign=17fc4e7af9f4033010d24045648add7168e149dc6885e9e1a1730033b06fd7f2]] <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br>在这个层次结构中，从上到下，设备之间的访问速度越来越慢，容量越来越大，并且每字节的造价也越来越低。寄存器文件在层次结构中位于最顶层，也就是第0级或者L0，主存在第4存…</p><p>存储器层次结构的主要思想是上一层的存储器作为低一层存储器的高速缓存。因此寄存器文件就是L1的高速缓存，L1是L2的高速缓存..在某些具有分布式文件系统的网络系统中，本地磁盘就是存储在其他系统中磁盘上的数据的高速缓存。正如可以运用不同的高速缓存的知识来提高程序性能一样，程序员同样可以利用对整个存储器层次结构的理解来提高程序性能。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;也就是说，在处理器中和一个较大较慢的设备(例如主存)之间插入要给更小更快的存储设备(例如高缓)的想法已经成为一个普遍的观念。实际上，每个计算机中的存储设备都被组织成了一个存储器层次结构，如图所示&lt;br&gt;![[&lt;a class=&quot;link&quot;   href=&quot;https://h</summary>
      
    
    
    
    <category term="CSAPP" scheme="https://primeluoqiu.github.io/categories/CSAPP/"/>
    
    
  </entry>
  
  <entry>
    <title>CSAPP Chapter1.5 多来点高速缓存嘛</title>
    <link href="https://primeluoqiu.github.io/2024/03/24/CSAPP/%E7%AC%AC%E4%B8%80%E7%AB%A0/1.5%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E8%87%B3%E5%85%B3%E9%87%8D%E8%A6%81/"/>
    <id>https://primeluoqiu.github.io/2024/03/24/CSAPP/%E7%AC%AC%E4%B8%80%E7%AB%A0/1.5%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E8%87%B3%E5%85%B3%E9%87%8D%E8%A6%81/</id>
    <published>2024-03-24T02:51:49.633Z</published>
    <updated>2024-03-24T02:40:19.983Z</updated>
    
    <content type="html"><![CDATA[<p>上述简单的运行过程中，我们不难发现系统花费了大量的时间把信息从一个地方挪到另一个地方。例如hello最初放在磁盘上，当程序加载的时候，被复制到主存，最后从主存上复制到显示设备。复制总是需要随时间的。这些复制就是开销，所以系统设计者的一个主要目标就是使这些复制操作尽可能快的完成。</p><p>根据机械原理，较大的存储设备要比比较小的存储设备运行的慢，而快速设备的造价远高于同类的低速设备，比如说，一个典型系统上的磁盘驱动器可能比主存大1000倍，但是对处理器而言，从磁盘驱动器上读取一个字的时间开销要比从主存中的开销大1000万倍。</p><p>类似得，一个典型的寄存器文件只存储几百byte的信息，而主存里面可以存放几十亿字节。然而，处理器从寄存器文件中读数据比从主存中读取几乎要快100倍，而且随着半导体技术的进步，处理器和主存之间的差距还在增大。加快处理器的运行速度比加快主存的运行速度要容易和便宜得多。针对这种处理器和主存之间的差异，系统设计者就采用了更小更快的存储设备，称为<strong>高速缓存存储器</strong>(cache memory, 简称cache或高速缓存)，作为暂时的集结区域，存放处理器近期可能需要的信息。<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/03/24/Z51UmPNz.png"                      alt="Pasted image 20240318151011.png"                ><br>这是一个典型系统中的高速缓存存储器，位于CPU上的L1高速缓存的荣富良可以达到数万字节。访问速度几乎和访问寄存器文件一样快。一个容量为数十万到百万字节的更大的L2告诉换曾黁通过一条特殊的总线连接到CPU。</p><p>进程访问L2高速缓存的时间要比访问L1告诉换从的时间长5倍，但是这仍然比访问主存的时间快5-10倍。L1和L2告诉换从使用一种叫做<strong>静态随机访问存储器</strong>的硬件技术实现的。比较新的，处理能力更强大的系统甚至有三级高速缓存：L1、L2、L3.系统可以获得一个很大的存储器，同时访问速度也很快，原因是利用了高速缓存的局部性原理，即<strong>程序具有访问局部区域里的数据和代码的趋势</strong>。通过让高速缓存里存放可能经常访问的数据，大部分的内存操作都能在快速的高速缓存中完成。<br>![[Pasted image 20240318151738.png]]</p><p>本书得出的重要结论之一就是，意识到高速缓存存储器存在的应用程序员能够利用高速缓存将程序的的性能提升一个数量级。</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;上述简单的运行过程中，我们不难发现系统花费了大量的时间把信息从一个地方挪到另一个地方。例如hello最初放在磁盘上，当程序加载的时候，被复制到主存，最后从主存上复制到显示设备。复制总是需要随时间的。这些复制就是开销，所以系统设计者的一个主要目标就是使这些复制操作尽可能快的完</summary>
      
    
    
    
    <category term="CSAPP" scheme="https://primeluoqiu.github.io/categories/CSAPP/"/>
    
    
  </entry>
  
</feed>
