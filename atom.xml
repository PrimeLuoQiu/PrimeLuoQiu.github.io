<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>秋过冬漫长</title>
  
  <subtitle>没有比脚更长的路,走过去就好了</subtitle>
  <link href="https://primeluoqiu.github.io/atom.xml" rel="self"/>
  
  <link href="https://primeluoqiu.github.io/"/>
  <updated>2024-04-22T16:33:10.541Z</updated>
  <id>https://primeluoqiu.github.io/</id>
  
  <author>
    <name>LuoQiu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>计网第二个实验</title>
    <link href="https://primeluoqiu.github.io/2024/04/23/SchoolHomework/%E8%AE%A1%E7%BD%91/Experiment3/"/>
    <id>https://primeluoqiu.github.io/2024/04/23/SchoolHomework/%E8%AE%A1%E7%BD%91/Experiment3/</id>
    <published>2024-04-22T16:31:51.392Z</published>
    <updated>2024-04-22T16:33:10.541Z</updated>
    
    <content type="html"><![CDATA[<h1 id="实验三"><a href="#实验三" class="headerlink" title="实验三"></a>实验三</h1><p>五、实验步骤                    </p><p>1.数据规划（课程目标1）</p><p>表1-交换机VLAN划分及端口</p><table><thead><tr><th>设备</th><th>VLAN编号</th><th>端口范围</th><th>IP地址&#x2F;端口模式</th></tr></thead><tbody><tr><td>S5700</td><td>vlan 10 20</td><td>G 0&#x2F;0&#x2F;1 - G 0&#x2F;0&#x2F;2</td><td>串口</td></tr><tr><td>S3700</td><td>vlan 10&#x2F;20</td><td>E 0&#x2F;0&#x2F;1 - 0&#x2F;0&#x2F;2 G 0&#x2F;0&#x2F;1</td><td>单通</td></tr></tbody></table><p>表2-PC计算机IP地址及端口信息</p><table><thead><tr><th>设备</th><th>端口</th><th>IP地址信息</th><th>网关</th></tr></thead><tbody><tr><td>PC1</td><td>E 0&#x2F;0&#x2F;1</td><td>DHCP自动获取</td><td>DHCP自动获取</td></tr><tr><td>PC2</td><td>E 0&#x2F;0&#x2F;1</td><td>DHCP自动获取</td><td>DHCP自动获取</td></tr><tr><td>PC3</td><td>E 0&#x2F;0&#x2F;1</td><td>DHCP自动获取</td><td>DHCP自动获取</td></tr><tr><td>PC4</td><td>E 0&#x2F;0&#x2F;1</td><td>DHCP自动获取</td><td>DHCP自动获取</td></tr></tbody></table><p> 2.启动有eNSP模拟器，按实验要求和规划，搭建网络拓扑。（课程目标3）</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="C:\Users\LuoQiu\AppData\Roaming\Typora\typora-user-images\image-20240422231008790.png"                      alt="image-20240422231008790"                ></p><p>3.设备配置。（课程目标3）</p><p>通过官网内容可以得出，DHCP(Dynamic Host Configuration Protocol)主要目的是在于移动终端想要即插即用，不需要修改终端的IP等网络参数。那么实际上，也就是说应该在<strong>汇聚层</strong>的用户网关中配置DHCP来给终端分配IP地址等网络参数</p><p>动态主机配置协议DHCP（Dynamic Host Configuration Protocol）采用客户端&#x2F;服务器模式( 指分配的是服务器，分配的设备是客户端) 对用户的网络参数进行动态配置和集中管理。其中，DHCP服务器通过地址池为用户分配IP地址等网络参数。地址池分为接口地址池和全局地址池两种。</p><p>接口地址池配置方式简单，只能用于<strong>用户DHCP服务器在同一网段的场景</strong>，且只能给对应接口下的用户分配IP地址等网络参数；适用于设备有限、配置以及维护量可控的小型网络。在用户网关设备上基于接口地址池的DHCP服务器功能之后，对应接口下的固定主机、移动终端等都可以获得IP地址等网络参数，不需用户手动更改。</p><p>与接口地址池相比，全局地址池可应用于大型网络，推荐在核心层设备上配置基于全局地址池的DHCP服务器功能或在服务器区域搭建一台专门的DHCP服务器统一分配IP地址等网络参数，而用户网关设备上只需要启用简单的DHCP中继功能即可。</p><p><strong>配置思路</strong></p><p>基于全局的DHCP服务的配置思路如下：</p><p>通过在最上层的switch上配置DHCP服务器，实现为企业两个网段内的终端动态分配IP地址</p><p>操作步骤</p><p>1开通DHCP服务，</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">system-view</span><br><span class="line">sysname Switch</span><br><span class="line">dhcp enable</span><br></pre></td></tr></table></figure></div><p>2.配置接口加入VLAN</p><p>首先是G1和G2 分别加入vlan10和20</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vlan batch 10 20</span><br><span class="line">port link-type access</span><br><span class="line">port default vlan 10</span><br><span class="line">interface G 0/0/2</span><br><span class="line">port link-type access</span><br><span class="line">port default vlan 20</span><br></pre></td></tr></table></figure></div><p>3.配置VLANIF接口IP地址</p><p>首先，我们要知道vlanif是用来干什么的：VLANIF接口(C&#x2F;S模式)是基于VLAN的三层逻辑接口，可以配置IP地址(一个网段的IP)。划分VLAN后，同一VLAN内的用户可以互相通信，但是属于不同VLAN的用户不能直接通信。</p><p>分别是VLANIF10和20，也就是刚刚创建的两个VLAN</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">interface vlanif 10</span><br><span class="line">ip address 10.10.1.1 24 //为固定终端的网段</span><br><span class="line">q</span><br><span class="line"></span><br><span class="line">interface vlanif 20</span><br><span class="line">ip address 10.10.2.1 24 //另一个网段</span><br><span class="line">q</span><br></pre></td></tr></table></figure></div><p>4.配置全局地址池</p><p> #先配置全局地址池pool1中的IP地址和相关网络参数</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ip pool pool1</span><br><span class="line">network 10.10.1.0 mask 24  //配置IP地址池</span><br><span class="line">dns-list 114.114.114.114   //配置DNS，即域名解析系统，为的是可以通过该系统访问到这个主机所在的地域</span><br><span class="line">gate-way list 10.10.1.1    //配置网关，也就是通过这个地址访问出去，外面的也从这个地址进来。</span><br><span class="line">q</span><br><span class="line"></span><br><span class="line">ip pool pool2  //和上面相同配置</span><br><span class="line">network 10.10.2.0 mask 24</span><br><span class="line">dns-list 114.114.114.114</span><br><span class="line">gate-way list 10.10.2.1 </span><br><span class="line">q</span><br></pre></td></tr></table></figure></div><p>5.使能DHCP服务器</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">interface vlanif 10</span><br><span class="line">dhcp select global</span><br><span class="line">q</span><br><span class="line"></span><br><span class="line">interface vlanif 20</span><br><span class="line">dhcp select global</span><br><span class="line">q</span><br></pre></td></tr></table></figure></div><p>五.验证。（课程目标3）</p><p>上面结束之后就可以进行验证了</p><p>分别在PC1，2，3，4上使用ipconfig进行ip相关信息的查看，然后再用ping来查看是否和vlan20的进行连通。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="C:\Users\LuoQiu\AppData\Roaming\Typora\typora-user-images\image-20240423002600574.png"                      alt="image-20240423002600574"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="C:\Users\LuoQiu\AppData\Roaming\Typora\typora-user-images\image-20240423002621936.png"                      alt="image-20240423002621936"                ></p><p>六、实验心得或存在的问题（课程目标1）</p><p>实验内容还是很简单的，主要是对于过程的了解以及vlanif的使用，还有就是对三层交换机的内容的理解。然后就是对于配置全局地址池的内容进行了解。主要是对于DHCP的理解和相关操作。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;实验三&quot;&gt;&lt;a href=&quot;#实验三&quot; class=&quot;headerlink&quot; title=&quot;实验三&quot;&gt;&lt;/a&gt;实验三&lt;/h1&gt;&lt;p&gt;五、实验步骤                    &lt;/p&gt;
&lt;p&gt;1.数据规划（课程目标1）&lt;/p&gt;
&lt;p&gt;表1-交换机VLAN划</summary>
      
    
    
    
    <category term="Expriment" scheme="https://primeluoqiu.github.io/categories/Expriment/"/>
    
    
  </entry>
  
  <entry>
    <title>局域网和城域网</title>
    <link href="https://primeluoqiu.github.io/2024/04/22/%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B%E5%B8%88/%E5%B1%80%E5%9F%9F%E7%BD%91%E5%92%8C%E5%9F%8E%E5%9F%9F%E7%BD%91/"/>
    <id>https://primeluoqiu.github.io/2024/04/22/%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B%E5%B8%88/%E5%B1%80%E5%9F%9F%E7%BD%91%E5%92%8C%E5%9F%8E%E5%9F%9F%E7%BD%91/</id>
    <published>2024-04-22T15:22:02.696Z</published>
    <updated>2024-04-22T15:23:41.592Z</updated>
    
    <content type="html"><![CDATA[<h1 id="局域网和城域网"><a href="#局域网和城域网" class="headerlink" title="局域网和城域网"></a>局域网和城域网</h1><p>最常考点:CSMA&#x2F;CD 、VLAN 、 STP</p><h2 id="局域网体系与拓扑结构"><a href="#局域网体系与拓扑结构" class="headerlink" title="局域网体系与拓扑结构"></a>局域网体系与拓扑结构</h2><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/04/19/zWGjZM4w.png"                      alt="18.png"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/04/19/eQg4COy9.png"                      alt="19.png"                ></p><h2 id="CSMA-CD与监听算法"><a href="#CSMA-CD与监听算法" class="headerlink" title="CSMA&#x2F;CD与监听算法"></a>CSMA&#x2F;CD与监听算法</h2><p>对于总线型、星形和树形拓扑访问控制协议是CSMA&#x2F;CS(Carrier Sense Multiple Access&#x2F;Collision Detection)</p><ul><li>CSMA基本原理：发送数据之前，先监听信道上是否有人在发送，若有，说明信道正忙，否则空闲，然后根据预定的策略决定<ul><li>若信道空闲，是否立即发送</li><li>若信道忙，是否继续监听</li></ul></li><li>如果连续发生<strong>16</strong>次碰撞后，认为网络繁忙有问题，不再尝试发送</li></ul><p>三种监听算法</p><ol><li>非坚持型监听算法：后退随机时间</li></ol><p>由于随机时延后退，从而减少了冲突的概率。问题是因为后退而使信道闲置一段时间，这使信道的利用率降低，而且增加了发送时延，类似蹲坑，但是坑有人，选择出去憋一会再等等</p><ol start="2"><li>1-坚持型监听算法：继续监听，不等待</li></ol><p>有利于抢占信道，减少信道空闲时间。但是多个站同时都在监听信道时必然会发生冲突。<em>冲突概率和利用率都高(双高）</em> 不等人，敲门催促</p><ol start="3"><li><p>P-坚持型监听算法</p><p>若信道空闲，以概率P发送，以概率(1-P)延迟一个时间单位，P大小可调整。</p></li></ol><p>【2011年下】以太网介质访问控制策略可以采取不同的监听算法，其中一种是：“一旦介质空闲就发送数据，假如介质忙，继续监听，直到介质空闲后立即发送数据”这种算法称为()监听算法，该算法的主要特点是()</p><p>A.1-坚持型 B.非坚持性 C.P-坚持型 D.0-坚持型</p><p>A.介质利用率和冲突概率都低 B.介质利用率和冲突概率都高</p><p>C.介质利用率低且无法避免冲突 D.介质利用率高且可以有效避免冲突</p><p>【2015下】以下关于CSMA&#x2F;CD协议的叙述中，正确的是()</p><p>A.每个节点按照逻辑顺序占用一个时间片轮流发送</p><p>B.每个节点检查介质是否空闲，如果空闲立即发送</p><p>C.每个节点想发就发，如果没有冲突则继续发送</p><p>D.得到令牌的节点发送，没有得到令牌的节点等待</p><h2 id="冲突检测原理"><a href="#冲突检测原理" class="headerlink" title="冲突检测原理"></a>冲突检测原理</h2><p>载波监听只能减小冲突的概率，不能完全避免冲突</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;局域网和城域网&quot;&gt;&lt;a href=&quot;#局域网和城域网&quot; class=&quot;headerlink&quot; title=&quot;局域网和城域网&quot;&gt;&lt;/a&gt;局域网和城域网&lt;/h1&gt;&lt;p&gt;最常考点:CSMA&amp;#x2F;CD 、VLAN 、 STP&lt;/p&gt;
&lt;h2 id=&quot;局域网体系与拓扑</summary>
      
    
    
    
    <category term="网络工程师" scheme="https://primeluoqiu.github.io/categories/%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B%E5%B8%88/"/>
    
    
  </entry>
  
  <entry>
    <title>第七周总结 + 第八周学习计划</title>
    <link href="https://primeluoqiu.github.io/2024/04/22/%E6%AF%8F%E5%91%A8%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/Week7/"/>
    <id>https://primeluoqiu.github.io/2024/04/22/%E6%AF%8F%E5%91%A8%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/Week7/</id>
    <published>2024-04-21T16:08:28.305Z</published>
    <updated>2024-04-21T16:10:42.032Z</updated>
    
    <content type="html"><![CDATA[<h4 id="第七周总结"><a href="#第七周总结" class="headerlink" title="第七周总结"></a>第七周总结</h4><p>前两周似乎有点莫得激情，希望本周可以把激情找回来，感觉还是要深入地进行学习这样子才能到关键的时候有的说。</p><h5 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h5><p>走一步看一步，大体计划然后每日更新学习内容好了<br>1.计网<br>2.面向对象<br>3.前端<br>4.开发思路和知识</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;第七周总结&quot;&gt;&lt;a href=&quot;#第七周总结&quot; class=&quot;headerlink&quot; title=&quot;第七周总结&quot;&gt;&lt;/a&gt;第七周总结&lt;/h4&gt;&lt;p&gt;前两周似乎有点莫得激情，希望本周可以把激情找回来，感觉还是要深入地进行学习这样子才能到关键的时候有的说。&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="大二下" scheme="https://primeluoqiu.github.io/categories/%E5%A4%A7%E4%BA%8C%E4%B8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>Go基本的结构和基本数据类型</title>
    <link href="https://primeluoqiu.github.io/2024/04/21/%E5%85%A8%E6%A0%88%E5%86%85%E5%AE%B9/%E5%90%8E%E7%AB%AFGo/C1/"/>
    <id>https://primeluoqiu.github.io/2024/04/21/%E5%85%A8%E6%A0%88%E5%86%85%E5%AE%B9/%E5%90%8E%E7%AB%AFGo/C1/</id>
    <published>2024-04-21T15:45:29.730Z</published>
    <updated>2024-04-21T15:50:13.682Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Chapter-4-基本结构和基本数据类型"><a href="#Chapter-4-基本结构和基本数据类型" class="headerlink" title="Chapter 4 基本结构和基本数据类型"></a>Chapter 4 基本结构和基本数据类型</h1><h2 id="2-Go程序的基本结构和要素"><a href="#2-Go程序的基本结构和要素" class="headerlink" title="2.Go程序的基本结构和要素"></a>2.Go程序的基本结构和要素</h2><h3 id="1-包的概念、导入和可见性"><a href="#1-包的概念、导入和可见性" class="headerlink" title="1.包的概念、导入和可见性"></a>1.包的概念、导入和可见性</h3><p>包是结构化代码的一种方式：每个程序都由包(pkg)的概念组成，可以使用自身的包或者从其他包中导入内容。每个go文件都属于且仅属于一个包，一个包可以有很多go程序，文件名和包名一般来说是不相同的。</p><p>必须在源文件中非注释的第一行指明这个文件属于哪个包，如<code>package main</code>。<code>package main</code>表示一个可独立执行的程序，每个go程序都包含一个可独立执行的程序，每个go都应该包含一个名为<code>main</code>的包</p><p>一个应用程序也可以包含不同的包，不必要把所有代码写在main中，可以用小文件，所有的包名都应该使用小写字母。</p><h4 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a>标准库</h4><p>Go 的标准库包含了大量的包，如fmt和os，也可以创建自己的包。想要构建一个程序，则包和包内的文件都必须以正确的顺序进行编译。包的依赖关系决定了其构建顺序。属于同一个包的源文件必须全部被一起编译，一个包即是编译时的一个单元，因此根据管理，每个目录都只包含一个包。<strong>如果对一个包进行更改或重新编译，所有引用这个包的客户端都必须全部重新编译</strong>。 </p><p><strong>每一段代码只会被编译一次。</strong> 一个go程序通过”import”关键字将一组包连接在一起。<code>import &quot;fmt&quot;</code>告诉go编译器这个程序需要使用<code>fmt</code>包(的函数，或其他元素)，”fmt”包实现了格式化IO的函数。包名被封闭在半角双引号中，如果打算从已编译的包中导入并加载公开声明的方法，不需要插入已编译包的源代码。</p><p>如果需要多个包，可以被分别导入</p><div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;os&quot;</span></span><br></pre></td></tr></table></figure></div><p>或者</p><div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span>; <span class="keyword">import</span> <span class="string">&quot;os&quot;</span></span><br></pre></td></tr></table></figure></div><p>还有短且优雅的方法(被称为因式分解关键字，方法同样适用于const, var 和 Type的声明或定义):</p><div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></div><p>甚至可以更短，不过使用fmt之后会强制换行</p><div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>(<span class="string">&quot;fmt&quot;</span>, <span class="string">&quot;os&quot;</span>)</span><br></pre></td></tr></table></figure></div><p>如果包名不以<code>.</code>或<code>/</code>开头，如<code>&quot;fmt&quot;</code>，会在全局文件进行查找;如果以<code>./</code>开头，会在相对目录中查找，或者绝对路径查找<br>导入包等同于包含了这个包的所有的代码对象。<br>除了符号<code>_</code>，包中所有代码对象的标识符必须是唯一的，避免名称冲突<br>可以通过下述被编译器强制执行的规则来决定是否将自身的代码对象暴露给外部文件：</p><h4 id="可见性规则"><a href="#可见性规则" class="headerlink" title="可见性规则"></a>可见性规则</h4><p>当标识符以一个大写字母开头，如Group1，那么使用这种形式的标识符的对象就可以被外部包的代码所使用(前提是已经被导入)，这被称之为导出；标识符如果以小写字母开头，则对包外是不可见的，但在整个包内部是可见并可用的。(private)</p><p>大写字母可以使用任何Unicode编码的字符，例如希腊文</p><p>因此在导入一个外部包之后，能够且只能够访问该包中导出的对象。</p><p>假设在pack1中有一个变量或函数叫做Thing，那么在当前包中导入pack1包，Thing就可以像面向对象语言那样使用点标记来调用。<code>pack1.Thing</code></p><p>因此包也可以作为命名空间使用，帮助避免命名冲突，两个包中的同名变量区别在于包名。</p><p>也可以通过使用包的别名来解决包名之间的名称冲突，或者根据个人喜好对包名进行重新设置，例如</p><div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> fm <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fm.Println(<span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>如果导入一个包之后没有进行使用，则会在构建程序时引发错误，如<code>imported and not used: os</code>，这遵循了go的格言：没有不必要的代码</p><p>也可以在使用<code>import</code>导入包之后定义或声明0个或多个常量(cosnt)、变量(var)和类型(type)，这些对象的作用域都是全局的(在本包范围内)，所以可以被本包中所有的函数调用，然后声明一个或多个函数(func)</p><h3 id="2-函数"><a href="#2-函数" class="headerlink" title="2.函数"></a>2.函数</h3><p>这是定义一个函数最简单的方式</p><div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">functionName</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure></div><p>可以在括号中写入0个或多个函数的参数，(使用，分隔)，参数名称后面必须跟着参数的类型。</p><p><strong>main函数是每一个可执行程序所必须包含的</strong>，一般来说都是在启动后<strong>第一个执行的函数</strong>(如果有init()函数则会先执行该函数)。如果main包的<strong>源代码</strong>没有包含<em>main</em>函数，则会引发构建错误。main函数既没有参数，也没有返回类型。<strong>添加</strong>也会出现<strong>构建错误</strong></p><p>在程序开始执行并完成初始化之后，第一个调用(程序的入口点)的函数是<code>main.main()</code>该函数一旦返回就表示程序已成功执行并立即退出。</p><p>函数体使用大括号括起来。 <code>&#123;</code>必须与方法的声明放在<strong>同一行</strong>，这是<strong>强制规定</strong>，否则就会出现相关错误<br>原因是因为编译器会产生<code>func main();</code>这样的结果，这很明显是错的</p><div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">`bulid-error: syntax error: unexpected semicolon or newline before &#123;`</span></span><br></pre></td></tr></table></figure></div><p><strong>Go语言虽然看起来不使用分号作为语句的结束，但实际上这一过程是由编译器自动完成，因此才会引发像上面这样的错误</strong></p><p><code>&#125;</code>需要被放在紧接着函数体的下一行，如果函数非常简短，也可以放在同一行</p><div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sum</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123; <span class="keyword">return</span> a + b &#125;</span><br></pre></td></tr></table></figure></div><p>大括号使用规则在任何时候都是相同的。<br>因此符合规范的函数一般写成如下形式</p><div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">functionName</span><span class="params">(parameter_list)</span></span> (return_value_list) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>其中：</p><ul><li>parameter_list的形式为(param1 type1, param2 type2, …)</li><li>return_value_list的形式为(ret1 type1, ret2 type2, …)<br>只有当某个函数需要被外部包调用的时候才使用大写字母开头，并遵循Pascal命名法：否则就遵循驼峰命名法(第一个单词的首字母小写，其余单词首字母大写)。</li></ul><div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(<span class="string">&quot;Hello, world&quot;</span>)</span><br></pre></td></tr></table></figure></div><p>这一行调用了fmt包的Println函数，将字符串输出到控制台并自动增加换行符，使用”Hello,world\n”可以得到同样效果。</p><p><code>Print</code>和<code>Println</code>也支持使用变量，如果没有特别指定，他们会以默认方式输出变量到控制台，如果只是单纯打印一个字符或者变量也可以用预定义的方式来实现<code>print</code>、<code>println</code>，不过这些函数只用于调试阶段，在部署的时候务必换成<code>fmt</code>中的相关函数。</p><p>当被调用的函数的代码执行到结束符<code>&#125;</code>或返回语句就会返回，然后继续执行调用函数之后的代码</p><p>正常退出的代码为0，异常被终止为非零值，可以用来测试是否成功执行一个程序。</p><h3 id="3-注释"><a href="#3-注释" class="headerlink" title="3.注释"></a>3.注释</h3><p>如果使用国际化字符直接用输出语句输出即可，注释不会被翻译，但可以用goddoc来使用。</p><p>单行注释很常见，或者多行注释(块状注释)，一般用于包的文档描述或者注释成块的代码片段。</p><p>每个包应该有相关注释，package之前的注释被默认成为这个包的文档说明，其中应该提供一些相关信息并对整体功能做简要的介绍。在首行的简要注释之后可以用成段的注释来进行更详细的说明，不必挤在一起，在多段注释之间用用空行加以区分。</p><p>几乎所有全局作用域的类型，常量、变量、函数和被导出的对象都应该有一个合理的注释。如果这种注释出现在函数前面，例如函数Abcd，则要以<code>&quot;Abcd...&quot;</code>作为开头。</p><div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// enterOrbit cause Superman to fly into low Earth orbit, a postion</span></span><br><span class="line"><span class="comment">// that presents sevral possibilities for planet salvation</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">enterOrbit</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>goddoc工具会手机这些注释并产生一个技术文档</p><h3 id="4-类型"><a href="#4-类型" class="headerlink" title="4.类型"></a>4.类型</h3><p>可以包含的数据的变量或常量。可以使用不同的数据类型或类型来保存数据，使用<code>var</code>声明的变量的值会自动初始化为该类型的0值。类型定义了某个变量的值得集合与可对其进行操作的集合</p><p>类型可以是基本类型，也可以是结构化的 struct, array，或者只描述类型的行为的。interface</p><p>结构化的类型没有真正的值，使用nil作为默认值(Null)。值得注意的是，Go中不存在类型继承。</p><p>函数也可以是一个确定的类型，就是以函数作为返回类型。这种类型的声明要写在函数名和可选的参数列表之后，例如</p><div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FunctionName</span><span class="params">(a typea, b typeb)</span></span> typeFunc</span><br></pre></td></tr></table></figure></div><p>可以在函数体中的某处返回使用类型为typeFunc的变量var：</p><div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">var</span></span><br></pre></td></tr></table></figure></div><p>一个函数可以拥有多返回值，返回类型之间需要使用逗号分隔，并使用小括号括起来</p><div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FunctionName</span> <span class="params">(a typea, b typeb)</span></span>(t1 type1, t2 type2)</span><br></pre></td></tr></table></figure></div><p>示例：函数Atoi(4.7节)<code>func Atoi(s string) (i int, err error)</code><br>返回的形式：</p><div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> var1, var2</span><br></pre></td></tr></table></figure></div><p>这种多返回值一般用于判断某个函数是否执行成功(true&#x2F;false)或与其他返回值一同返回错误消息</p><p>使用<code>type</code>关键字可以定义自己的类型，可以是一个结构体，也可以定义一个已经存在的类型的别名，如</p><div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IZ <span class="type">int</span></span><br></pre></td></tr></table></figure></div><p><strong>这里并不是真正意义上的别名，因为使用这种方法定义之后的类型可以拥有更多的特性，且在类型转换时必须显示转换。</strong><br>然后我们可以使用下面的方式声明变量：</p><div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a IZ = <span class="number">5</span></span><br></pre></td></tr></table></figure></div><p>这里可以看到int是变量a的底层类型，这也使得它们之间存在相互转换的可能。如果有多个类型需要定义，也可以使用因式分解关键字的方式，例如:</p><div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> (</span><br><span class="line">    IZ <span class="type">int</span></span><br><span class="line">    Fz <span class="type">float64</span></span><br><span class="line">    STR <span class="type">string</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></div><p>每个值都必须在经过编译之后属于某个类型(编译器必须能够推断出所有值的类型)，因为Go语言是一种静态类型语言。</p><h3 id="5-Go程序的一般结构"><a href="#5-Go程序的一般结构" class="headerlink" title="5.Go程序的一般结构"></a>5.Go程序的一般结构</h3><p>下面的程序虽然可以顺利的编译，但是什么都做不了，不过这很好的展示了一个Go程序的首选结构，这种结构没有被强制要求，且编译器也不关心main函数的位置，但是使用统一的结构能够在从上至下阅读Go代码时有更好的体验</p><p>总体思路</p><ul><li>在完成包的import之后，开始对常量、变量和类型的定义或声明。</li><li>如果存在int函数的话，则对该函数进行定义(这是一个特殊的函数，每个含有该函数的包都会首先执行这个函数)。</li><li>如果当前包是main包，则定义main函数</li><li>然后定义其余的函数，首先是类型的方法，接着是按照main函数中先后调用的顺序来定义相关函数，如果有很多函数，则可以按照字母顺序来进行排序</li></ul><div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> c = <span class="string">&quot;C&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> v <span class="type">int</span> = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123; <span class="comment">//initialization of package</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a <span class="type">int</span></span><br><span class="line">Func1()</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">fmt.Println(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t T)</span></span> Method1() &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Func1</span><span class="params">()</span></span> &#123; <span class="comment">//exported function Func1</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p>顺序如下：</p><ol><li>按顺序导入所有被main包引用的其他包，然后在每个包中执行如下流程：</li><li>如果该包又导入了其他的包，则从第一步开始递归执行，但是每个包只会被导入一次</li><li>然后以相反的顺序在每个包中初始化常量和变量，如果该包含有init函数的话，则调用该函数</li><li>在完成这一切之后，main也执行同样的过程，最后调用main函数开始执行程序。</li></ol><h3 id="6-类型转换"><a href="#6-类型转换" class="headerlink" title="6.类型转换"></a>6.类型转换</h3><p>在必要以及可行的情况下，一个类型的值可以被转换成另一种类型的值。由于go语言不存在隐式类型转换，因此所有的转换都必须显示说明，就像调用一个函数一样。(类型在这里的作用可以看作是一种函数):</p><div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">valueOfTypeB = typeB(valueofTypeA)</span><br></pre></td></tr></table></figure></div><p><strong>类型B的值&#x3D;类型B(类型A的值)</strong></p><p>示例:</p><div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a := <span class="number">5.0</span></span><br><span class="line">b := <span class="type">int</span>(a)</span><br></pre></td></tr></table></figure></div><p>这只能在定义正确的情况下转换成功，如果从一个取值范围较小的类型转换到要给取值范围较大的类型(int 16-32)。如果从大到小的话，将会发生精度丢失的情况，于是编译器捕捉到非法的类型转换时会引发编译时错误，否则将引发运行时错误。<br>具有相同底层类型的变量可以相互转换。</p><div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a IZ = <span class="number">5</span></span><br><span class="line">c := (<span class="type">int</span>) a</span><br><span class="line">d := IZ(c)</span><br></pre></td></tr></table></figure></div><h3 id="7-Go命名规范"><a href="#7-Go命名规范" class="headerlink" title="7.Go命名规范"></a>7.Go命名规范</h3><p>干净、可读的代码和简洁性是Go追求的主要目标，通过gofmt来强制实现统一的代码风格。Go中对象的命名也应该是简洁而有意义的。像是java和python中那样使用混着大小写和下划线的冗长的名称会降低代码的可读性，名称不需要指出自己所属的包。因为在调用的时候会使用包名作为限定符，返回某个对象的函数或方法的名称一般都是使用名词。没有<code>Get ...</code>之类的字符。如果是用于修改某个对象，则使用<code>SetName</code>。有必须要的话可以使用大小写混合的方式，如MixedCaps或mixedCaps，而不是用下划线来分割多个名称。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Chapter-4-基本结构和基本数据类型&quot;&gt;&lt;a href=&quot;#Chapter-4-基本结构和基本数据类型&quot; class=&quot;headerlink&quot; title=&quot;Chapter 4 基本结构和基本数据类型&quot;&gt;&lt;/a&gt;Chapter 4 基本结构和基本数据类型&lt;/</summary>
      
    
    
    
    <category term="全栈后端" scheme="https://primeluoqiu.github.io/categories/%E5%85%A8%E6%A0%88%E5%90%8E%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>广域通信网</title>
    <link href="https://primeluoqiu.github.io/2024/04/19/%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B%E5%B8%88/%E5%B9%BF%E5%9F%9F%E9%80%9A%E4%BF%A1%E7%BD%91/"/>
    <id>https://primeluoqiu.github.io/2024/04/19/%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B%E5%B8%88/%E5%B9%BF%E5%9F%9F%E9%80%9A%E4%BF%A1%E7%BD%91/</id>
    <published>2024-04-19T13:51:36.823Z</published>
    <updated>2024-04-19T14:03:00.837Z</updated>
    
    <content type="html"><![CDATA[<h1 id="广域通信网"><a href="#广域通信网" class="headerlink" title="广域通信网"></a>广域通信网</h1><p>本章考察较少，一般1-2分，最常考点：帧中继、HDLC</p><h2 id="广域网通信基础"><a href="#广域网通信基础" class="headerlink" title="广域网通信基础"></a>广域网通信基础</h2><h3 id="1-公共交换电话网-PSTN"><a href="#1-公共交换电话网-PSTN" class="headerlink" title="1.公共交换电话网 PSTN"></a>1.公共交换电话网 PSTN</h3><p>PSTN: Public Switched Telephone Network 为了语音通信建立的网络，20c60s开始用于数据传输</p><ul><li>三个部分组成：本地回路、干线和交换机</li><li>干线和交换机采用数字传输和交换技术，本地回路基本采用模拟线路</li><li>电话线联网时需要在发送端通过调制解调器把数字信号变换成模拟信号，接收端再用同样设备转换成数字信号</li></ul><h3 id="2-本地回路"><a href="#2-本地回路" class="headerlink" title="2.本地回路"></a>2.本地回路</h3><p>DTE(Data Terminal Equipment)数据终端：通信链路的端点</p><p>DCE(Data Circuit Equipment)数据电路设备：用于信号变换器、自动呼叫等</p><p>DTE：PC&#x2F;电话机</p><p>DCE：猫&#x2F;调制解调器&#x2F;Modem</p><p>以RS-232-C接口为例说明机械特性及技术特性</p><p>机械特性描述DTE和DCE之间物理上的分界线，规定连机器的几何形状，尺寸大小，引线数、引线、排列方式及锁定装置等。 上述接口没有正式规定连机器的标准，只有在其附录中建议用<strong>25针</strong>的D型连接器，也有很多使用其他连接器，特别是在微型机RS-232-C串行接口上，大多使用<strong>9针</strong>连接器</p><p>电气特性：</p><p>上述设备采用的<strong>V.28标准</strong>电路，速率20kb&#x2F;s，最长15米</p><p>信号源产生3-15V的信号，±3V之间是信号电平过渡区</p><p>3-15V表示1，控制线和定时线OFF，</p><p>功能特性：对接口连线的功能给出明确定义 上述设备采用的是V.24</p><p>【2009上】</p><p>RS-232-C电气特性采用V.28标准电路，允许的数据速率是(),传输距离不大于()</p><p>a.1kbps b. 20Kbps c.100Kbps d. 1Mbps</p><p>a.1m b.15m c.100m d.1000m</p><p>【2009上】关于RS-232-C标准的描述中，正确的是</p><p>A.可以实现长距离远程通信</p><p>B.可以使用9针或25针D型连接器</p><p>C.必须采用24根线的电缆进线连接</p><p>D.通常用于连接并行打印机</p><h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><h3 id="流量控制和差错控制"><a href="#流量控制和差错控制" class="headerlink" title="流量控制和差错控制"></a>流量控制和差错控制</h3><p>流量控制指协调发送和接受的步调，避免发送过快</p><ul><li>两种协议：TCP、X.25 都考</li></ul><p>差错控制：检测和纠正传输错误的机制</p><ul><li>检错码：CRC   纠错码：海明码</li></ul><p>流量控制有两种协议</p><ul><li><p>停止等待协议</p><ul><li><p>发送方直到接收到接受方发来的应答信号(ACK)后再发送下一帧。如果不应答就等待</p></li><li><p>$$<br>TFA&#x3D;2t_p+t_f<br>$$</p></li><li><p>tp是路上时间，tf是发送时间。</p></li></ul></li><li><p>滑动窗口协议</p><ul><li>滑动窗口主要思想：允许连续发送多个帧而无需等待应答。</li><li>TCP&#x2F;X.25都是这种机制</li></ul></li></ul><p>应付差错的办法：</p><ol><li>肯定回答</li><li>否定回答</li><li>超时重传(最常用)<ol><li>停止等待ARQ(Automatic Repeat reQuest)自动重传协议</li><li>选择重发ARQ协议</li><li>后退N帧ARQ协议</li></ol></li></ol><p>停止等待ARQ：是停等流控制技术和自动请求重发技术的结合，发送站发送出一帧之后必须等待应答，收到肯定应答后再发送下一帧。收到NAK或者超时都要重发</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/04/19/y8DhaQ6C.png"                      alt="17.png"                ></p><p>选择重发ARQ：重传特定的某一帧<br>$$<br>W_发&#x3D;W_收≤2^{k-1}<br>$$<br>后退N帧ARQ：重传此帧和后续的N帧<br>$$<br>W_发&#x3D;W_收≤2^k-1<br>$$<br>HDLC(High Level Data Link Control, 高级数据链路控制)，是一种面向位(bit)的数据链路层控制协议，通常使用CRC-16、CRC-32校验，帧边界**”01111110”**</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/04/19/cIrslMMl.png"                      alt="16.png"                ></p><p>【2009下】对于选择重发ARQ协议，如果帧编号字段为k位，则窗口大小()</p><p>A.W≤2^k -1  B.W≤2^K-1  C.W&#x3D;2^k D. W &lt; 2^k - 1</p><p>【2019上】采用HDLC协议进行数据传输，帧0-7循环编号为0、1、2、3、4的5帧时，收到了对方应答帧REJ3,此时发送站应该发送的后续3帧为()；若收到对方的应答帧为SREJ3,则发送站应发送的后续3帧为()</p><p>A 2 3 4 B. 3 4 5 C. 3 5 6 D. 5 6 7</p><p>A 2\3\4  B. 3\4\5 C. 3\5\6 D. 5\6\7</p><p>【2009上】HDLC协议是一种(), 采用()标志作为帧定界符</p><p>A.面向比特的同步链路控制协议B</p><p>B.面向字节技术的同步链路控制协议</p><p>C.面向字符的同步链路控制协议</p><p>D.异步链路控制协议</p><p>A.10000001 B.01111110 C.10101010 D.101101011</p><h2 id="X-25与帧中继"><a href="#X-25与帧中继" class="headerlink" title="X.25与帧中继"></a>X.25与帧中继</h2><p>已经被IP和以太网取代了</p><h3 id="X-25公共数据网（了解）"><a href="#X-25公共数据网（了解）" class="headerlink" title="X.25公共数据网（了解）"></a>X.25公共数据网（了解）</h3><ul><li>X.25分为三个协议层，即<em>物理层、链路层和分组层</em>，分别对应OSI模型低三层</li><li>X.25是一种分组交换技术，面向连接，建立虚链路</li><li>X.25支持<strong>差错控制和流量控制</strong>，传输速率：64Kbps</li></ul><h3 id="帧中继FR-Frame-Relay-选择常考"><a href="#帧中继FR-Frame-Relay-选择常考" class="headerlink" title="帧中继FR(Frame Relay) 选择常考"></a>帧中继FR(Frame Relay) 选择常考</h3><ul><li>帧中继在第二层建立虚链路，提供<strong>虚链路服务</strong>，本地表示<strong>DLCI</strong></li><li>基于分组交换的透明传输，可提供<strong>面向连接</strong>的服务。</li><li><em>只做检错和拥塞控制，没有流量控制和重传机制，开销很少</em></li><li>既可以按需要提供带宽，也可以应对突发的数据传输 <strong>CIR(承诺速率) EIR(扩展速率)</strong></li><li><strong>帧长可变</strong>，长度可达1600-4096字节，可以承载各种局域网的数据帧</li><li>可以达到很高的速率，<strong>2-45Mbps</strong></li><li>不适合对延迟敏感的应用(语音、视频)</li><li>数据的丢失依赖于运营商对虚电路的配置</li><li>不保障可靠的提交</li></ul><p> 【2013下】帧中继的网络虚电路建立在(),这种虚电路的特点是()</p><p>A.数据链路层  B.网络层 C.传输层  D.会话层</p><p>A.没有流量控制功能，也没有拥塞控制功能</p><p>B.没有流量控制功能，但具有拥塞控制功能</p><p>C.具有流量控制功能，但没有拥塞控制功能</p><p>D.具有流量控制功能，也具有拥塞控制功能</p><p>【2012下】下面用于表示帧中继虚链路标识符是()</p><p>A.CIR  B.LMI C.DLCI D.VPI</p><p>ISDN和ATM</p><ul><li><p>ISDN综合数字业务网，目的是以数字系统代替模拟电话系统（PSTW），把音频、视频、数据业务放在一个网上统一传输</p></li><li><p>分为窄带ISDN和宽带ISDN，窄带ISDN提供两种用户接口</p><ul><li>基本速率<em>BRI</em>&#x3D;2B+D&#x3D;<strong>144Kbps</strong></li><li>集群速率<em>PRI</em>&#x3D;30B+D&#x3D;<strong>2.048Mbps</strong></li></ul></li><li><p>宽带ISDN即ATM</p></li><li><p>ATM是<strong>信元交换</strong>，信元为<strong>53字节</strong>固定长度</p></li><li><p>ATM依然是以虚链路提供面向连接的服务</p></li><li><p>ATM典型速率为<strong>150M</strong></p></li></ul><p>【2014下】典型运营商提供的ISDN服务有两种不同接口，其中供小型企业和家庭使用的基本速率接口(BRI)速率是(),供大型企业使用的接口速率是()</p><p>A.128Kb&#x2F;s B.144Kb&#x2F;s C.1024Kb&#x2F;s D.2048Kb&#x2F;s</p><p>A.128Kb&#x2F;s B.144Kb&#x2F;s C.1024Kb&#x2F;s D.2048Kb&#x2F;s</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;广域通信网&quot;&gt;&lt;a href=&quot;#广域通信网&quot; class=&quot;headerlink&quot; title=&quot;广域通信网&quot;&gt;&lt;/a&gt;广域通信网&lt;/h1&gt;&lt;p&gt;本章考察较少，一般1-2分，最常考点：帧中继、HDLC&lt;/p&gt;
&lt;h2 id=&quot;广域网通信基础&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    <category term="网络工程师" scheme="https://primeluoqiu.github.io/categories/%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B%E5%B8%88/"/>
    
    
  </entry>
  
  <entry>
    <title>1.2初识输入输出</title>
    <link href="https://primeluoqiu.github.io/2024/04/18/C++Primer/Chapter1/1.2/"/>
    <id>https://primeluoqiu.github.io/2024/04/18/C++Primer/Chapter1/1.2/</id>
    <published>2024-04-18T15:50:10.094Z</published>
    <updated>2024-04-18T15:57:15.380Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-2初识输入输出"><a href="#1-2初识输入输出" class="headerlink" title="1.2初识输入输出"></a>1.2初识输入输出</h1><p>C++语句并未定义任何输入输出，取而代之包含了一个全面的标准库(standard library)来提供IO机制。对于很多用途，我们只需要了解IO库中一部分基本概念和操作。</p><p>iostream库包含两个基础类型:istream和ostream。分别对应in和out。一个流就是一个字符序列，是从IO设备读出或写入IO设备的。术语”流”想要表达的是，随着时间的推移，字符是顺序生成或消耗的。</p><h2 id="标准输入输出对象"><a href="#标准输入输出对象" class="headerlink" title="标准输入输出对象"></a>标准输入输出对象</h2><p>标准库定义了4个IO对象。为了处理输入，我们使用一个名为cin的istream的对象。这个对象也被称为<strong>标准输入</strong>。对于输出，我们使用一个名为cout的ostream类型的对象。此对象也被称为标准输出。标准库还定义了其他两个ostream类型的对象，名为ccer和clog。我们通常用cerr来输出警告和错误信息，因此它也被称为标准错误。而clog用来输出程序运行时的一般性信息。 </p><p>系统通常将程序所运行得窗口与这些对象关联起来。因此当我们读取cin，数据将从程序正在运行的窗口读入，当我们向cout、cerr和clog写入数据时，将会写到同一个窗口。</p><h2 id="一个使用IO库的程序"><a href="#一个使用IO库的程序" class="headerlink" title="一个使用IO库的程序"></a>一个使用IO库的程序</h2><p>我们先看一下如何将两个数相加。通过IO库，我们可以扩展main程序，使之能提示用户输入两个数，然后输出他们的和</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Enter two numbers: &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="type">int</span> v1 = <span class="number">0</span>, v2 = <span class="number">0</span>;</span><br><span class="line">    std::cin &gt;&gt; v1 &gt;&gt; v2;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The sum of &quot;</span> &lt;&lt; v1 &lt;&lt; <span class="string">&quot; and &quot;</span> &lt;&lt; v2 &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; v1 + v2 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>第一行告诉编辑器我们想要使用iostream库，尖括号中的名字指出了一个头文件。每个使用标准库的设施的程序都必须包含相关的头文件。#include指令和头文件的名字必须写在同一行中。通常情况下，#include指令必须出现在所有函数之外。</p><h2 id="向流写入数据"><a href="#向流写入数据" class="headerlink" title="向流写入数据"></a>向流写入数据</h2><p>在C++中，一个表达式产生一个计算结果，它是由一个或多个运算对象和一个运算符组成。这条语句中的表达式使用了**输出运算符&lt;&lt;**再标准输出上打印消息</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; <span class="string">&quot;Enter two numbers:&quot;</span> &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure></div><p>&lt;&lt;运算符接受两个运算对象：左侧的运算对象必须是一个<strong>ostream</strong>对象，右侧的运算对象是要打印的值。此运算符将给定的值写到给定的ostream对象中。输出运算符的计算结果就是其左侧运算对象。也就是说，计算结果就是写入给定值的那个ostream对象。</p><p>我们的输出语句使用了两次&lt;&lt;运算符。因为运算符返回其左侧的运算对象，因此第一个运算符的结果成为了第二个运算符的左侧运算对象。这样，我们就可以将输出请求连接起来。</p><p>endl是一个操纵符的特殊值。写入endl的效果是结束当前行。并将与设备关联的缓冲区(buffer)中的内容刷到设备中。</p><p>缓冲刷新操作可以保证到目前为止程序所产生的所有输出都真正写入输出流中，而不是仅停留在内存中等待写入流。</p><h3 id="使用标准库中的名字"><a href="#使用标准库中的名字" class="headerlink" title="使用标准库中的名字"></a>使用标准库中的名字</h3><p>前缀std::指出cout和endl是定义在名为std的命名空间中的。命名空间可以帮助我们避免不经意的名字定义冲突，以及使用库中相同名字导致的冲突。标准库定义的所有名字都在命名空间std中</p><p>不过通过命名空间使用标准库有个副作用：当使用标准库中的一个名字时，必须显式说明我们想使用来自命名空间std中的名字。例如，需要写出std::cout，通过使用**作用域运算符(::)**来指出我们想使用定义在命名空间中std中的名字cout。</p><h3 id="从流中读取数据"><a href="#从流中读取数据" class="headerlink" title="从流中读取数据"></a>从流中读取数据</h3><p>**输入运算符(&gt;&gt;)**与输出运算符类似，他接受一个istream作为其左侧运算对象，接受一个对象作为其右侧运算对象。它从给定的istream读入数据，并存入给定对象中。输入运算符返回其左侧运算对象作为其运算结果。</p><p>标准库定义了不同版本的输入输出运算符，来处理输出语句中的不同类型的运算对象。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-2初识输入输出&quot;&gt;&lt;a href=&quot;#1-2初识输入输出&quot; class=&quot;headerlink&quot; title=&quot;1.2初识输入输出&quot;&gt;&lt;/a&gt;1.2初识输入输出&lt;/h1&gt;&lt;p&gt;C++语句并未定义任何输入输出，取而代之包含了一个全面的标准库(standard l</summary>
      
    
    
    
    <category term="C++ Primer" scheme="https://primeluoqiu.github.io/categories/C-Primer/"/>
    
    
  </entry>
  
  <entry>
    <title>1.1编写一个简单的C++程序</title>
    <link href="https://primeluoqiu.github.io/2024/04/18/C++Primer/Chapter1/1.1/"/>
    <id>https://primeluoqiu.github.io/2024/04/18/C++Primer/Chapter1/1.1/</id>
    <published>2024-04-18T15:50:02.616Z</published>
    <updated>2024-04-18T15:57:31.184Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-1编写一个简单的C-程序"><a href="#1-1编写一个简单的C-程序" class="headerlink" title="1.1编写一个简单的C++程序"></a>1.1编写一个简单的C++程序</h1><p>本章内容是编写一个程序来解决简单的书店问题。</p><p>​书店保存所有销售记录的档案，每条记录保存了某本书的一次销售的信息(一册或多册)。每条记录包含三个数据项</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0-201-70353-X 4 24.99</span><br></pre></td></tr></table></figure></div><p>第一项是书的ISBN号，第二项是售出的册数，最后一项是书的单价。</p><p>为了编写这个程序，我们要使用若干C++的基本特性。而且，我们需要了解如何编译及运行程序。</p><p>很显然，它需要</p><ul><li>定义变量</li><li>进行输入和输出</li><li>使用数据结构保存数据</li><li>检测两条记录是否有相同的ISBN</li><li>包含一个循环来处理销售档案中的每条记录</li></ul><p>我们首先介绍如何用C++来解决这些子问题，然后编写书店程序</p><p>一个函数的定义包含四部分:<strong>返回类型(return type) 、 函数名、一个括号包围的形参列表，以及函数体</strong></p><p>main函数的返回类型必须为int，即整数类型。int类型是一种<strong>内置类型</strong>，即语言自身定义的类型。</p><p>return语句结束函数的执行。当return语句包括一个值的时候，此返回值的类型必须与函数的返回类型相容。</p><p>在大多数系统中，main的返回值被用来指示状态。返回值0表明成功，非0的返回值的含义由系统定义，通常用来指出<strong>错误类型</strong></p><h3 id="1-1-1-编译、运行程序"><a href="#1-1-1-编译、运行程序" class="headerlink" title="1.1.1 编译、运行程序"></a>1.1.1 编译、运行程序</h3><p>编写好程序就要编译了。很多PC上的编译器都具备集成开发环境(Integrated Development Environment, IDE),将编译器与其他程序创建和分析工具包装在一起。在开发大型程序的时候，这类集成环境会是非常有用的工具</p><p>大部分编译器包括集成IDE的编译器，都会提供一个命令行。接触命令行界面学习C++还是很容易的。一旦掌握了语言，IDE通常很容易学习。</p><h4 id="程序源文件命名约定"><a href="#程序源文件命名约定" class="headerlink" title="程序源文件命名约定"></a>程序源文件命名约定</h4><p>大多数编译器都要求程序源码存储在一个或多个文件中。程序文件通常被称为**源文件(source file)**。源文件通常以一个后缀结尾，告诉系统这个文件是一个c++程序。不同编译器使用不同的后缀命名约定。</p><h4 id="命令行运行编译器"><a href="#命令行运行编译器" class="headerlink" title="命令行运行编译器"></a>命令行运行编译器</h4><p>如果正在使用命令行，那么通常是在一个控制台窗口内编译程序。假定main程序保存在文件prog1.cc中。可以如下方式编译</p><div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cc prog1.cc</span><br></pre></td></tr></table></figure></div><p>在Windows中运行的话</p><div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ prog1</span><br></pre></td></tr></table></figure></div><p>其他</p><div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ .\prog1</span><br></pre></td></tr></table></figure></div><p>在Unix中的话是</p><div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ a.out</span><br><span class="line">$./a.out</span><br><span class="line">$ <span class="built_in">echo</span> $?  <span class="comment">#在执行完一个程序之后，都可以通过echo获得返回值</span></span><br></pre></td></tr></table></figure></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-1编写一个简单的C-程序&quot;&gt;&lt;a href=&quot;#1-1编写一个简单的C-程序&quot; class=&quot;headerlink&quot; title=&quot;1.1编写一个简单的C++程序&quot;&gt;&lt;/a&gt;1.1编写一个简单的C++程序&lt;/h1&gt;&lt;p&gt;本章内容是编写一个程序来解决简单的书店问</summary>
      
    
    
    
    <category term="C++ Primer" scheme="https://primeluoqiu.github.io/categories/C-Primer/"/>
    
    
  </entry>
  
  <entry>
    <title>数据通信基础</title>
    <link href="https://primeluoqiu.github.io/2024/04/18/%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B%E5%B8%88/%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1%E5%9F%BA%E7%A1%80/"/>
    <id>https://primeluoqiu.github.io/2024/04/18/%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B%E5%B8%88/%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1%E5%9F%BA%E7%A1%80/</id>
    <published>2024-04-18T13:24:40.865Z</published>
    <updated>2024-04-18T13:25:30.291Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据通信基础"><a href="#数据通信基础" class="headerlink" title="数据通信基础"></a>数据通信基础</h1><p>本章只考上午题，考试一般3-5分，有逐年增大的趋势。</p><p>最长考点:PCM、E1、海明码…难点：海明码和CRC</p><h2 id="信道特性"><a href="#信道特性" class="headerlink" title="信道特性"></a>信道特性</h2><p><strong>重点是两个公式</strong></p><h3 id="数据通信基本概念"><a href="#数据通信基本概念" class="headerlink" title="数据通信基本概念"></a>数据通信基本概念</h3><p>首先，通信的目的就是为了传递信息。通信中产生和发送信息的一端叫信源，接收信息的一端叫信宿，信源和信宿之间的通信线路成为信道。</p><p>通信系统的模型如此</p><p>​                          噪声</p><p>​                           ↓</p><p>信源 -&gt; 变换 -&gt; 信道 -&gt; 变换 -&gt; 信宿</p><p>首先，我们要知道，信号分为两种，分别是连续的模拟信号和离散的数字信号，前者类似于声波，后者类似于电脑之间的信息传递。那么为什么中间会有变换呢，是因为，理想状态下肯定是信源发送的是连续的模拟信号，信道也是模拟信号的信道，但是有些时候可能信源是模拟信号，但是信道会是数字信号的信道，这个时候就需要转换了。当然，就像声音在传播的过程中会出现干扰一样，信号在传播的时候也会受到干扰，这就是上面出现的噪声。</p><h4 id="信道带宽-常考"><a href="#信道带宽-常考" class="headerlink" title="信道带宽(常考)"></a>信道带宽(常考)</h4><p>模拟信道:</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">W = f2 - f1</span><br></pre></td></tr></table></figure></div><p>就是信道能通过的最高频率减最低频率。单位是Hz</p><p>数字信道：</p><p>​数字信道是离散信道，带宽为信道能够达到的最大数据传输速率，单位是bit&#x2F;s</p><p>数据传输速率</p><p>​指每秒钟能够传输的二进制数据位数，单位为比特&#x2F;秒(记作 bit&#x2F;s b&#x2F;s 或bps) 1B &#x3D; 8bit</p><p>码元：</p><p>​一个数字脉冲称为一个码元(可以理解为时钟周期的信号)</p><p>码元速率：</p><p>单位时间内信道传送的码元个数。如果码元宽度(脉冲周期)为T，则**码元速率(波特率)**B</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">B = 1/T</span><br></pre></td></tr></table></figure></div><p>单位是波特(Baud)</p><p>一个码元携带信息量n(位)与码元种类数(N)的关系是<br>$$<br>n &#x3D; log_2N<br>$$</p><p>举例来说，假如有两个码元种类，那么携带的信息数只有0和1，也就是只有一位。那么四个码元种类呢 那么就有 00 01 10 11这四种，对应的肯定是两位了。同理，8种对应的就是3类</p><h2 id="信道特性-1"><a href="#信道特性-1" class="headerlink" title="信道特性"></a>信道特性</h2><h3 id="来奎斯特定理"><a href="#来奎斯特定理" class="headerlink" title="来奎斯特定理"></a>来奎斯特定理</h3><p>在一个理想的（没有噪声）的信道中，若信道带宽为W， 最大码元速率为：<br>$$<br>B &#x3D; 2W (baud)<br>$$</p><p>极限数据速率为<br>$$<br>R &#x3D; Blog_2N&#x3D;2Wlog_2N<br>$$<br>理解：每秒包裹总重&#x3D;每秒发送包裹个数*每个包裹重量</p><h3 id="香农定理"><a href="#香农定理" class="headerlink" title="香农定理"></a>香农定理</h3><p>在一个<strong>噪声信道</strong>的极限速率和带宽之间的关系。</p><ul><li>极限速率公式为:</li></ul><p>$$<br>  C&#x3D;Wlog_2(1+S&#x2F;N)<br>$$</p><ul><li>分贝与信噪比关系</li></ul><p>$$<br>dB &#x3D; 10log_10S&#x2F;N<br>$$</p><p>其中W为带宽，S为信号平均功率，N为噪声平均功率，S&#x2F;N为信噪比</p><ul><li>dB&#x3D;10， S&#x2F;N&#x3D;10</li><li>dB&#x3D;30 , S&#x2F;N &#x3D;1000</li><li>log21001 ≈ log21024 &#x3D; 10</li></ul><h3 id="误码率-考的少"><a href="#误码率-考的少" class="headerlink" title="误码率(考的少)"></a>误码率(考的少)</h3><ul><li><p>误码率是衡量数据通信系统在正常工作下传输可靠性的指标</p></li><li><p>定义：传输出错的码元数占传输总码元数的比例，误码率越小，通信可靠性越高</p></li><li><p>Pe &#x3D; Ne&#x2F;N 其中Ne表示出错数，N表示传送总数</p></li><li><p>计算机网络通信中，<strong>误码率一般要求低于10^-6</strong></p></li><li><p>数据延时 &lt; 200ms ，语音视频延时 &lt; 50ms 抖动 &lt; 20ms, 丢包率 &lt; 1%</p></li></ul><h3 id="信道延迟-考频较高"><a href="#信道延迟-考频较高" class="headerlink" title="信道延迟(考频较高)"></a>信道延迟(考频较高)</h3><p>信道延迟： 与源端和宿端距离有关，也与具体信道中的信号传播速率有关。</p><ul><li><p>光速为<strong>300m&#x2F;&#x2F;us &#x3D; 300000km&#x2F;s</strong></p></li><li><p>电缆中传播速度一般为光速的77%，即<strong>200m&#x2F;us &#x3D; 200000km&#x2F;s</strong></p></li><li><p>例如500m同轴电缆时延大概为2.5us</p></li><li><p>卫星信道的时延大约270ms(来回双向的延迟)</p></li><li><p><strong>发送数据时间&#x3D;线路延迟+调制延迟</strong></p></li><li><p>路上跑的时间+排队上车的时间</p></li></ul><p>【2014上】：在地面上相距2000km的两地之间通过电缆传输4000比特长的数据包，数据速率为64Kb&#x2F;s，从开始发送到接收完成需要的时间为</p><p>a. 48ms   b.640ms   c.32.5ms d.72.5ms</p><p>【2018上】在相隔20km的两地通过电缆以100Mb&#x2F;s的速率传送1518字节长的以太帧，从开始发送到接收完成数据需要的时间约是</p><p>a.131us b.221us c.1310us d.2210us</p><p>解答：</p><p>电缆传输速率是200000km&#x2F;s<br>$$<br>2<em>10^4km&#x2F;2</em>10^6km &#x3D; 1&#x2F;100ms<br>$$</p><p>$$<br>4<em>10^3bit&#x2F;64</em>10^3 &#x3D; 1&#x2F;16ms<br>$$</p><p>D</p><p>注意换算B</p><h3 id="传输介质"><a href="#传输介质" class="headerlink" title="传输介质"></a>传输介质</h3><ul><li>双绞线：8根铜导线每两根扭在一起(百兆用4根，千兆必须用8根)</li><li>分类：直通线&#x2F;交叉线， 屏蔽线和非屏蔽双绞线</li></ul><p>为什么要扭在一起，为了消除每跟线和每根线之间的磁场干扰。如果有一个线坏了，那么速度会降速。</p><p>直通线是指568A-568A 交叉线是指568A-568B 相同设备的话用的是交叉线，不同设备是交叉线。</p><ul><li>光纤：利用光在<strong>玻璃或塑料纤维</strong>中的全反射原理而达成的光传导工具<ul><li>光传导比电缆传导的损耗低得多，光纤适合用于长距离的信息传递(双绞线100m， 光纤100km)</li><li>光线特点：重量轻，体积小，传输远(衰减小)，容量大(4T&#x2F;s)，抗电磁干扰</li></ul></li></ul><h3 id="光纤分类"><a href="#光纤分类" class="headerlink" title="光纤分类"></a>光纤分类</h3><ul><li><p>单模光纤</p><ul><li>当光纤的几何尺寸可以与光波长相比拟时，即纤芯的几何尺寸与光信号波长相差不大时，一般为5~10um；</li><li>光纤只允许<strong>一种模式</strong>在其中传播，单模光纤具有极宽的带宽，特别适用于<strong>大容量、长距离的光纤通信</strong>（贵）</li></ul></li><li><p>多模光纤</p><ul><li>多模光纤纤芯的几何尺寸远大于光波波长，一般为50um、62.5um；允许<strong>多种模式光信号传播</strong></li><li>多模光纤仅用于<strong>较小容量、短距离的光纤传输通信</strong>（便宜）</li></ul></li></ul><p>多模光纤运行波长 850nm或1300nm</p><p>单模光纤运行波长 1310nm或1550nm</p><p>SX（多模光纤）- 颜色橘黄色 光源是发光二极管</p><p>LX（单模光纤） - 颜色黄色 光源是激光二极管</p><p>LH&#x2F;ZX（单模光纤）传输距离远 10-120km 颜色黄色 光源是激光二极管</p><p>光纤是没有带宽的，只有光模块的配合才有带宽这一说。光纤只有单模和多模。</p><p>【2018上】：关于单模光纤，下面描述中错误的是</p><p>a.芯线由玻璃或塑料制成</p><p>b.比多模光纤纤芯小</p><p>c.光波在芯线中以多种反射路径传播</p><p>d.比多模光纤传输距离远</p><p>答案：C 单模不是多模</p><h3 id="数据编码"><a href="#数据编码" class="headerlink" title="数据编码"></a>数据编码</h3><p>单极性码：用正的或负的电压表示数据，高电压表示二进制数1，无电压表示二进制数0。(容易出现的问题：如果有0.5就很难办)</p><p>极性码：分别用正负电压表示二进制数0和1，这种电平相差较大，抗干扰能力好。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/04/18/G9NyByOk.png"                      alt="1.png"                ></p><p>双极性码：信号在三个电平之间变化，一种典型的双极性编码就是信号<strong>交替反转编码</strong>(Alternative Mark Inversion)</p><p>如下图，0电平表示0， 1则在正负之间交替反转，1跳0不跳</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/04/18/U8Kjf1lo.png"                      alt="2.png"                ></p><p>归零编码：在归零编码(Return to Zero, RZ)中，码元中间的信号回归到零电平。</p><p>从负电平到零电平的转换边表示码元”1”，从正电平到零电平的转换边表示码元”0”</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/04/18/aBGgL2fh.png"                      alt="3.png"                ></p><p>不归零编码(Not Return to Zero, NRZ):规律是，当出现”1”时电平反转，当出现”0”时电平不翻转，也叫<strong>差分码</strong></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/04/18/zsmmfgcC.png"                      alt="4.png"                ></p><p>主要用在终端到调制解调器的接口中。</p><h4 id="双相码"><a href="#双相码" class="headerlink" title="双相码"></a>双相码</h4><p>曼彻斯特编码（重点考点）</p><p>曼彻斯特编码是一种双相码，在每个比特中间均有一个跳变，<strong>第一个编码自定义</strong>，<strong>假如</strong>下图由高电平向低电平跳变代表”0”，由低电平向高电平跳变代表”1”</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/04/18/ONFRWAQJ.png"                      alt="5.png"                ></p><p>曼彻斯特编码常用于以太网中</p><p>差分曼彻斯特编码(重点考点)</p><p>差分曼彻斯特编码 也是一种双相码 用在令牌环网中</p><p>有跳变代表”0”,无跳变代表”1”【有0无1】，第一个也是自定义的</p><p>不是比较形状，比较起始电平(上一个的终止与下一个起点)</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/04/18/6A4XTGK9.png"                      alt="6.png"                ></p><p>两种曼彻斯特编码特点</p><ol><li>优点：将时钟和数据包含在信号数据流中，也称自同步码</li><li>缺点：编码效率低：每个码元都要调制为两个不同的电平，因而调制速率是码元速率的两倍，这对信道的带宽提出了更高的要求，例如当数据传输速率为100Mbps时，需要200MHz的脉冲</li><li>**编码效率都是50%**，一般指用于最早的10M以太网编码</li></ol><h4 id="4B-5B编码（重点考点）"><a href="#4B-5B编码（重点考点）" class="headerlink" title="4B&#x2F;5B编码（重点考点）"></a>4B&#x2F;5B编码（重点考点）</h4><ul><li><p>发送数据流每4bit，先使用不归零码(NRZ-I)，编码成5bit，多一位用于解决同步问题</p></li><li><p>各种编码效率</p><ul><li>曼码和差分曼码效率50%，用于以太网</li><li>4B&#x2F;5B效率80% 用于百兆以太网</li><li>8B&#x2F;10B效率80% 用于千兆以太网</li><li>64B&#x2F;66B效率97%，用于万兆以太网</li></ul></li></ul><p>【2012上】曼彻斯特编码的效率是(), 4B&#x2F;5B编码的效率是()%</p><p>a.40 b.50 c.80 d.100</p><p>a.40 b.50 c.80 d.100</p><p>【2011下】（不吃饭也要会）</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/04/18/d4MUVvun.png"                      alt="7.png"                ></p><p>【拓展思考】 (同上)</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/04/18/m6ELHUYN.png"                      alt="8.png"                ></p><h2 id="2-5调制技术-出现频率比较高"><a href="#2-5调制技术-出现频率比较高" class="headerlink" title="2.5调制技术(出现频率比较高)"></a>2.5调制技术(出现频率比较高)</h2><ul><li>将数字信号转换成模拟信号称为调制，将模拟信号转换为数字信号称为解调<ul><li>幅度键控(ASK)：用载波的两个不同振幅表示0和1</li><li>频移键控(FSK)：用载波的两个不同频率表示0和1</li><li>相移键控(PSK)：用载波的起始相位的变化表示0和1</li><li>正交幅度调制(QAM)：把两个幅度相同但相位相差90°的模拟信号合成一个模拟信号</li></ul></li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/04/18/w1c5Upxf.png"                      alt="9.png"                ></p><ul><li><ul><li>码元只取两个相位值叫2相调制，码元取四个相位叫做四相调制，N&#x3D;2 &#x2F; 4</li><li>DPSK(Double)是二项 QPSK（Quarter)是四项</li></ul></li></ul><p>【2011下】可以用数字信号对模拟载波的不同参量进行调制，下图所示的调制方式称为()</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/04/18/qBSuRreX.png"                      alt="11.png"                ></p><p>【2014下】所谓正交幅度调制是把两个()的模拟信号合成一个载波信号</p><p>a.幅度相同相位相差90°</p><p>b.幅度相同相位相差180°</p><p>c.频率相同相位相差90°</p><p>d.频率相同相位相差180°</p><p>a</p><p>【2016上】通过正交幅度调制技术把ASK和PSK两种调制模式结合起来组成16种不同的码元，这时数据速率是码元速率的()倍</p><p>a.2 b.4 c.8 d.16</p><p>b</p><p>【2017下】下图展示的编码方式是()。若数据速率为1kb&#x2F;s，则载波速率为()Hz</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/04/18/RkHILfqL.png"                      alt="10.png"                ></p><p>a.DPSK b.BPSK c.QPSK d.MPSK</p><p>a.1000 b.2000 c. 4000 d.8000</p><p>【2018下】以下关于DPSK描述，正确的是()</p><p>a.采用两种相位，一种固定表示数据”0”,一种固定表示数据”1”</p><p>b.采用两种相位，通过前后有无相位改变来表示数据”0”和”1”</p><p>c.采用四种振幅，每个码元表示2比特</p><p>d.采用四种频率，每个码元表示2比特</p><p>【2019上】设信号的波特率(码元速率)为1000Baud，信道支持的最大数据速率为2000b&#x2F;s,则信道采用的调制技术为()</p><p>a. BPSK b.QPSK c.BFSK d.4B5B</p><h2 id="2-6-脉码调制PCM-出现频率高"><a href="#2-6-脉码调制PCM-出现频率高" class="headerlink" title="2.6 脉码调制PCM(出现频率高)"></a>2.6 脉码调制PCM(出现频率高)</h2><p>解调：把模拟信号转换为数字信号的过程</p><p>常用数字化技术就是脉冲编码调制技术，简称脉码调制</p><p>PCM数字化过程三个步骤：<strong>采样、量化和编码</strong></p><ul><li><p>采样：按照一定时间间隔对模拟信号进行取样，把模拟信号的当前值作为样本</p><ul><li>奈奎斯特采样定理：如果模拟信号的<strong>最高频率为fmax，若以大于2fmax的采样频率</strong>对其进行采样，则采样得到的离散信号序列就能完整的恢复出原始信号</li></ul></li><li><p>量化：把取样后得到的样本由连续值转换为离散值，离散值的个数决定了量化的精度。</p><ul><li>如图，把量化等级分为8级(n &#x3D; log2N的大N)，用000-111这8个二进制数分别代表不同的电平幅度</li></ul></li><li><p>编码：把量化后的<strong>样本值变成相应的二进制代码</strong>，可以得到相应的二进制代码序列，其中每个二进制代码都可以用一个脉冲串来表示，这一组脉冲序列就代表了经PCM编码的模拟信号</p><ul><li>如：对声音信号数字化时，由于语音最高频率是4kHz，所以取样频率是8kHz。对语音样本用128个等级量化，因而每个样本用7bit表示。在数字信道上传输这种数字化后的语音信号速率是<strong>7*8000&#x3D;56kbps</strong></li></ul></li></ul><p>【2013上】 假设模拟信号的频率范围是3~9MHz，采用频率必须大于()时，才能使得到的样本信号不失真。</p><p>A.6MHz b.12Mhz c.18Mhz d.20MHz</p><p>f&#x3D; 2fmax</p><p>【2013下】设信道带宽为4000Hz，采用PCM编码，采样周期为125us，每个样本量化后为128个等级，则信道的速率为()</p><p>a.10kb&#x2F;s b.16Kb&#x2F;s c.56Kb&#x2F;s d.64Kb&#x2F;s</p><p>有周期考虑到频率，就是用倒数来做。</p><p>N&#x3D; 128 n &#x3D; 7</p><h2 id="2-8-通信和交换方式"><a href="#2-8-通信和交换方式" class="headerlink" title="2.8  通信和交换方式"></a>2.8  通信和交换方式</h2><p>考点比较少，很好理解。</p><p>1.数据通信方式</p><ol><li>按通信方向分：<ul><li>单工通信：信息只能在一个方向传送，发送方不能接收，接收方不能发送(电视&#x2F;广播)</li><li>半双工通信：通信的双方可以交替发送和接收信息，但不能同时接收或发送(对讲机&#x2F;WIFI&#x2F;HUB)</li><li>全双工通信：通信双方可同时进行双向的信息传送(电话、交换机)</li></ul></li></ol><p>2.按同步方式分</p><ul><li>两种传输方式：异步传输和同步传输<ul><li>异步传输：把各个字符分开传输，在字符之间插入一位起始位(0)，在字符之后插入一位停止位(1),起始位对接收方的时钟起置位作用。在字符和停止位之间还要插入一位校验位，一般使用奇偶校验<ul><li>1位起始位   7位字符   1位校验位    1位停止位</li></ul></li><li>同步传输：比特分组(帧)要大得多。不是独立发送每个字符，而是把他们组合起来一起发送。我们称这些组合为数据帧，或简称帧。数据帧的第一部分包含同步字符，用于通知接收方一个帧已经达到。帧的最后一部分是一个帧结束标记。</li></ul></li></ul><p>【2016下】在异步通信中，每个字符包含1位起始位，7位数据位，1位奇偶位和1位终止位，每秒钟传送100个字符，采用DPSK调制，则码元速率为()， 有效数据速率为()</p><p>a.200波特 b.500波特 c.1000波特 d.2000波特</p><p>a.200b&#x2F;s b.500b&#x2F;s c.700b&#x2F;s d.1000b&#x2F;s</p><p>7*100 &#x3D; 700 c</p><p>码元速率求B R&#x3D;Blog2N DPSK N &#x3D; 2 R &#x3D; 1000 B &#x3D; 1000 c</p><p>2.交换方式</p><ul><li><p>数据交换技术有三种：电路交换、报文交换和分组交换</p></li><li><p>电路交换：一条物理通路，线路被释放之前处于占用状态</p></li><li><p>报文交换：从发送方传送到接收方采用存储转发的方式。完整的报文在一个个节点间传送</p></li><li><p>分组交换：分两种，数据报和虚电路</p><ul><li>数据报：每个分组都被独立的处理，每个节点根据一个路由选择算法，为每个分组选择一条路径，使它们的目的地相同。</li><li>虚电路：在传送之前，先建立起一条逻辑上的连接(VPN)，每个分组都沿着一条路径传输。(X.25 FR ATM)</li></ul></li></ul><p>减小了延迟，提高了吞吐 分组交换可以按分组纠错，发现错误只需重发出错的分组，通信效率提高。</p><h2 id="2-8-数字传输系统-E1-T1"><a href="#2-8-数字传输系统-E1-T1" class="headerlink" title="2.8 数字传输系统 E1&#x2F;T1"></a>2.8 数字传输系统 E1&#x2F;T1</h2><p>多路复用技术是把多个低速的信道组合成一个高速的信道的技术</p><p>光纤入户：分成上网、电视和电话</p><p>这种技术要用到两个设备：</p><ul><li>多路复用器(Multiplexer),在发送端根据某种约定的规则吧多个地贷款的信号复合成一个高带宽的信号</li><li>多路分配器(Demultiplexer),在接收端根据统一规则把高带宽信号分解成多个低带宽信号</li><li>二者统称多路器，简写MUX</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/04/18/P8IUiGwN.png"                      alt="12.png"                ></p><p>以上了解即可</p><p>数字传输系统</p><ul><li>脉码调制已经介绍，对4kHz语言信道按照8kHz速率采样，128级量化，则每个语音信道的比特流是56Kbps</li><li>美国和日本使用T1标准，T1&#x3D;56K*24 + 开销和间隔 &#x3D; 1.544M </li><li>T2 &#x3D; 4T1 T3&#x3D;7T2 T4&#x3D;6T3</li></ul><p>ITU-T标准E1信道数据</p><p>数据速率是2.048Mbps，把<strong>32个</strong>8位一组的数据样本组装成125us的基本帧，其中30个子信道用于语音传送，2个子信道(CH0和16)用于控制信令。</p><p>E1每秒语音64Kb E5-E4-…E1每一个前者都是后者的四倍。</p><p>【2016上】</p><p>T1的载波速率是()</p><p>a.1.544Mb&#x2F;s b.6.321Mb&#x2F;s c.2.048Mb&#x2F;s d.44.736Mb&#x2F;s</p><p>【2011下】E1信道速率是(), 其中每个语音信道的数据速率是()</p><p>a.1.544Mb&#x2F;s b.2.048Mb&#x2F;s c.6.312Mb&#x2F;s d.44.736Mb&#x2F;s</p><p>A.56kb&#x2F;s B.64Kb&#x2F;s C.128Kb&#x2F;s D.2048kb&#x2F;s</p><h3 id="同步数字序列"><a href="#同步数字序列" class="headerlink" title="同步数字序列"></a>同步数字序列</h3><p>重点：STM-1 155Mbps STM-4 322Mbps STM-16 2.5Gbps STM-64 10Gbps</p><p>同步数字序列(SDH)是光纤信道复用标准，其中最常用的STM-1(OC-3)速率是(15)，STM4(OC-12)速率是(16)<br>(15)</p><p>A.155.20Mb&#x2F;s<br>B.622.08Mb&#x2F;s<br>C.2488.320Mb&#x2F;s<br>D. 10Gb&#x2F;s<br>(16)</p><p>A.155.20Mb&#x2F;s<br>B.622.08Mb&#x2F;s<br>C.2488.320Mb&#x2F;s<br>D. 10Gb&#x2F;s</p><h2 id="2-9海明码纠错码"><a href="#2-9海明码纠错码" class="headerlink" title="2.9海明码纠错码"></a>2.9海明码纠错码</h2><p>数据传输中的错误要采用差错控制方法。数据通信中常用的办法是<strong>检错和纠错</strong></p><p>差错控制原理：传输k位，加入r位冗余，接受方收到进行计算比较</p><p>知道差错并请求重传称为检错，知道差错且知道是什么，叫纠错</p><p><strong>奇偶校验</strong>是最常用的检错方法，能检测出一位错位</p><p><strong>原理</strong>：在7位ASCII后增加一位，使码字中的1的个数成奇数(奇校验)或偶数(偶校验)</p><ul><li>奇校验：整个校验码(包括有效信息和校验位)中1的个数是奇数</li><li>偶校验：整个校验码中1的个数为偶数</li></ul><p><strong>海明码</strong>：通过冗余数据位来<strong>检测</strong>和<strong>纠正</strong>差错的编码方式</p><p><strong>海明距离</strong>：一个码字要变成另一个码字时必须改变的最小位数  </p><p>例如：7位ASCII码增加一位奇偶位称为8位的码字，这128个8位的码字之间的海明距离是2，所以当其中1位出错时便能检测出来，两位出错无能为力。</p><p><strong>海明码原理</strong>：在数据中间加入几个校验码，码距均匀拉大，当某位出错，会引起几个校验位的值发生变化。</p><p><strong>海明不等式</strong>：校验码个数为k，可以表示2^k个信息，一个信息用来表示没有错误，其余2^k-1个表示数据中存在错误，如果满足<br>$$<br>2^k-1&gt;&#x3D;m+k<br>$$<br>(m+k)为编码后的数总长度，则在理论上k个校验码就可以判断是哪一位出了问题。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/04/18/qb76RXaS.png"                      alt="13.png"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/04/18/DBAtILmO.png"                      alt="14.png"                ></p><p>【2014上&#x2F;2016上】海明码是一种纠错码，一对有效码字之间的海明距离是(), 如果信息位6位，要求纠正1位错，按照海明编码规则，需要增加的校验位至少()位</p><p>A.两个码字的比特数之和 B.两个码字的比特数之差</p><p>C.两个码字之间相同的比特数 D.两个码字之间不同的比特数</p><p>A.3 B.4 C.5 D.6</p><p>【2018上】</p><p>海明码是一种纠错码，其方法是为需要校验的数据位增加若干校验位，使得校验位的值决定某些被校位的的数据，当被校数据出错时，可根据校验位的值变化找到出错位，从而纠正错误。对于32位的数据，至少增加()个校验位才能构成海明码</p><p>A.3 B.4 C.5 D.6</p><p>以10位数据为例，其海明码表示为D9D8D7D6D5D4P4D3D2D1P3D0P2P1，其中Di表示数据位，Pj表示校验位，数据位D9由P4P3和P2进行校验(从右至左D9的位序为14，即等于8+4+2，因此用第8位的P4，第4位的P3和第2位的P2校验)，数据D5由()进行校验</p><p>A.P4P3 B.P4P2 C.P4P3P1 D.P3P2P1</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/04/18/z4BKWar3.png"                      alt="15.png"                ></p><h2 id="CRC循环冗余码"><a href="#CRC循环冗余码" class="headerlink" title="CRC循环冗余码"></a>CRC循环冗余码</h2><p>能检错不能纠错，广泛用于网络通信和磁盘存储</p><p>采用CRC进行差错校验，生成多项式为G(X)&#x3D;X^4+X+1信息码字为10111，则计算出CRC校验码是（）</p><p>过程分为以下几步</p><ol><li>判断校验位数：生成多项式的最高次方是几，校验位就是几位   <strong>4位校验位</strong></li><li>补齐数据位后面的0   10111 0000</li><li>提取生成多项式的系数  G(X)&#x3D;1xX^4+0*X^3 &#x3D; 10011</li><li>用第二步的结果，除以第三步的结果(异或运算)  余数就是CRC校验码，余位不够位，前面补0</li></ol><p>答案：1100</p><p>【2013下】循环冗余校验码CRC-16的生成多项式为G(X) &#x3D; X^16 + X^15 + X^2 + 1，它产生的校验码是()位，接收端发现错误采取的措施是()</p><p>A.2 B.4 C.16 D.32</p><p>A.自动纠错  B.报告上层协议 C.重新生成数据 D.自动请求重发</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;数据通信基础&quot;&gt;&lt;a href=&quot;#数据通信基础&quot; class=&quot;headerlink&quot; title=&quot;数据通信基础&quot;&gt;&lt;/a&gt;数据通信基础&lt;/h1&gt;&lt;p&gt;本章只考上午题，考试一般3-5分，有逐年增大的趋势。&lt;/p&gt;
&lt;p&gt;最长考点:PCM、E1、海明码…难点：海</summary>
      
    
    
    
    <category term="网络工程师" scheme="https://primeluoqiu.github.io/categories/%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B%E5%B8%88/"/>
    
    
  </entry>
  
  <entry>
    <title>网络体系结构</title>
    <link href="https://primeluoqiu.github.io/2024/04/18/%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B%E5%B8%88/%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    <id>https://primeluoqiu.github.io/2024/04/18/%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B%E5%B8%88/%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</id>
    <published>2024-04-18T13:24:40.861Z</published>
    <updated>2024-04-18T13:28:40.517Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一学时-网络体系结构"><a href="#第一学时-网络体系结构" class="headerlink" title="第一学时 网络体系结构"></a>第一学时 网络体系结构</h1><h2 id="OSI参考模型"><a href="#OSI参考模型" class="headerlink" title="OSI参考模型"></a>OSI参考模型</h2><p>两个点</p><p>一个是七个模型要记住，再一个是每个模型对应的叫什么。</p><p>比如：</p><p>应用层-&gt;数据-&gt;进程号</p><p>传输层-&gt;数据段-&gt;端口号 -&gt;端到端的传输</p><p>网络层-&gt;数据包-&gt;IP地址</p><p>数据链路层-&gt;数据帧-&gt; Mac地址 -&gt; 点到点的传输</p><p>物理层-&gt;比特流</p><p>看几个例题</p><p>【2016下】：数据封装的正确顺序是</p><p>a.数据、帧、分组、段、比特</p><p>b.段、数据、分组、帧、比特</p><p>c.数据、段、分组、帧、比特</p><p>d.数据、段、帧、分组、比特</p><p>【2005上】：在OSI参考模型中，上层协议实体和下层协议实体之间的逻辑接口叫做服务访问点(SAP)。在Internet中，网络层的服务访问点是</p><p>a.MAC地址</p><p>b.LLC地址</p><p>c.IP地址</p><p>d.端口号</p><p>【2005上+2016下】：在OSI参考模型中，实现端到端的应答、分组排序和流量控制功能的协议层是()</p><p>a.数据链路层</p><p>b.网络层</p><p>c.传输层</p><p>d.会话层</p><p>【2005下】</p><ul><li><p>在ISO OSI&#x2F;RM中 ()实现数据压缩功能。</p><p>a.应用层 b.表示层 c.会话层 d.网络层</p></li><li><p>在OSI参考模型中，数据链路层处理的数据单位是()</p><p>a.比特 b.帧 c.分组 d.报文</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第一学时-网络体系结构&quot;&gt;&lt;a href=&quot;#第一学时-网络体系结构&quot; class=&quot;headerlink&quot; title=&quot;第一学时 网络体系结构&quot;&gt;&lt;/a&gt;第一学时 网络体系结构&lt;/h1&gt;&lt;h2 id=&quot;OSI参考模型&quot;&gt;&lt;a href=&quot;#OSI参考模型&quot; c</summary>
      
    
    
    
    <category term="网络工程师" scheme="https://primeluoqiu.github.io/categories/%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B%E5%B8%88/"/>
    
    
  </entry>
  
  <entry>
    <title>1.6 高阶函数</title>
    <link href="https://primeluoqiu.github.io/2024/04/14/ClassesFormUCBerkely/CS61A/1.6/"/>
    <id>https://primeluoqiu.github.io/2024/04/14/ClassesFormUCBerkely/CS61A/1.6/</id>
    <published>2024-04-14T03:22:11.346Z</published>
    <updated>2024-04-14T05:43:52.342Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-6-高阶函数"><a href="#1-6-高阶函数" class="headerlink" title="1.6 高阶函数"></a>1.6 高阶函数</h1><p>我们已知函数是一种抽象方法，描述了与<strong>特定参数</strong>无关的<strong>复合操作</strong></p><p>也就是说，在<code>square</code>中我们并不是讨论一个参数的平方，而是讨论一种可以获得任何数字平方的办法，当然也可以通过<code>8*8</code>这样的表达式来计算平方得到结果。从而不显式的提到<code>square</code></p><p>这种虽然看起来很方便，但是对于一些简单的操作是足够的，但是对于复杂的表达式就会变得很麻烦，一般来说，缺少函数定义对我们来说就像是一个原始人，而不是modern people，程序虽然可以计算平方，但是缺少了对平方的概念的能力。</p><p>我们对强大的编程语言提出的要求之一就是能通过将名称分配给通用模板(general patterns)来构造抽象，然后直接使用该名称进行工作。函数提供了这种能力。代码中重复出现一些常见模板，它们可以与许多不同的函数一起使用。这些模板也可以通过给它们命名来进行抽象。</p><p>为了将某些通用模板表达为具名概念(named concepts)，我们需要构造一种可以**”接受其他函数作为参数”<strong>或可以把</strong>可以把函数当作返回值**的函数。这种可以操作函数的函数就叫做高阶函数(high-order functions)。</p><hr><h3 id="1-6-1-作为函数的参数"><a href="#1-6-1-作为函数的参数" class="headerlink" title="1.6.1 作为函数的参数"></a>1.6.1 作为函数的参数</h3><p>现在有三个函数，分别是计算自然数之和，计算立方之和，计算一个收敛到Π的总和</p><div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">sum_naturals</span>(<span class="params">n</span>):</span><br><span class="line">    total, k = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> k &lt;= n:</span><br><span class="line">            total += k</span><br><span class="line">            k ++</span><br><span class="line">    <span class="keyword">return</span> total</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">sum_cubes</span>(<span class="params">n</span>):</span><br><span class="line">    total, k = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> k &lt;= n:</span><br><span class="line">            total, k = total + k*k*k, k+<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> total</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">pi_sum</span>(<span class="params">n</span>):</span><br><span class="line">    total, k = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> k &lt;= n:</span><br><span class="line">            total, k = total + (<span class="number">4</span>*k-<span class="number">3</span>)*(<span class="number">4</span>*k-<span class="number">1</span>) ,k + <span class="number">1</span> </span><br><span class="line">        <span class="keyword">return</span> total</span><br></pre></td></tr></table></figure></div><p>我们不难看出来，它们在背后共用的其实是一个模板，它们在很大程度上是相同的，仅在名称和用于计算被加项<code>k</code>的函数上有所不同。我们可以通过在同一模板中填充槽位(slots)来生成每个函数:</p><div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> &lt;name&gt;(n):</span><br><span class="line">    total, k = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> k &lt;= n:</span><br><span class="line">        total, k = total + &lt;term&gt;(k), k + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> total</span><br></pre></td></tr></table></figure></div><p>这种通用模板的封存在证明了有一个实用的抽象手段正在”浮出水面”。这些函数都是用来求和的，我们不妨编写一个表达求和概念的函数，方法是使用通用模板，并将槽位转换为形式参数:</p><p>接下来看一个例子，<code>summation</code>将上界<code>n</code>和计算第k项的函数<code>term</code>作为两个参数，并简洁地表达了求和。</p><div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">summation</span>(<span class="params">n, term</span>):</span><br><span class="line">    total, k = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> k&lt;=n:</span><br><span class="line">        total, k = total + term(k), k ++</span><br><span class="line">    <span class="keyword">return</span> total</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cube</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x*x*x</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sum_cubes</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">return</span> summation(n, cube)</span><br><span class="line"></span><br><span class="line">result = sum_cubes(<span class="number">3</span>)</span><br></pre></td></tr></table></figure></div><p>同样的，我们还可以利用返回其函数的<code>identity</code>函数，我们还可以使用完全相同的<code>summation</code>函数对自然数求和。</p><div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">summation</span>(<span class="params">n ,term</span>)</span><br><span class="line">total, k = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> k&lt;=n: </span><br><span class="line">        total, k = total + term(k), k ++</span><br><span class="line">    <span class="keyword">return</span> total</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">identity</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sum_naturals</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">return</span> summation(n, identity)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sum_naturals(<span class="number">10</span>)</span><br><span class="line"><span class="number">55</span></span><br></pre></td></tr></table></figure></div><p><code>summation</code>函数也可以直接调用，而无需为特定数列去定义另一个函数。</p><p><code>pi_sum</code>函数也可以如此，只要抽象的出来就可以。但是得有一个限制用的，例如一个精确值<code>1e6</code>以计算pi的近似值</p><div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">pi_term</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="number">8</span> / ((<span class="number">4</span>*x-<span class="number">3</span>) * (<span class="number">4</span>*x-<span class="number">1</span>))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pi_sum</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> smmation(n, pi_term)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pi_sum(<span class="number">1e6</span>)</span><br></pre></td></tr></table></figure></div><hr><h3 id="1-6-2作为通用方法的函数"><a href="#1-6-2作为通用方法的函数" class="headerlink" title="1.6.2作为通用方法的函数"></a>1.6.2作为通用方法的函数</h3><p>之前引入了”用户定义函数”，在有了高阶函数之后，会看到一种更强大的抽象，用一些函数来表达计算的通用方法，而且和它们调用的特定函数无关。</p><p>尽管我们对函数的意义进行了这些概念上的扩展，但我们用于查看“调用表达式如何求解”的环境模型可以优雅地、无需更改地扩展到高阶函数。当将用户定义的函数应用于某些参数时，形式参数将与局部帧中它们的值（参数可能是函数）绑定。</p><p>下面的例子实现了<strong>迭代改进(iterative improvement)的通用方法</strong>，并使它来计算黄金比例的值，黄金比例通常被称为phi，是一个接近1.6的数字。</p><p><strong>迭代改进算法</strong>从方程的<code>guess</code>解(推测值)开始，重复应用<code>update</code>函数来改进猜测，并调用<code>close</code>来比较当前的<code>guess</code>是否已经足够接近正确值</p><div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">improve</span>(<span class="params">update, close, guess = <span class="number">1</span></span>): <span class="comment">#给一个推测值</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> close(guess):  <span class="comment">#推测之不够接近</span></span><br><span class="line">        guess = update(guess) <span class="comment">#更新推测值</span></span><br><span class="line">    <span class="keyword">return</span> guess <span class="comment">#返回正确值</span></span><br></pre></td></tr></table></figure></div><p><strong>这个<code>improve</code>函数是迭代求精的的通用表达式，它并不指定要解决的问题，而是会将这些细节留给作为参数传入的<code>update</code>和<code>close</code>函数</strong></p><p>黄金比例的一个著名特性是它可以<strong>通过反复叠加任何正数的倒数加上1来计算</strong>，而且它比它的平方小1，我们可以将这些特性表示为与<code>improve</code>一起使用的函数</p><div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">goleden_update</span>(<span class="params">guess</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>/guess + <span class="number">1</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">square_close_to_successor</span>(<span class="params">guess</span>):</span><br><span class="line">    <span class="keyword">return</span> approx_eq(guess * guess, guess + <span class="number">1</span>)</span><br></pre></td></tr></table></figure></div><p>以上我们调用了<code>approx_eq</code>函数：如果其参数大致相等，则返回<code>True</code>。为了实现<code>approx_eq</code>，我们可以将两个数字差的绝对值与一个小的公差值(tolerance value)进行比较</p><div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">approx_eq</span>(<span class="params">x, y, tolerance=<span class="number">1e-15</span></span>):</span><br><span class="line">    retun <span class="built_in">abs</span>(x - y) &lt; tolerance</span><br></pre></td></tr></table></figure></div><p>使用参数<code>golden_update</code>和<code>square_close_to_successor</code>来调用<code>improve</code>将会计算出黄金比例的有限近似值。</p><div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>improve(golden_update, square_close_to_successor)</span><br></pre></td></tr></table></figure></div><p>通过追踪求解的步骤，我们可以看到这个结果是如何计算出来的。首先，将 <code>update</code>、<code>close</code> 和 <code>guess</code> 绑定在构造 <code>improve</code> 的局部帧上。然后在 <code>improve</code> 的函数体中，将名称 <code>close</code> 绑定到 <code>square_close_to_successor</code> ，它会使用 <code>guess</code> 的初始值进行调用。</p><div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">improve</span>(<span class="params">update, close, guess = <span class="number">1</span></span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> close(guess):</span><br><span class="line">        guess = update(guess)</span><br><span class="line">    <span class="keyword">return</span> guess</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">golden_update</span>(<span class="params">guess</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> / guess + <span class="number">1</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">square_close_to_successor</span>(<span class="params">guess</span>):</span><br><span class="line">    <span class="keyword">return</span> approx_eq(guess * guess, guess + <span class="number">1</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">approx_eq</span>(<span class="params">x, y, tolerance=<span class="number">1e-3</span></span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">abs</span>(x - y) &lt; tolerance</span><br><span class="line">phi = improve(golden_update, square_close_to_successor)</span><br></pre></td></tr></table></figure></div><hr><p><del>突然想起来一句话，虽然算法对于程序来讲非常的重要，但是对于一个臃肿的程序运行起来肯定时间很长，但是如果有了算法的加持，那么这个程序跑起来就会很快，所有的进程运行起来就会很流畅。因此就可以在类似例如打开应用的时候做出一些比较精美的打开动画，但是其实，臃肿也不代表不能用，对于现在而言，能够开发出来就已经很不错了，如果一味追求动画的优雅和流畅而连一个正常的APP都开发不出来的话，那么不久本末倒置了。</del></p><p>一点废话，当我没说</p><hr><p>这个例子说明了计算机科学中两个相关的重要思想：首先，命名和函数能使我们将大量的复杂事务进行抽象。虽然每个函数定义都很简单，但是求解程序出发的计算过程非常复杂。其次，正是我们对Python有一个及其通用的求解过程，小的组件才能组合成复杂的程序。理解解释程序的求解过程有便于我们验证和检查我们创建的程序。</p><hr><h3 id="1-6-3-定义函数III-嵌套定义"><a href="#1-6-3-定义函数III-嵌套定义" class="headerlink" title="1.6.3 定义函数III:嵌套定义"></a>1.6.3 定义函数III:嵌套定义</h3><p>上面的示例演示了将函数作为参数传递的能力显著地增强编程语言的表达能力。每个通用概念或方程都能映射到自己的小型函数上，但这种方法的一个负面后果是<strong>全局帧会变得混乱</strong>，因为小型函数的名称必须都是唯一的。另一个问题是我们受到<strong>特定函数签名的限制</strong>：<code>improve</code> 的 <code>update</code> 参数只能接受一个参数。<strong>嵌套函数定义</strong>（Nested function definition）解决了这两个问题，但需要我们丰富一下环境模型。</p><p>那么上述的方法是不是可以拿来计算一个数的平方根呢？重复以下更新，值会收敛为的平方根。</p><div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">average</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">return</span> (x + y)/<span class="number">2</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sqrt_update</span>(<span class="params">x, a</span>):</span><br><span class="line">    <span class="keyword">return</span> average(x, a/x)</span><br></pre></td></tr></table></figure></div><p>但是这个双参数更新函数和<code>improve</code>函数不兼容(他有两个参数，而不是一个)，而且它只提供一次更新，但是我们真正想要的是通过重复更新求平方根。这两个问题的解决方案是将函数定义放在其他函数的主体中。</p><div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sqrt</span>(<span class="params">a</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sqrt_update</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="keyword">return</span> average(x, a/x)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sqrt_close</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="keyword">return</span> approx_eq(x * x, a)</span><br><span class="line">    <span class="keyword">return</span> improve(sqrt_update, sqrt_close)</span><br></pre></td></tr></table></figure></div><p>与局部赋值一样，这些函数之影响当前局部帧。这些函数尽在求解<code>sqrt</code>时在作用域内。与求解过程一致，局部在调用函数前不会被求解。</p><p>词法作用域（Lexical scope）：局部定义的函数也可以访问定义作用域内的名称绑定。在此示例中， <code>sqrt_update</code> 引用名称 <code>a</code>，它是其封闭函数 <code>sqrt</code> 的形式参数。这种在<strong>嵌套定义之间共享名称的规则称为词法作用域</strong>。最重要的是，<strong>内部函数可以访问定义它们的环境中的名称</strong>（而不是它们被调用的位置）。</p><p> 如果想要启用词法作用域，得实现两个扩展</p><ol><li>每个用户定义的函数都有一个定义这个函数的父环境。</li><li>在调用用户定义的函数的时候，它的局部frame会继承父环境。</li></ol><p>在调用创建的sqrt的函数之前，所有的函数都是在全局环境中定义的。因此他们的父级都是全局环境。相比之下，当计算<code>sqrt</code>的前两个子句的时候，在这次调用中，它会创建局部环境关联的函数。</p><p>环境先为<code>sqrt</code>添加一个局部frame，然后求解<code>sqrt_update</code>和<code>sqrt_close</code>的def语句。</p><p>通过可视化网站我们可以得出Python中词法作用域的两个关键优势</p><ul><li>局部函数的名称不会影响定义它的函数的外部名称，因为局部函数的名称将绑定在定义它的当前局部环境中，而不是全局环境中。</li><li>局部函数可以访问外层函数的环境，这是因为局部函数的函数体的求值环境会继承定义它的求值环境。</li></ul><p>局部定义的函数通常被称为闭包。(closures)</p><hr><h3 id="1-6-4-作为返回值的函数"><a href="#1-6-4-作为返回值的函数" class="headerlink" title="1.6.4 作为返回值的函数"></a>1.6.4 作为返回值的函数</h3><p>通过创建”返回值就是函数”的函数，我们可以在程序中实现更强大的表达能力。带有词法作用域的编程语言的一个重要特性就是，局部定义函数在它们返回时仍持有所关联的环境。</p><p>一旦定义了许多简单的函数，函数组合(composition)就称为编程语言中的一种自然的组合方法。也就是说，给定两个函数<code>f(x)</code>和<code>g(x)</code>，我们可能想要定义<code>h(x) = f(g(x))</code>。我们可以使用我们现有的工具定义函数组合:</p><div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">compose1</span>(<span class="params">f, g</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">h</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="keyword">return</span> f(g(x))</span><br><span class="line">    <span class="keyword">return</span> h</span><br></pre></td></tr></table></figure></div><p> 下面是一个例子,展示了如何正确解析名称<code>f</code>和<code>g</code>，即使它们存在名称冲突</p><div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">square</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x * x</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">successor</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x + <span class="number">1</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">compose1</span>(<span class="params">f, g</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">h</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="keyword">return</span> f(g(x))</span><br><span class="line">    <span class="keyword">return</span> h</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="string">&quot;Never Called.&quot;</span></span><br><span class="line">    <span class="keyword">return</span> -x</span><br><span class="line"></span><br><span class="line">square_successor = compose1(square, successor)</span><br><span class="line">result = square_successor(<span class="number">12</span>)</span><br></pre></td></tr></table></figure></div><p><code>compose1</code>中的1表示这个组合的函数只有一个参数。这个命名惯例不是解释器强制要求的，1只是函数名的一部分。</p><p>在这点上，我们已经能够察觉到努力去精确定义计算环境模型的好处：不需要修改环境模型就可以解释如何以这种方式来返回函数。</p><hr><h3 id="1-6-5-示例：牛顿法"><a href="#1-6-5-示例：牛顿法" class="headerlink" title="1.6.5 示例：牛顿法"></a>1.6.5 示例：牛顿法</h3><p>这个拓展的示例展示了函数和局部定义如何协同工作，以简洁地表达一般的思想。我们将实现一种广泛用于机器学习，科学计算、硬件设计和优化的算法。</p><p>牛顿法(Newton’s method)是一种经典的迭代方法，用于查找返回值为0地数学函数地参数。这些值(参数)称为函数的零点(Zero)。找到函数的零点通常等同于解决了其他一些有趣的问题，例如求平方根。</p><p>这个操作在现代看来是非常便捷的，但是学习计算机科学的一部分是理解这样的量是如何计算的，此处介绍的一般方法适用于求解Python内置方程之外的一大类方程。</p><p>牛顿法也是一种迭代改进算法，他会对所有可微函数的零点的猜测值进行改进，这意味着它可以在任意点用直线进行近似处理。牛顿的方法遵循这些线性近似(linear approximations)来找到函数零点。</p><p>试想一条穿过点(x, f(x))的直线与函数f(x)在该点拥有相同的斜率。这样的直线称为切线(tangent)，它的斜率我们称为f在x处的导数</p><p>这条直线的斜率是函数值变化量与函数自变量的比值。所以，按照f(x)除以这个斜率来平移x，就会得到切线到达0时的自变量的值。</p><p><code>newton_update</code>表示函数f及其导数df沿着这条切线到0的计算过程</p><div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">newton_update</span>(<span class="params">f, df</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="keyword">return</span> x - f(x) / df(x)</span><br><span class="line">    <span class="keyword">return</span> update</span><br></pre></td></tr></table></figure></div><p>最后，我们可以使用<code>newton_update</code>、<code>improve</code>算法以及比较f(x)是否接近0来定义<code>find_root</code>函数。</p><div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">find_zero</span>(<span class="params">f, df</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">near_zero</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="keyword">return</span> approx_eq(f(x), <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> improve(newton_update(f, df), near_zero)</span><br></pre></td></tr></table></figure></div><p>计算根：我们可以使用牛顿法来计算任意次方根。</p><p>如果我们可以找到最后一个方程的零点，那么我们就可以计算出n次方根。通过绘制n&#x3D;2、3、6，a&#x3D;64的曲线，我们可以将这种关系可视化</p><p>我们首先通过定义f和它的导数df来实现<code>square_root</code>函数，使用微积分中的知识，f(x)&#x3D;x²-a的导数是线性方程df(x) &#x3D; 2x。</p><div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">square_root_newton</span>(<span class="params">a</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="keyword">return</span> x * x - a</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">df</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * x</span><br><span class="line">    <span class="keyword">return</span> find_zero(f, df)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>square_root_newton(<span class="number">64</span>)</span><br><span class="line"><span class="number">8.0</span></span><br></pre></td></tr></table></figure></div><p>推广到n次方根，我们可以得到f(x)&#x3D;x^n-a和它的导数df(x) &#x3D; nx^n-1</p><div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">power</span>(<span class="params">x, n</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;返回n个x相乘&quot;&quot;&quot;</span></span><br><span class="line">    product, k = <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> k &lt; n:</span><br><span class="line">        product, k = product*x, k + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> product</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">nth_root_of_a</span>(<span class="params">n, a</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pow</span>(x, n) - a</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">df</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="keyword">return</span> n * power(x, n-<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> find_zero(f, df)</span><br></pre></td></tr></table></figure></div><p>所有这些计算中的近似误差都可以通过将<code>approx_eq</code>中的公差tolerance改为更小的数字来减小</p><p>当1使用牛顿法时，要注意它并不总是收敛的。<code>improve</code>的初始猜测必须足够接近零，并且必须满足有关函数的各种条件。尽管有这个缺点，牛顿法仍是一种用于求解微积分方程的强大的通用计算方法。现代计算机技术中的对数和大整数除法的快速算法，都采用了该方法的变体。</p><hr><h3 id="1-6-6-柯里化"><a href="#1-6-6-柯里化" class="headerlink" title="1.6.6 柯里化"></a>1.6.6 柯里化</h3><p>我们可以使用高阶函数将一个接受多个参数的函数转换为一个函数链，每个函数接受一个参数。</p><p>给定一个函数<code>f(x, y)</code>可以定义另一个函数<code>g</code>使得<code>g(x)(y) == f(x, y)</code>。g是一个高阶函数，它接受单个参数x并返回另一个接受单个参数y的函数。这种转化称为<strong>柯里化</strong></p><p>例如pow函数的柯里化版本</p><div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">curried_pow</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">h</span>(<span class="params">y</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pow</span>(x, y)</span><br><span class="line">    <span class="keyword">return</span> h</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>curried_pow(<span class="number">2</span>)(<span class="number">3</span>)</span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure></div><p>​感觉就是在嵌套函数的基础上，通过定义一个新的函数，然后传入两个参数，主函数返回定义的新的函数的值即可。</p><p>例如我们计算2的前10次方，我们就可以不用专门编写一个函数来实现。而是</p><div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>map_to_range(<span class="number">0</span>, <span class="number">10</span>, curried_pow)</span><br><span class="line">...</span><br></pre></td></tr></table></figure></div><p>我们可以类似地使用相同的两个函数来计算其他数字的幂。柯里化允许我们这么做，而无需为每个数字编写特定的函数。</p><p>上面，我们对<code>pow</code>进行了柯里化变换，得到了<code>curried_pow</code>。相反，我们可以定义函数来自动进行柯里化，以及逆柯里化变换。</p><div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">curry2</span>(<span class="params">f</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;返回给定的双参数函数的柯里化版本&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">g</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">h</span>(<span class="params">y</span>):</span><br><span class="line">            <span class="keyword">return</span> f(x, y)</span><br><span class="line">        <span class="keyword">return</span> h</span><br><span class="line">    <span class="keyword">return</span> g</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cuury2</span>(<span class="params">g</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;返回给定的柯里化函数的双参数版本&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">x, y</span>):</span><br><span class="line">        <span class="keyword">return</span> g(x, y)</span><br><span class="line">    <span class="keyword">return</span> f</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pow_curried = curried2(<span class="built_in">pow</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pow_curried(<span class="number">2</span>)(<span class="number">5</span>)</span><br><span class="line"><span class="number">32</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>map_to_range(<span class="number">0</span>, <span class="number">10</span>, pow_curried(<span class="number">2</span>))</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line">...</span><br><span class="line"><span class="number">512</span></span><br></pre></td></tr></table></figure></div><p><code>curry2</code>函数接受一个双参数函数<code>f</code>并返回一个单参数函数<code>g</code>。当<code>g</code>应用于参数<code>x</code>时，它返回一个单参数函数<code>h</code>。当<code>h</code>应用于参数y时，它调用<code>f(x, y)</code>。因此，<code>curry2(f)(x)(y)</code>等价于<code>f(x, y)</code>。<code>uncurry2</code>函数反转了柯里化变换，因此<code>uncurry2(curry2(f))</code>等价于<code>f</code></p><div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>uncurry2(pow_curried)(<span class="number">2</span>, <span class="number">5</span>)</span><br><span class="line"><span class="number">32</span></span><br></pre></td></tr></table></figure></div><hr><h3 id="1-6-7-Lambda表达式"><a href="#1-6-7-Lambda表达式" class="headerlink" title="1.6.7 Lambda表达式"></a>1.6.7 Lambda表达式</h3><p>在Python中，我们可以使用lambda表达式临时创建函数，这些表达式会计算为未命名的函数。一个lambda表达式的计算结果是一个<strong>函数</strong>，它仅有一个返回表达式作为主体。不允许使用赋值和控制语句。</p><div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">compose</span>(<span class="params">f, g</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">lambda</span> x: f(g(x))</span><br></pre></td></tr></table></figure></div><p>我们可以通过构造相应的英文句子来理解lambda表达式的结构</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lambda                    x                  :                  f(g(x))</span><br><span class="line">&quot;A function that          takes x            and returns        f(g(x))&quot;</span><br></pre></td></tr></table></figure></div><p>lambda表达式的结果称为lambda函数(匿名函数)。它没有固有名称，但除此之外它的行为与任何其他函数都相同</p><div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="keyword">lambda</span> x: x * x</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">&lt;function &lt;<span class="keyword">lambda</span>&gt; at ......</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s(<span class="number">12</span>)</span><br><span class="line"><span class="number">144</span></span><br></pre></td></tr></table></figure></div><p>从环境图当中来看的话，lambda表达式的结果也是一个函数，以希腊字母λ(lambda)命名。我们的<code>compose</code>示例就可以用lambda表达式非常简洁的表示出来</p><div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">compose1</span>(<span class="params">f, g</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">lambda</span> x: f(g(x))</span><br><span class="line">f = compose1(<span class="keyword">lambda</span> x: x * x, <span class="keyword">lambda</span> y: y + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">result = f(<span class="number">12</span>)</span><br></pre></td></tr></table></figure></div><p>虽然lambda表达式这种方式更短更直接。然而，它确实出了名的难以辨认。</p><p>一般来说，Python style更喜欢使用明确的<code>def</code>语句哈不是lambda表达式，但在需要简单函数作为参数或返回值的情况下可以使用它们。</p><hr><h3 id="1-6-8-抽象和一等函数"><a href="#1-6-8-抽象和一等函数" class="headerlink" title="1.6.8 抽象和一等函数"></a>1.6.8 抽象和一等函数</h3><p>作为程序员，我们应该警觉地寻找发现我们程序中的基本抽象，然后对其进行扩展，并加以推广去创建更强大的抽象。要选择符合任务地抽象级别。不过，重要的是我们能够思考这些抽象的概念，然后准备好将其应用到新的环境中。高阶函数的重要性在于，它们使我们将这些抽象显示地表示为我们编程语言中的元素，以便可以像其他元素一样处理。</p><p>一般而言，编程语言会对计算元素的操作方式施加限制。拥有最少限制的元素可以获得一等地位(first-class status)。这些一等元素的”权力和特权包括”</p><ol><li>可以与名称保定</li><li>可以作为参数传递给函数</li><li>可以作为函数的结果返回</li><li>可以包含在数据结构中</li></ol><p>Python授予函数完全的一等地位，由此带来的表达能力的提升是巨大的。</p><hr><h3 id="1-6-9-函数装饰器"><a href="#1-6-9-函数装饰器" class="headerlink" title="1.6.9 函数装饰器"></a>1.6.9 函数装饰器</h3><p>Python提供了一种特殊的语法来使用高阶函数作为执行<code>def</code>语句地一部分，称为装饰器(decorator)。最常见的例子也许就是<code>trace</code></p><div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">trace</span>(<span class="params">fn</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapped</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;-&gt;&#x27;</span>, fn, <span class="string">&#x27;(&#x27;</span>, x, <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> fn(x)</span><br><span class="line">    <span class="keyword">return</span> wrapped</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>@trace</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">triple</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span> * x</span><br><span class="line">    </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>triple(<span class="number">12</span>)</span><br><span class="line">-&gt; &lt;function triple at ... &gt;(<span class="number">12</span>)</span><br><span class="line"><span class="number">36</span></span><br></pre></td></tr></table></figure></div><p><code>triple</code>的<code>def</code>语句有一个注释(annotation)<code>@trace</code>，它会影响<code>def</code>执行的规则。和往常一样，函数<code>triple</code>被创建了。但是名称triple不会绑定到这个函数上，相反，这个名称会被绑定到在新定义的<code>triple</code>函数调用<code>trace</code>后返回的函数值上。代码中，这个装饰器等价于</p><div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">triple</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span> * x</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>triple = trace(triple)</span><br></pre></td></tr></table></figure></div><p>在本教材相关的项目中，装饰器被用于追踪，以及在从命令行运行程序时选择要调用哪些函数。</p><p>对于专家的额外内容：装饰器符号<code>@</code>也可以后跟一个调用表达式。跟在@后面的表达式会先被解析，然后是def语句，最后将装饰器表达式的运算结果应用到新定义的函数上，并将结果绑定到<code>def</code>语句中的名称上</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-6-高阶函数&quot;&gt;&lt;a href=&quot;#1-6-高阶函数&quot; class=&quot;headerlink&quot; title=&quot;1.6 高阶函数&quot;&gt;&lt;/a&gt;1.6 高阶函数&lt;/h1&gt;&lt;p&gt;我们已知函数是一种抽象方法，描述了与&lt;strong&gt;特定参数&lt;/strong&gt;无关的&lt;str</summary>
      
    
    
    
    <category term="CS61A" scheme="https://primeluoqiu.github.io/categories/CS61A/"/>
    
    
  </entry>
  
  <entry>
    <title>3.1-3 概述和传输层服务、多路复用和解复用、无连接传输UDP</title>
    <link href="https://primeluoqiu.github.io/2024/04/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.1-3/"/>
    <id>https://primeluoqiu.github.io/2024/04/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.1-3/</id>
    <published>2024-04-08T12:35:27.048Z</published>
    <updated>2024-04-08T12:37:36.010Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/04/08/QwEk2fO6.jpg"                      alt="61.jpg"                ><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/04/08/Zjtl3ltv.jpg"                      alt="62.jpg"                ><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/04/08/uDSZt1vB.jpg"                      alt="63.jpg"                ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;https://img2.imgtp.com</summary>
      
    
    
    
    <category term="计网" scheme="https://primeluoqiu.github.io/categories/%E8%AE%A1%E7%BD%91/"/>
    
    
  </entry>
  
  <entry>
    <title>第五周总结 + 第六周学习计划</title>
    <link href="https://primeluoqiu.github.io/2024/04/07/%E6%AF%8F%E5%91%A8%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/Week6/"/>
    <id>https://primeluoqiu.github.io/2024/04/07/%E6%AF%8F%E5%91%A8%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/Week6/</id>
    <published>2024-04-07T13:38:15.326Z</published>
    <updated>2024-04-07T13:41:49.446Z</updated>
    
    <content type="html"><![CDATA[<h4 id="第五周总结"><a href="#第五周总结" class="headerlink" title="第五周总结"></a>第五周总结</h4><p>其实本周内容还是把最最主要的计网完成了，不过看起来计网后面的题目相对来说还是比较难的。得认真地的看一下对应的题目。<br>然后就是准备蓝桥杯和复习来着，蓝桥杯好像是下周六，本周还是以计网和蓝桥杯为主吧，其余的话看情况学，底层还是要继续的</p><h5 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h5><p>1.计网看完第三章节，然后复习一下之前的两章<br>2.蓝桥杯复习<br>3.CS系列课程，记得更新就好<br>4.看点面向对象的语言</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;第五周总结&quot;&gt;&lt;a href=&quot;#第五周总结&quot; class=&quot;headerlink&quot; title=&quot;第五周总结&quot;&gt;&lt;/a&gt;第五周总结&lt;/h4&gt;&lt;p&gt;其实本周内容还是把最最主要的计网完成了，不过看起来计网后面的题目相对来说还是比较难的。得认真地的看一下对应的题目。&lt;</summary>
      
    
    
    
    <category term="大二下" scheme="https://primeluoqiu.github.io/categories/%E5%A4%A7%E4%BA%8C%E4%B8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>2.9 UDP套接字编程 + 本章小节</title>
    <link href="https://primeluoqiu.github.io/2024/04/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.9/"/>
    <id>https://primeluoqiu.github.io/2024/04/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.9/</id>
    <published>2024-04-07T03:50:18.322Z</published>
    <updated>2024-04-07T03:50:54.070Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/04/07/E2uC02S0.jpg"                      alt="59.jpg"                ><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/04/07/m8szHXnc.jpg"                      alt="60.jpg"                ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;https://img2.imgtp.com</summary>
      
    
    
    
    <category term="计网" scheme="https://primeluoqiu.github.io/categories/%E8%AE%A1%E7%BD%91/"/>
    
    
  </entry>
  
  <entry>
    <title>2.8 TCP套接字编程</title>
    <link href="https://primeluoqiu.github.io/2024/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.8/"/>
    <id>https://primeluoqiu.github.io/2024/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.8/</id>
    <published>2024-04-06T13:57:31.127Z</published>
    <updated>2024-04-06T13:59:01.246Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/04/06/uMODHIAC.jpg"                      alt="56.jpg"                ><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/04/06/ZW10ZehE.jpg"                      alt="57.jpg"                ><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/04/06/MBxZIUZg.jpg"                      alt="58.jpg"                ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;https://img2.imgtp.com</summary>
      
    
    
    
    <category term="计网" scheme="https://primeluoqiu.github.io/categories/%E8%AE%A1%E7%BD%91/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://primeluoqiu.github.io/2024/04/06/Algorithm/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/%E7%AC%AC%E4%B8%80%E7%AB%A0/"/>
    <id>https://primeluoqiu.github.io/2024/04/06/Algorithm/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/%E7%AC%AC%E4%B8%80%E7%AB%A0/</id>
    <published>2024-04-06T13:55:22.142Z</published>
    <updated>2024-04-06T13:54:09.345Z</updated>
    
    <content type="html"><![CDATA[<h3 id="深度优先搜索-DFS"><a href="#深度优先搜索-DFS" class="headerlink" title="深度优先搜索(DFS)"></a>深度优先搜索(DFS)</h3><p>很执着，尽可能的往深搜。当搜不到的时候回溯，然后回溯完之后看看，当前是不是所有的路径都遍历过了。</p><p>对于数据结构来讲：使用的是栈</p><p>空间：O(n)</p><p>不具有最短性</p><p>第一次搜索完之后不一定具备最短性</p><p>存在两个概念</p><h4 id="概念1：回溯"><a href="#概念1：回溯" class="headerlink" title="概念1：回溯"></a>概念1：回溯</h4><h4 id="概念2：剪枝"><a href="#概念2：剪枝" class="headerlink" title="概念2：剪枝"></a>概念2：剪枝</h4><p>DFS最重要的是顺序，要考虑是用一个什么样的顺序来比遍历整个方案。想不清楚的话画棵树考虑一下。</p><p>对于本题而言，顺序有很多种，这里的搜索顺序是假设我们已经有n个空位了，从第一位开始填，从前往后填，每次填的时候数字不能和前面一样就可以了。最开始状态是n个空，第一位有三种填法，分别对应三个不同的分支。深搜的话会继续往下搜，也就是搜第二个位置，第二个位置也有三种方案。但是深搜的时候不会把方案先画出来，直接走到黑。第二位枚举一下，第一位确定了是1，那第二位肯定不能是1，因为重复了，第二位只能先填2，优先往下走，就只剩第三位，那么第三位就只剩下3了，这个时候分支对应的就是123，已经无路可走，然后回退一步。回到填写第二位的时候，发现第二位还有一条路可以走，还可以填3，那么就填上3，就是有3的分支，那么132，再回溯，无路可走，在回溯，回到根节点，这个时候就要枚举2这个分支。</p><p>求全排列的过程，是可以用DFS来做的。搜索顺序可以看成一棵树。当然只是看成一棵树，每次存的时候存储的都是路径，回溯的时候就没了，不需要存数和栈。在回溯的时候一定要记得回复现场。下去的时候是什么样子，回溯回来的话还得是那个样子。走的时候分支看到的状态是一样的。</p><p>看一下代码怎么写：</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> path[N]; <span class="comment">//状态用一个全局数组来存,存储的是方案 </span></span><br><span class="line"><span class="type">bool</span> st[N]; <span class="comment">//true表示点被用过了</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> u)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//当完美走到n,说明全部填满了</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n;i ++) <span class="built_in">cout</span> &lt;&lt; path[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!st[i])</span><br><span class="line">        &#123;</span><br><span class="line">            path[u] = i; <span class="comment">//i放到当前位置上</span></span><br><span class="line">            st[i] = <span class="literal">true</span>; <span class="comment">//记录i已经被用过了</span></span><br><span class="line">            dfs(u + <span class="number">1</span>); <span class="comment">//状态处理好之后递归到下一层</span></span><br><span class="line">            st[i] = <span class="literal">false</span>; <span class="comment">//恢复现场 path不需要回复，会覆盖，递归函数结束之后一定要记得恢复。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    dfs(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>还有一个经典的N皇后问题，有很多种搜索方式</p><p>​在n*n的棋盘上放n个皇后，皇后可以横竖斜着走，让任何两个皇后不能互相攻击到，给定一个n，输出所有的方案</p><p>比如说：搜索全排列的思路是一样的，搜索顺序是：先看一下同一行同一列只放一个皇后，先看第一行皇后可以放在那一列。枚举每一行皇后可以放到哪里去。从第一位开始枚举。递归枚举第二行皇后放到那…这里要注意<strong>剪枝</strong>。这是按照全排列的方法来枚举。</p><p>也可以先生成一个全排列，然后再判断。也是可以的。</p><p>蛋柿呢，也可以边做边判断，假设枚举了一个4，直接判断有没有冲突，如果有冲突，就不用再往下走，直接停止了。可以看作是把枝剪掉，直接回溯，这就是剪枝了。</p><p>那么这种方法对应的解决方案是</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">20</span>;</span><br><span class="line"><span class="type">bool</span> col[N], dg[N], udg[N];</span><br><span class="line"><span class="type">char</span> g[N][N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u == n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) <span class="built_in">puts</span>(g[i]);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!col[i] &amp;&amp; !dg[u + i] &amp;&amp; !udg[n - u + i])</span><br><span class="line">        &#123;</span><br><span class="line">            g[u][i] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">            col[i] = dg[u + i] = udg[n - u + i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(u + <span class="number">1</span>);</span><br><span class="line">            col[i] = dg[u + i] = udg[n - u + i] = <span class="literal">false</span>;</span><br><span class="line">            g[u][i] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++)</span><br><span class="line">            g[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>没有模板，只有顺序和思路。</p><p>除了这种方式之外，我们还可以用一种更原始的方式来解决这种问题。也就是说，对于每个点而言，都有两种状态，分别是放或者不放这两种分支，然后我们挨个枚举所有格子，当枚举到n²格子的时候，就结束了。这个更加原始，更加接近题目的选项的方式</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">20</span>;</span><br><span class="line"><span class="type">bool</span> row[N], col[N], dg[N], udg[N];</span><br><span class="line"><span class="type">char</span> g[N][N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(y == n) y = <span class="number">0</span>, x ++;</span><br><span class="line">    <span class="keyword">if</span>(x == n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s == n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n; i ++) <span class="built_in">puts</span>(g[i]);</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//不放皇后</span></span><br><span class="line">    <span class="built_in">dfs</span>(x, y + <span class="number">1</span>, s);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//放皇后</span></span><br><span class="line">    <span class="keyword">if</span>(!row[x] &amp;&amp; !col[y] &amp;&amp; !dg[x + y] &amp;&amp; !udg[x - y + n])</span><br><span class="line">    &#123;</span><br><span class="line">        g[x][y] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">        row[x] = col[y] = dg[x + y] = udg[x - y + n] = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(x, y + <span class="number">1</span>, s + <span class="number">1</span>);</span><br><span class="line">        row[x] = col[y] = dg[x + y] = udg[x - y + n] = <span class="literal">false</span>;</span><br><span class="line">        g[x][y] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++)</span><br><span class="line">            g[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="宽度优先搜索-BFS"><a href="#宽度优先搜索-BFS" class="headerlink" title="宽度优先搜索(BFS)"></a>宽度优先搜索(BFS)</h3><p>按层搜索。同时看很多条路，第一次看第一层，第二次看第二层。第二层搜完之后再搜第三层。每次只扩展一层。</p><p>数据结构：队列</p><p>空间：O(n^2)</p><p>有最短路的概念，第一次扩展到的点，一定是离他最近的点</p><p>为什么可以呢？是一圈一圈往外扩展，可以搜到的点是离起点越来越远的。第一次搜到的一定是距离最小的。前提是图里的边权重必须都得是1.</p><h3 id="树与图的存储"><a href="#树与图的存储" class="headerlink" title="树与图的存储"></a>树与图的存储</h3><h3 id="树与图的深度优先遍历"><a href="#树与图的深度优先遍历" class="headerlink" title="树与图的深度优先遍历"></a>树与图的深度优先遍历</h3><h3 id="树与图的宽度优先遍历"><a href="#树与图的宽度优先遍历" class="headerlink" title="树与图的宽度优先遍历"></a>树与图的宽度优先遍历</h3><h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;深度优先搜索-DFS&quot;&gt;&lt;a href=&quot;#深度优先搜索-DFS&quot; class=&quot;headerlink&quot; title=&quot;深度优先搜索(DFS)&quot;&gt;&lt;/a&gt;深度优先搜索(DFS)&lt;/h3&gt;&lt;p&gt;很执着，尽可能的往深搜。当搜不到的时候回溯，然后回溯完之后看看，当前是不</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Ts快速入门</title>
    <link href="https://primeluoqiu.github.io/2024/04/06/HarmonyOsDeveloper/Ts%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
    <id>https://primeluoqiu.github.io/2024/04/06/HarmonyOsDeveloper/Ts%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</id>
    <published>2024-04-05T16:37:05.386Z</published>
    <updated>2024-04-05T16:42:07.571Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h3><p>赋值语句:<code>let 变量名: 变量类型  = 值</code></p><p>变量类型还是布尔值、数字、字符串(单引号双引号都可以)、数组、元组、枚举、Unknown、Void和Undefined以及联合类型</p><p>数字：</p><p>所有数字全部都是浮点数，类型是<code>number</code>。支持标准进制</p><div class="highlight-container" data-rel="Ts"><figure class="iseeu highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">decLiteral</span>: <span class="built_in">number</span> = <span class="number">2023</span>;</span><br></pre></td></tr></table></figure></div><p>两种定义方式:</p><p>元素后+[]，表示由此类型元素组成的一个数组</p><div class="highlight-container" data-rel="Typescript"><figure class="iseeu highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">list</span>: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure></div><p>第二种:使用数组泛型，Array&lt;元素类型&gt;</p><div class="highlight-container" data-rel="Ts"><figure class="iseeu highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">list</span>: <span class="title class_">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure></div><p>元组：元组类型允许表示一个已知元素数量和类型的数组。各元素的类型不必相同。比如，可以定义一对值分别为<code>string</code>和<code>number</code>类型的元组，顺序不可相反</p><div class="highlight-container" data-rel="Ts"><figure class="iseeu highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">x</span>: [<span class="built_in">string</span>, <span class="built_in">number</span>];</span><br><span class="line">x = [<span class="string">&#x27;hello&#x27;</span>, <span class="number">10</span>];</span><br></pre></td></tr></table></figure></div><p>枚举：</p><p><code>enum</code>类型是对js标准数据类型的一个补充，使用枚举类型可以为一组数值赋予友好的名字</p><div class="highlight-container" data-rel="Ts"><figure class="iseeu highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;<span class="title class_">Red</span>, <span class="title class_">Green</span>, <span class="title class_">Blue</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">c</span>: <span class="title class_">Color</span> = <span class="title class_">Color</span>.<span class="property">Green</span>; </span><br></pre></td></tr></table></figure></div><p>Unknow:为编程阶段还尚不清楚类型的变量指定一个类型。在这种情况下，不希望类型检查器对这些值进行检查而实直接通过编译阶段的检查。便可以使用Unknown</p><p>Void还是出现在函数返回值类型。</p><p>在ts中，undefined和null各自有自己的类型分别叫做undefined和null</p><p>联合类型(Union Type): 取值可以为多种类型中的一种</p><div class="highlight-container" data-rel="Ts"><figure class="iseeu highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">myFavouriteNumver</span>: <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line">myFavouriteNumber = <span class="string">&#x27;seven&#x27;</span>;</span><br><span class="line">myFavouriteNumber = <span class="number">7</span>;</span><br></pre></td></tr></table></figure></div><hr><h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><p>通过一条或者多条的执行结果来决定执行的代码块</p><h4 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h4><div class="highlight-container" data-rel="Ts"><figure class="iseeu highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="attr">num</span>: <span class="built_in">number</span> = <span class="number">5</span></span><br><span class="line"><span class="keyword">if</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;数字是正数&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>其他的和C语言类似</p><h4 id="switch…case语句"><a href="#switch…case语句" class="headerlink" title="switch…case语句"></a>switch…case语句</h4><div class="highlight-container" data-rel="Ts"><figure class="iseeu highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="attr">grade</span>: <span class="built_in">string</span> = <span class="string">&#x27;A&#x27;</span></span><br><span class="line"><span class="keyword">switch</span>(grade) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>: &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;优秀&#x27;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span>: &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;良&#x27;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span>: &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;及格&#x27;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attr">default</span>: &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;非法输入&#x27;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><hr><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>是一组一起执行一个任务的语句，函数声明要告诉编译器函数的名称、返回类型和参数。Ts可以创建有名的函数和匿名函数，创建方法如下</p><div class="highlight-container" data-rel="Ts"><figure class="iseeu highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//有名函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//匿名函数</span></span><br><span class="line"><span class="keyword">let</span> myAdd = <span class="keyword">function</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><h4 id="为函数定义类型"><a href="#为函数定义类型" class="headerlink" title="为函数定义类型"></a>为函数定义类型</h4><p>为了确保输入输出的准确性，我们可以为函数添加类型:</p><div class="highlight-container" data-rel="Ts"><figure class="iseeu highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有名函数: 给变量设置为number类型</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匿名函数: 给变量设置为number类型</span></span><br><span class="line"><span class="keyword">let</span> myAdd = <span class="keyword">function</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h4><p>在Ts里可以在参数名旁边使用<code>?</code>实现可选参数的功能。比如，我们想让lastName是可选的:</p><div class="highlight-container" data-rel="Ts"><figure class="iseeu highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">buildName</span>(<span class="params">firstName: <span class="built_in">string</span>, lastName?: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(lastName)</span><br><span class="line">        <span class="keyword">return</span> firstName + <span class="string">&#x27; &#x27;</span> + lastName;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> firstName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = <span class="title function_">buildName</span>(<span class="string">&#x27;Bob&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> result2 = <span class="title function_">buildName</span>(<span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Adams&#x27;</span>);</span><br></pre></td></tr></table></figure></div><h4 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h4><p>剩余参数会被当做个数不限的可选参数，可以一个都没有，同样也可以有任意个。可以使用省略号(…)进行定义:</p><div class="highlight-container" data-rel="Ts"><figure class="iseeu highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getEmployeeName</span>(<span class="params">firstName: <span class="built_in">string</span>, ...restOfName: <span class="built_in">string</span>[]</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> firstName + <span class="string">&#x27; &#x27;</span> + restOfName.<span class="title function_">join</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> employeeName = <span class="title function_">getEmployeeName</span>(<span class="string">&#x27;Joseph&#x27;</span>, <span class="string">&#x27;Samuel&#x27;</span>, <span class="string">&#x27;Luces&#x27;</span>, <span class="string">&#x27;MacKinzie&#x27;</span>);</span><br></pre></td></tr></table></figure></div><h4 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h4><p>es6版本的ts提供了一个箭头函数，它是定义匿名函数的简写语法，用于函数表达式，省略了function关键字。箭头函数的定义如下，其函数是一个语句块:</p><div class="highlight-container" data-rel="Ts"><figure class="iseeu highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">( [param1, param2, ... param n] ) =&gt; &#123;</span><br><span class="line">    <span class="comment">//代码块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>其中，括号内是函数的入参，可以有0到多个参数，箭头后是函数的代码块。我们可以将这个箭头函数赋值给一个变量，如下所示</p><div class="highlight-container" data-rel="Ts"><figure class="iseeu highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">arrowFun</span> = (<span class="params"> [param1, param2, ... param n] </span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">//代码块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>如何要主动调用这个箭头函数，可以按如下方法调用:</p><div class="highlight-container" data-rel="Ts"><figure class="iseeu highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">arrowFun</span>(param1, param2, ... param n)</span><br></pre></td></tr></table></figure></div><p>那么如何将熟悉的函数定义方式转换成箭头函数</p><div class="highlight-container" data-rel="Ts"><figure class="iseeu highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">testNumber</span>(<span class="params">num: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">testArrowFun</span> = (<span class="params">num: <span class="built_in">number</span></span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">//函数体内容一致</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>后面在开发HarmonyOS时会经常用到箭头函数。例如，给一个按钮添加点击事件，其中onClick事件中的函数就是箭头函数</p><div class="highlight-container" data-rel="Ts"><figure class="iseeu highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Button</span>(<span class="string">&quot;Click Now&quot;</span>)</span><br><span class="line">.<span class="title function_">onClick</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">info</span>(<span class="string">&quot;Button is click&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div><hr><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>Ts支持基于类的面向对象的编程方式，定义类的关键字为class，后面紧跟类名。类描述了所创建的对象共同的属性和方法。</p><h4 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h4><p>例如，我们可以声明一个Person类，这个类有三个成员：一个是属性(包含name和age)，一个是构造函数，一个是getPersonInfo方法，其定义如下所示</p><div class="highlight-container" data-rel="Ts"><figure class="iseeu highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">    <span class="keyword">private</span> <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">    </span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">getPersonInfo</span>(): <span class="built_in">string</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;My name is $&#123;this.name&#125; and age is $&#123;this.age&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>继承就是子类继承父类的特征和行为，使得子类具有父亲相同的行为。Ts中允许使用继承来扩展现有的类，对应的关键字为extend。</p><div class="highlight-container" data-rel="Ts"><figure class="iseeu highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="attr">department</span>: <span class="built_in">string</span></span><br><span class="line">    </span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span>, department: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>(name, age);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">department</span> = department;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">getEmployeeInfo</span>(): <span class="built_in">string</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">getPersonInfo</span>() + <span class="string">`and work in <span class="subst">$&#123;<span class="variable language_">this</span>.department&#125;</span>`</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>通过上面的Employee类，可以定义一个人物并获取他的基本信息，具体使用场景参考相关学习资料。</p><h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p>随着应用越来越大，通常要将代码拆分成多个文件，即所谓的模块（module）。模块可以相互加载，并可以使用特殊的指令 export 和 import 来交换功能，从另一个模块调用一个模块的函数。</p><p>两个模块之间的关系是通过在文件级别上使用 import 和 export 建立的。模块里面的变量、函数和类等在模块外部是不可见的，除非明确地使用 export 导出它们。类似地，我们必须通过 import 导入其他模块导出的变量、函数、类等。</p><h4 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h4><p>任何声明(比如变量、函数、类、类型别名和接口)都能通过添加export关键字来导出，例如要导出一个类</p><div class="highlight-container" data-rel="Ts"><figure class="iseeu highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">NewsData</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h4><div class="highlight-container" data-rel="Ts"><figure class="iseeu highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;<span class="title class_">NewsData</span>&#125; <span class="keyword">from</span> <span class="string">&#x27;../common/bean/NewsData&#x27;</span>;</span><br></pre></td></tr></table></figure></div><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>当一个对象实现了Symbol.iterator属性时，我们认为它是可迭代的。一些内置的类型如Array，Map，Set，String，Int32Array，Uint32Array等都具有可迭代性。</p><h4 id="for…of语句"><a href="#for…of语句" class="headerlink" title="for…of语句"></a>for…of语句</h4><p>for..of会遍历可迭代的对象，调用对象上的Symbol.iterator方法。下面是在数组上使用for..of的简单例子:</p><div class="highlight-container" data-rel="Ts"><figure class="iseeu highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> someArray = [<span class="number">1</span>, <span class="string">&quot;string&quot;</span>, <span class="literal">false</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> entry <span class="keyword">of</span> someArray) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(entry); <span class="comment">// 1, &quot;string&quot;, false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="for…in语句"><a href="#for…in语句" class="headerlink" title="for…in语句"></a>for…in语句</h4><p>上述两种方式均可迭代一个列表，但是用于迭代的值却不同:for…in迭代的是对象的键，而for..of则迭代的是对象的值</p><div class="highlight-container" data-rel="Ts"><figure class="iseeu highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> list = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> list) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i) <span class="comment">// &quot;0&quot;, &quot;1&quot;, &quot;2&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> <span class="keyword">in</span> <span class="keyword">of</span> list) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">//&quot;4&quot;, &quot;5&quot;, &quot;6&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>TypeScript是一个开源的编程语言，本章节只有TypeScript的基础语法知识，更多内容参考TypeScript的官方教程（<a class="link"   href="https://www.typescriptlang.org/docs/%EF%BC%89%E3%80%82" >https://www.typescriptlang.org/docs/）。 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;基础类型&quot;&gt;&lt;a href=&quot;#基础类型&quot; class=&quot;headerlink&quot; title=&quot;基础类型&quot;&gt;&lt;/a&gt;基础类型&lt;/h3&gt;&lt;p&gt;赋值语句:&lt;code&gt;let 变量名: 变量类型  = 值&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;变量类型还是布尔值、数字、字符串(单</summary>
      
    
    
    
    <category term="OpenHarmonyDeveloper" scheme="https://primeluoqiu.github.io/categories/OpenHarmonyDeveloper/"/>
    
    
  </entry>
  
  <entry>
    <title>2.7 CDN(内容分发网络)</title>
    <link href="https://primeluoqiu.github.io/2024/04/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.7/"/>
    <id>https://primeluoqiu.github.io/2024/04/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.7/</id>
    <published>2024-04-05T06:31:06.791Z</published>
    <updated>2024-04-05T06:33:13.372Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/04/05/FoZrhkS8.jpg"                      alt="54.jpg"                ><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/04/05/QvnBufgw.jpg"                      alt="55.jpg"                ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;https://img2.imgtp.com</summary>
      
    
    
    
    <category term="计网" scheme="https://primeluoqiu.github.io/categories/%E8%AE%A1%E7%BD%91/"/>
    
    
  </entry>
  
  <entry>
    <title>2.6 P2P</title>
    <link href="https://primeluoqiu.github.io/2024/04/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.6/"/>
    <id>https://primeluoqiu.github.io/2024/04/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.6/</id>
    <published>2024-04-04T15:29:50.750Z</published>
    <updated>2024-04-04T15:30:55.076Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/04/04/R3X2Nco5.jpg"                      alt="50.jpg"                ><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/04/04/TFIyogDt.jpg"                      alt="51.jpg"                ><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/04/04/CUZMPxTG.jpg"                      alt="52.jpg"                ><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/04/04/ayBVCH5r.jpg"                      alt="53.jpg"                ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;https://img2.imgtp.com</summary>
      
    
    
    
    <category term="计网" scheme="https://primeluoqiu.github.io/categories/%E8%AE%A1%E7%BD%91/"/>
    
    
  </entry>
  
  <entry>
    <title>2.5 DNS</title>
    <link href="https://primeluoqiu.github.io/2024/04/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.5/"/>
    <id>https://primeluoqiu.github.io/2024/04/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.5/</id>
    <published>2024-04-03T14:32:46.454Z</published>
    <updated>2024-04-03T14:42:13.470Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/04/03/eDDtt0xR.jpg"                      alt="45.jpg"                ><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/04/03/7QasoPyg.jpg"                      alt="46.jpg"                ><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/04/03/rQvuGoqE.jpg"                      alt="47.jpg"                ><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/04/03/dXTAhcmR.jpg"                      alt="48.jpg"                ><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2.imgtp.com/2024/04/03/GXV38DGF.jpg"                      alt="49.jpg"                ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;https://img2.imgtp.com</summary>
      
    
    
    
    <category term="计网" scheme="https://primeluoqiu.github.io/categories/%E8%AE%A1%E7%BD%91/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://primeluoqiu.github.io/2024/04/02/Algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(%E4%B8%89)/"/>
    <id>https://primeluoqiu.github.io/2024/04/02/Algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(%E4%B8%89)/</id>
    <published>2024-04-02T14:10:44.252Z</published>
    <updated>2024-04-02T14:11:48.550Z</updated>
    
    <content type="html"><![CDATA[<hr><p>title: 哈希表和STL</p><p>categories: Algorithm</p><hr><h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><p>哈希表实际上就是把一个很大范围的数据结构映射成为一个很小的数据范围的东西。举例来说，比如说想把从0-10的9次方这些数映射到从0到10的五次方左右的一些数。</p><p>比如现在有一批数的范围是-10九次方到+10的九次方，然后通过一个哈希函数把它们放进一个很小的(10的五次方)的范围之内。</p><p>哈希函数的一些问题，例如：</p><ol><li><p>哈希函数一般怎么写：就是直接模一个数，例如可以直接模10^5。</p></li><li><p>冲突定义域比较大，映射的结果比较小，那么必然会产生冲突，把两个不一样的数映射到同一个数。按照处理冲突的方式分为开放寻址法和拉链法。</p></li></ol><h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><h3 id="开放寻址法"><a href="#开放寻址法" class="headerlink" title="开放寻址法"></a>开放寻址法</h3><p>通俗来讲的话，也叫蹲坑法，什么意思呢，就是说，我们只需要一个数组就可以了，但是这个数组的大小一般要开到题目范围的2-3倍，然后就像大家上厕所一样，当一个坑位被占了的时候，只能去找下一个坑位，然后下一个坑位被占了再找下一个，也就意味着说，我们先通过函数来寻找到k，但是如果那个k被占用了的话，那么就去k+1，如果k+1被占用了，就去k+2…</p><p>然后这个方法主要就是find函数的实现，然后插入的话，就是通过find找到对应的位置，然后把x放进去就可以了，而查找的话就是如果对应的位置不是空的，那么就是有的，不然就是没有。删除其实也可以看做另外一种形式的查找，因为并不是真正的删除，而是对那个点做一个标记</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e6</span> + <span class="number">3</span>, null = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> h[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k = (x % N + N) % N;</span><br><span class="line">    <span class="keyword">while</span>(h[k] != null &amp;&amp; h[k] != x)</span><br><span class="line">    &#123;</span><br><span class="line">        k ++;</span><br><span class="line">        <span class="keyword">if</span>(k == N) k = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(h));</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(n --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d&quot;</span>, op, &amp;x);</span><br><span class="line">        <span class="type">int</span> k = <span class="built_in">find</span>(x);</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">&#x27;I&#x27;</span>) h[k] = x;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(h[k] != null)</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h3><p>简单来讲，就是说，先开出来一个空间，然后例如我们把h(11)映射到了3，h(23)也映射到了3，这个时候，我们就在3的下面拉一个线，类似拉链一样。多一个点就多一个线。然后一般哈希表只会存在两种操作，分别是添加和查找，添加很简单，只需要通过对应的哈希函数找到它的位置，然后添加一条拉链就可以了，查找的话，就是先看出来这个数值哈希完之后是什么，如果是某个点，然后顺着那个点去查找是不是有那个值。一般不会有删除操作的，就算有，也不是真的把那个数值删了，而是给那个点打个标记，例如布尔变量，然后就删除掉了。</p><p>这里要注意一个点，我们的哈希函数模的那个值最好是一个质数，而且距离2的多少次方比较远，这样能够保证冲突的概率是最小的。</p><p>接下来，看一下我们拉链法的模板</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> h[N], e[N], ne[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k = (x % N + N) % N;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    ne[idx] = h[k];</span><br><span class="line">    h[k] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k = (x % N + N) % N;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[k]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(e[i] == x)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="built_in">sizeof</span>(h));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(n --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d&quot;</span>, op, &amp;x);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">&#x27;I&#x27;</span>) <span class="built_in">insert</span>(x);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(x)) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="字符串哈希方式"><a href="#字符串哈希方式" class="headerlink" title="字符串哈希方式"></a>字符串哈希方式</h2><p>一种特殊的方式：字符串前缀哈希法。</p><p>求哈希之前，先预处理出来所有前缀的哈希。</p><p>那么如何处理出来所有前缀的哈希呢？</p><p>我们可以把每个字符串看成是一个<code>P</code>进制的数，例如”ABCD”是一个p进制的数，然后我们将它转化成为一个十进制的数，那么”ABCD”如果分别代表第一位第二位第三位和第四位的话，那么它可以转化成<br>$$<br>1<em>p^3+2</em>p^2+3<em>p^1+4</em>p^0<br>$$<br>那么当这个字符串比较长的时候，这个数值就会变得很大，那么我们不妨给它模一个<code>Q</code>让他变小，然后我们就把范围缩小到了0-<code>Q-1</code></p><p>不过有两个值得注意的点</p><ol><li>首先是任何一个字母都不能映射成0，毕竟0在任何进制上转换成十进制的时候都是0。</li><li>这个是建立在我们rp(人品)足够好的前提下，也就是说不存在冲突的情况。</li></ol><p>不过这倒是有个经验值可以保证在99.99%的前提下不会出现冲突，就是指当p &#x3D; 131&#x2F;13331，且Q &#x3D; 2^64的时候，就可以了</p><p>这么处理的好处是什么呢？</p><p>就是说我们可以通过一个公式来计算出所有子串的哈希值。</p><p>那么，具体是什么公式呢？</p><p>就是说，有一个线段，例如从L-R，那么我们把从1-L这一段让它和L-R这一段对齐，那么用这两段相减就可以了。那么最后的公式就是</p><p>h[R] - h[L] * p ^ (R - L + 1)</p><p>Q是等于2^64,如果我们这个时候开一个<code>unsigned long long</code>的话，那么只要溢出的话就相当于是自动模上2^64了</p><p>预处理的话就是</p><p><code>h(i) = h(i - 1) * p + str[i]</code></p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ULL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>, P = <span class="number">131</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">char</span> str[N];</span><br><span class="line">ULL h[N], p[N]; <span class="comment">//p[N]用来存储公式中的L-R+1</span></span><br><span class="line"></span><br><span class="line"><span class="function">ULL <span class="title">get</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h[r] - h[l - <span class="number">1</span>] * p[r - l + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%s&quot;</span>, &amp;n, &amp;m, str + <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        p[i] = p[i - <span class="number">1</span>] * P;</span><br><span class="line">        h[i] = h[i - <span class="number">1</span>] * P + str[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (m --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l1, r1, l2, r2;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;l1, &amp;r1, &amp;l2, &amp;r2);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">get</span>(l1, r1) == <span class="built_in">get</span>(l2, r2)) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h1 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h1><h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><p>实际上就是一个变长数组，倍增的思想。</p><p>有这样的一些函数</p><p><code>size()</code>返回元素个数</p><p><code>empty()</code>返回是否为空</p><p><code>clean()</code>清空这个vector</p><p><code>front()/ back()</code>最前面的和最后面的</p><p><code>push_back() / pop_back()</code>在最后插入和把最后一个删掉</p><p><code>begin() / end()</code>第0个和最后一个的后一个，也就是迭代器。</p><h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><p>字符串，一些常用的函数例如<code>substr()</code>、<code>c_str()</code></p><h3 id="queue-priority-queue"><a href="#queue-priority-queue" class="headerlink" title="queue, priority_queue"></a>queue, priority_queue</h3><p>队列,<code>push()</code>, <code>pop()</code> ,<code>front()</code></p><h3 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h3><p>栈,<code>push()</code>, <code>pop()</code>, <code>front()</code></p><h3 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h3><p>双端队列，也就是在队列的基础上让队列的头和尾都可以插入和删除</p><h3 id="set-map-multiset-multimap"><a href="#set-map-multiset-multimap" class="headerlink" title="set, map, multiset, multimap"></a>set, map, multiset, multimap</h3><p>基于平衡二叉树(红黑树)，动态维护有序序列</p><h3 id="unordered-map-unordered-set-unordered-multiset-unordered-multimap"><a href="#unordered-map-unordered-set-unordered-multiset-unordered-multimap" class="headerlink" title="unordered_map, unordered_set, unordered_multiset, unordered_multimap"></a>unordered_map, unordered_set, unordered_multiset, unordered_multimap</h3><p>哈希表</p><h3 id="bitset"><a href="#bitset" class="headerlink" title="bitset"></a>bitset</h3><p>压位</p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;p&gt;title: 哈希表和STL&lt;/p&gt;
&lt;p&gt;categories: Algorithm&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;哈希表&quot;&gt;&lt;a href=&quot;#哈希表&quot; class=&quot;headerlink&quot; title=&quot;哈希表&quot;&gt;&lt;/a&gt;哈希表&lt;/h1&gt;&lt;p&gt;哈希表实际</summary>
      
    
    
    
    
  </entry>
  
</feed>
