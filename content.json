{"meta":{"title":"秋过冬漫长","subtitle":"没有比脚更长的路,走过去就好了","description":"","author":"LuoQiu","url":"https://PrimeLuoQiu.github.io"},"pages":[{"title":"categories","date":"2024-03-23T11:22:46.000Z","updated":"2024-04-21T15:50:15.442Z","comments":true,"path":"categories/index.html","permalink":"https://primeluoqiu.github.io/categories/index.html","excerpt":"","text":"title: 大二下date: 2024-03-18 12:24:49 title: CS61Adate: 2024-03-18 12:24:50 title: CS61Bdate: 2024-03-18 12:24:58title: acwingdate: 2024-03-18 12:24:58 title: Experimentdate: 2024-03-18 12:24:00 title: 学校作业date: 2024-03-23 20:30:00 title: Algorithmdate: 2024-03-23 20:30:00 title: Dairydate: 2024-03-29 21:37:22 title: OpenHarmonyDeveloperdate: 2024-04-08 00:00:00 title: 网络工程师date: 2024-04-18 00:00:00 title: C++Primerdate: 2024-04-18 00:00:00 title: 全栈后端date: 2024-04-21 00:00:00"},{"title":"abot","date":"2024-03-23T09:13:50.000Z","updated":"2024-03-23T09:13:50.763Z","comments":true,"path":"about/index.html","permalink":"https://primeluoqiu.github.io/about/index.html","excerpt":"","text":""}],"posts":[{"title":"计网第三个实验","slug":"SchoolHomework/计网/Experiment3","date":"2024-04-22T16:31:51.392Z","updated":"2024-04-22T16:34:13.248Z","comments":true,"path":"2024/04/23/SchoolHomework/计网/Experiment3/","link":"","permalink":"https://primeluoqiu.github.io/2024/04/23/SchoolHomework/%E8%AE%A1%E7%BD%91/Experiment3/","excerpt":"","text":"实验三五、实验步骤 1.数据规划（课程目标1） 表1-交换机VLAN划分及端口 设备 VLAN编号 端口范围 IP地址&#x2F;端口模式 S5700 vlan 10 20 G 0&#x2F;0&#x2F;1 - G 0&#x2F;0&#x2F;2 串口 S3700 vlan 10&#x2F;20 E 0&#x2F;0&#x2F;1 - 0&#x2F;0&#x2F;2 G 0&#x2F;0&#x2F;1 单通 表2-PC计算机IP地址及端口信息 设备 端口 IP地址信息 网关 PC1 E 0&#x2F;0&#x2F;1 DHCP自动获取 DHCP自动获取 PC2 E 0&#x2F;0&#x2F;1 DHCP自动获取 DHCP自动获取 PC3 E 0&#x2F;0&#x2F;1 DHCP自动获取 DHCP自动获取 PC4 E 0&#x2F;0&#x2F;1 DHCP自动获取 DHCP自动获取 2.启动有eNSP模拟器，按实验要求和规划，搭建网络拓扑。（课程目标3） 3.设备配置。（课程目标3） 通过官网内容可以得出，DHCP(Dynamic Host Configuration Protocol)主要目的是在于移动终端想要即插即用，不需要修改终端的IP等网络参数。那么实际上，也就是说应该在汇聚层的用户网关中配置DHCP来给终端分配IP地址等网络参数 动态主机配置协议DHCP（Dynamic Host Configuration Protocol）采用客户端&#x2F;服务器模式( 指分配的是服务器，分配的设备是客户端) 对用户的网络参数进行动态配置和集中管理。其中，DHCP服务器通过地址池为用户分配IP地址等网络参数。地址池分为接口地址池和全局地址池两种。 接口地址池配置方式简单，只能用于用户DHCP服务器在同一网段的场景，且只能给对应接口下的用户分配IP地址等网络参数；适用于设备有限、配置以及维护量可控的小型网络。在用户网关设备上基于接口地址池的DHCP服务器功能之后，对应接口下的固定主机、移动终端等都可以获得IP地址等网络参数，不需用户手动更改。 与接口地址池相比，全局地址池可应用于大型网络，推荐在核心层设备上配置基于全局地址池的DHCP服务器功能或在服务器区域搭建一台专门的DHCP服务器统一分配IP地址等网络参数，而用户网关设备上只需要启用简单的DHCP中继功能即可。 配置思路 基于全局的DHCP服务的配置思路如下： 通过在最上层的switch上配置DHCP服务器，实现为企业两个网段内的终端动态分配IP地址 操作步骤 1开通DHCP服务， 123system-viewsysname Switchdhcp enable 2.配置接口加入VLAN 首先是G1和G2 分别加入vlan10和20 123456vlan batch 10 20port link-type accessport default vlan 10interface G 0/0/2port link-type accessport default vlan 20 3.配置VLANIF接口IP地址 首先，我们要知道vlanif是用来干什么的：VLANIF接口(C&#x2F;S模式)是基于VLAN的三层逻辑接口，可以配置IP地址(一个网段的IP)。划分VLAN后，同一VLAN内的用户可以互相通信，但是属于不同VLAN的用户不能直接通信。 分别是VLANIF10和20，也就是刚刚创建的两个VLAN 1234567interface vlanif 10ip address 10.10.1.1 24 //为固定终端的网段qinterface vlanif 20ip address 10.10.2.1 24 //另一个网段q 4.配置全局地址池 #先配置全局地址池pool1中的IP地址和相关网络参数 1234567891011ip pool pool1network 10.10.1.0 mask 24 //配置IP地址池dns-list 114.114.114.114 //配置DNS，即域名解析系统，为的是可以通过该系统访问到这个主机所在的地域gate-way list 10.10.1.1 //配置网关，也就是通过这个地址访问出去，外面的也从这个地址进来。qip pool pool2 //和上面相同配置network 10.10.2.0 mask 24dns-list 114.114.114.114gate-way list 10.10.2.1 q 5.使能DHCP服务器 1234567interface vlanif 10dhcp select globalqinterface vlanif 20dhcp select globalq 五.验证。（课程目标3） 上面结束之后就可以进行验证了 分别在PC1，2，3，4上使用ipconfig进行ip相关信息的查看，然后再用ping来查看是否和vlan20的进行连通。 六、实验心得或存在的问题（课程目标1） 实验内容还是很简单的，主要是对于过程的了解以及vlanif的使用，还有就是对三层交换机的内容的理解。然后就是对于配置全局地址池的内容进行了解。主要是对于DHCP的理解和相关操作。","categories":[{"name":"Expriment","slug":"Expriment","permalink":"https://primeluoqiu.github.io/categories/Expriment/"}],"tags":[],"keywords":[{"name":"Expriment","slug":"Expriment","permalink":"https://primeluoqiu.github.io/categories/Expriment/"}]},{"title":"局域网和城域网","slug":"网络工程师/局域网和城域网","date":"2024-04-22T15:22:02.696Z","updated":"2024-04-22T15:23:41.592Z","comments":true,"path":"2024/04/22/网络工程师/局域网和城域网/","link":"","permalink":"https://primeluoqiu.github.io/2024/04/22/%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B%E5%B8%88/%E5%B1%80%E5%9F%9F%E7%BD%91%E5%92%8C%E5%9F%8E%E5%9F%9F%E7%BD%91/","excerpt":"","text":"局域网和城域网最常考点:CSMA&#x2F;CD 、VLAN 、 STP 局域网体系与拓扑结构 CSMA&#x2F;CD与监听算法对于总线型、星形和树形拓扑访问控制协议是CSMA&#x2F;CS(Carrier Sense Multiple Access&#x2F;Collision Detection) CSMA基本原理：发送数据之前，先监听信道上是否有人在发送，若有，说明信道正忙，否则空闲，然后根据预定的策略决定 若信道空闲，是否立即发送 若信道忙，是否继续监听 如果连续发生16次碰撞后，认为网络繁忙有问题，不再尝试发送 三种监听算法 非坚持型监听算法：后退随机时间 由于随机时延后退，从而减少了冲突的概率。问题是因为后退而使信道闲置一段时间，这使信道的利用率降低，而且增加了发送时延，类似蹲坑，但是坑有人，选择出去憋一会再等等 1-坚持型监听算法：继续监听，不等待 有利于抢占信道，减少信道空闲时间。但是多个站同时都在监听信道时必然会发生冲突。冲突概率和利用率都高(双高） 不等人，敲门催促 P-坚持型监听算法 若信道空闲，以概率P发送，以概率(1-P)延迟一个时间单位，P大小可调整。 【2011年下】以太网介质访问控制策略可以采取不同的监听算法，其中一种是：“一旦介质空闲就发送数据，假如介质忙，继续监听，直到介质空闲后立即发送数据”这种算法称为()监听算法，该算法的主要特点是() A.1-坚持型 B.非坚持性 C.P-坚持型 D.0-坚持型 A.介质利用率和冲突概率都低 B.介质利用率和冲突概率都高 C.介质利用率低且无法避免冲突 D.介质利用率高且可以有效避免冲突 【2015下】以下关于CSMA&#x2F;CD协议的叙述中，正确的是() A.每个节点按照逻辑顺序占用一个时间片轮流发送 B.每个节点检查介质是否空闲，如果空闲立即发送 C.每个节点想发就发，如果没有冲突则继续发送 D.得到令牌的节点发送，没有得到令牌的节点等待 冲突检测原理载波监听只能减小冲突的概率，不能完全避免冲突","categories":[{"name":"网络工程师","slug":"网络工程师","permalink":"https://primeluoqiu.github.io/categories/%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B%E5%B8%88/"}],"tags":[],"keywords":[{"name":"网络工程师","slug":"网络工程师","permalink":"https://primeluoqiu.github.io/categories/%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B%E5%B8%88/"}]},{"title":"第七周总结 + 第八周学习计划","slug":"每周学习计划/Week7","date":"2024-04-21T16:08:28.305Z","updated":"2024-04-21T16:10:42.032Z","comments":true,"path":"2024/04/22/每周学习计划/Week7/","link":"","permalink":"https://primeluoqiu.github.io/2024/04/22/%E6%AF%8F%E5%91%A8%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/Week7/","excerpt":"","text":"第七周总结前两周似乎有点莫得激情，希望本周可以把激情找回来，感觉还是要深入地进行学习这样子才能到关键的时候有的说。 计划走一步看一步，大体计划然后每日更新学习内容好了1.计网2.面向对象3.前端4.开发思路和知识","categories":[{"name":"大二下","slug":"大二下","permalink":"https://primeluoqiu.github.io/categories/%E5%A4%A7%E4%BA%8C%E4%B8%8B/"}],"tags":[],"keywords":[{"name":"大二下","slug":"大二下","permalink":"https://primeluoqiu.github.io/categories/%E5%A4%A7%E4%BA%8C%E4%B8%8B/"}]},{"title":"Go基本的结构和基本数据类型","slug":"全栈内容/后端Go/C1","date":"2024-04-21T15:45:29.730Z","updated":"2024-04-21T15:50:13.682Z","comments":true,"path":"2024/04/21/全栈内容/后端Go/C1/","link":"","permalink":"https://primeluoqiu.github.io/2024/04/21/%E5%85%A8%E6%A0%88%E5%86%85%E5%AE%B9/%E5%90%8E%E7%AB%AFGo/C1/","excerpt":"","text":"Chapter 4 基本结构和基本数据类型2.Go程序的基本结构和要素1.包的概念、导入和可见性包是结构化代码的一种方式：每个程序都由包(pkg)的概念组成，可以使用自身的包或者从其他包中导入内容。每个go文件都属于且仅属于一个包，一个包可以有很多go程序，文件名和包名一般来说是不相同的。 必须在源文件中非注释的第一行指明这个文件属于哪个包，如package main。package main表示一个可独立执行的程序，每个go程序都包含一个可独立执行的程序，每个go都应该包含一个名为main的包 一个应用程序也可以包含不同的包，不必要把所有代码写在main中，可以用小文件，所有的包名都应该使用小写字母。 标准库Go 的标准库包含了大量的包，如fmt和os，也可以创建自己的包。想要构建一个程序，则包和包内的文件都必须以正确的顺序进行编译。包的依赖关系决定了其构建顺序。属于同一个包的源文件必须全部被一起编译，一个包即是编译时的一个单元，因此根据管理，每个目录都只包含一个包。如果对一个包进行更改或重新编译，所有引用这个包的客户端都必须全部重新编译。 每一段代码只会被编译一次。 一个go程序通过”import”关键字将一组包连接在一起。import &quot;fmt&quot;告诉go编译器这个程序需要使用fmt包(的函数，或其他元素)，”fmt”包实现了格式化IO的函数。包名被封闭在半角双引号中，如果打算从已编译的包中导入并加载公开声明的方法，不需要插入已编译包的源代码。 如果需要多个包，可以被分别导入 12import &quot;fmt&quot;import &quot;os&quot; 或者 1import &quot;fmt&quot;; import &quot;os&quot; 还有短且优雅的方法(被称为因式分解关键字，方法同样适用于const, var 和 Type的声明或定义): 1234import ( &quot;fmt&quot; &quot;os&quot;) 甚至可以更短，不过使用fmt之后会强制换行 1import(&quot;fmt&quot;, &quot;os&quot;) 如果包名不以.或/开头，如&quot;fmt&quot;，会在全局文件进行查找;如果以./开头，会在相对目录中查找，或者绝对路径查找导入包等同于包含了这个包的所有的代码对象。除了符号_，包中所有代码对象的标识符必须是唯一的，避免名称冲突可以通过下述被编译器强制执行的规则来决定是否将自身的代码对象暴露给外部文件： 可见性规则当标识符以一个大写字母开头，如Group1，那么使用这种形式的标识符的对象就可以被外部包的代码所使用(前提是已经被导入)，这被称之为导出；标识符如果以小写字母开头，则对包外是不可见的，但在整个包内部是可见并可用的。(private) 大写字母可以使用任何Unicode编码的字符，例如希腊文 因此在导入一个外部包之后，能够且只能够访问该包中导出的对象。 假设在pack1中有一个变量或函数叫做Thing，那么在当前包中导入pack1包，Thing就可以像面向对象语言那样使用点标记来调用。pack1.Thing 因此包也可以作为命名空间使用，帮助避免命名冲突，两个包中的同名变量区别在于包名。 也可以通过使用包的别名来解决包名之间的名称冲突，或者根据个人喜好对包名进行重新设置，例如 1234567package mainimport fm &quot;fmt&quot;func main() &#123; fm.Println(&quot;Hello World&quot;)&#125; 如果导入一个包之后没有进行使用，则会在构建程序时引发错误，如imported and not used: os，这遵循了go的格言：没有不必要的代码 也可以在使用import导入包之后定义或声明0个或多个常量(cosnt)、变量(var)和类型(type)，这些对象的作用域都是全局的(在本包范围内)，所以可以被本包中所有的函数调用，然后声明一个或多个函数(func) 2.函数这是定义一个函数最简单的方式 1func functionName() 可以在括号中写入0个或多个函数的参数，(使用，分隔)，参数名称后面必须跟着参数的类型。 main函数是每一个可执行程序所必须包含的，一般来说都是在启动后第一个执行的函数(如果有init()函数则会先执行该函数)。如果main包的源代码没有包含main函数，则会引发构建错误。main函数既没有参数，也没有返回类型。添加也会出现构建错误 在程序开始执行并完成初始化之后，第一个调用(程序的入口点)的函数是main.main()该函数一旦返回就表示程序已成功执行并立即退出。 函数体使用大括号括起来。 &#123;必须与方法的声明放在同一行，这是强制规定，否则就会出现相关错误原因是因为编译器会产生func main();这样的结果，这很明显是错的 1`bulid-error: syntax error: unexpected semicolon or newline before &#123;` Go语言虽然看起来不使用分号作为语句的结束，但实际上这一过程是由编译器自动完成，因此才会引发像上面这样的错误 &#125;需要被放在紧接着函数体的下一行，如果函数非常简短，也可以放在同一行 1func Sum(a, b int) int &#123; return a + b &#125; 大括号使用规则在任何时候都是相同的。因此符合规范的函数一般写成如下形式 123func functionName(parameter_list) (return_value_list) &#123; ...&#125; 其中： parameter_list的形式为(param1 type1, param2 type2, …) return_value_list的形式为(ret1 type1, ret2 type2, …)只有当某个函数需要被外部包调用的时候才使用大写字母开头，并遵循Pascal命名法：否则就遵循驼峰命名法(第一个单词的首字母小写，其余单词首字母大写)。 1fmt.Println(&quot;Hello, world&quot;) 这一行调用了fmt包的Println函数，将字符串输出到控制台并自动增加换行符，使用”Hello,world\\n”可以得到同样效果。 Print和Println也支持使用变量，如果没有特别指定，他们会以默认方式输出变量到控制台，如果只是单纯打印一个字符或者变量也可以用预定义的方式来实现print、println，不过这些函数只用于调试阶段，在部署的时候务必换成fmt中的相关函数。 当被调用的函数的代码执行到结束符&#125;或返回语句就会返回，然后继续执行调用函数之后的代码 正常退出的代码为0，异常被终止为非零值，可以用来测试是否成功执行一个程序。 3.注释如果使用国际化字符直接用输出语句输出即可，注释不会被翻译，但可以用goddoc来使用。 单行注释很常见，或者多行注释(块状注释)，一般用于包的文档描述或者注释成块的代码片段。 每个包应该有相关注释，package之前的注释被默认成为这个包的文档说明，其中应该提供一些相关信息并对整体功能做简要的介绍。在首行的简要注释之后可以用成段的注释来进行更详细的说明，不必挤在一起，在多段注释之间用用空行加以区分。 几乎所有全局作用域的类型，常量、变量、函数和被导出的对象都应该有一个合理的注释。如果这种注释出现在函数前面，例如函数Abcd，则要以&quot;Abcd...&quot;作为开头。 12345// enterOrbit cause Superman to fly into low Earth orbit, a postion// that presents sevral possibilities for planet salvationfunc enterOrbit() error &#123; ...&#125; goddoc工具会手机这些注释并产生一个技术文档 4.类型可以包含的数据的变量或常量。可以使用不同的数据类型或类型来保存数据，使用var声明的变量的值会自动初始化为该类型的0值。类型定义了某个变量的值得集合与可对其进行操作的集合 类型可以是基本类型，也可以是结构化的 struct, array，或者只描述类型的行为的。interface 结构化的类型没有真正的值，使用nil作为默认值(Null)。值得注意的是，Go中不存在类型继承。 函数也可以是一个确定的类型，就是以函数作为返回类型。这种类型的声明要写在函数名和可选的参数列表之后，例如 1func FunctionName(a typea, b typeb) typeFunc 可以在函数体中的某处返回使用类型为typeFunc的变量var： 1return var 一个函数可以拥有多返回值，返回类型之间需要使用逗号分隔，并使用小括号括起来 1func FunctionName (a typea, b typeb)(t1 type1, t2 type2) 示例：函数Atoi(4.7节)func Atoi(s string) (i int, err error)返回的形式： 1return var1, var2 这种多返回值一般用于判断某个函数是否执行成功(true&#x2F;false)或与其他返回值一同返回错误消息 使用type关键字可以定义自己的类型，可以是一个结构体，也可以定义一个已经存在的类型的别名，如 1type IZ int 这里并不是真正意义上的别名，因为使用这种方法定义之后的类型可以拥有更多的特性，且在类型转换时必须显示转换。然后我们可以使用下面的方式声明变量： 1var a IZ = 5 这里可以看到int是变量a的底层类型，这也使得它们之间存在相互转换的可能。如果有多个类型需要定义，也可以使用因式分解关键字的方式，例如: 12345type ( IZ int Fz float64 STR string) 每个值都必须在经过编译之后属于某个类型(编译器必须能够推断出所有值的类型)，因为Go语言是一种静态类型语言。 5.Go程序的一般结构下面的程序虽然可以顺利的编译，但是什么都做不了，不过这很好的展示了一个Go程序的首选结构，这种结构没有被强制要求，且编译器也不关心main函数的位置，但是使用统一的结构能够在从上至下阅读Go代码时有更好的体验 总体思路 在完成包的import之后，开始对常量、变量和类型的定义或声明。 如果存在int函数的话，则对该函数进行定义(这是一个特殊的函数，每个含有该函数的包都会首先执行这个函数)。 如果当前包是main包，则定义main函数 然后定义其余的函数，首先是类型的方法，接着是按照main函数中先后调用的顺序来定义相关函数，如果有很多函数，则可以按照字母顺序来进行排序 12345678910111213141516171819202122232425262728293031package mainimport ( &quot;fmt&quot;)const c = &quot;C&quot;var v int = 5type T struct&#123;&#125;func init() &#123; //initialization of package&#125;func main() &#123; var a int Func1() // ... fmt.Println(a)&#125;func (t T) Method1() &#123; // ...&#125;func Func1() &#123; //exported function Func1 //...&#125; 顺序如下： 按顺序导入所有被main包引用的其他包，然后在每个包中执行如下流程： 如果该包又导入了其他的包，则从第一步开始递归执行，但是每个包只会被导入一次 然后以相反的顺序在每个包中初始化常量和变量，如果该包含有init函数的话，则调用该函数 在完成这一切之后，main也执行同样的过程，最后调用main函数开始执行程序。 6.类型转换在必要以及可行的情况下，一个类型的值可以被转换成另一种类型的值。由于go语言不存在隐式类型转换，因此所有的转换都必须显示说明，就像调用一个函数一样。(类型在这里的作用可以看作是一种函数): 1valueOfTypeB = typeB(valueofTypeA) 类型B的值&#x3D;类型B(类型A的值) 示例: 12a := 5.0b := int(a) 这只能在定义正确的情况下转换成功，如果从一个取值范围较小的类型转换到要给取值范围较大的类型(int 16-32)。如果从大到小的话，将会发生精度丢失的情况，于是编译器捕捉到非法的类型转换时会引发编译时错误，否则将引发运行时错误。具有相同底层类型的变量可以相互转换。 123var a IZ = 5c := (int) ad := IZ(c) 7.Go命名规范干净、可读的代码和简洁性是Go追求的主要目标，通过gofmt来强制实现统一的代码风格。Go中对象的命名也应该是简洁而有意义的。像是java和python中那样使用混着大小写和下划线的冗长的名称会降低代码的可读性，名称不需要指出自己所属的包。因为在调用的时候会使用包名作为限定符，返回某个对象的函数或方法的名称一般都是使用名词。没有Get ...之类的字符。如果是用于修改某个对象，则使用SetName。有必须要的话可以使用大小写混合的方式，如MixedCaps或mixedCaps，而不是用下划线来分割多个名称。","categories":[{"name":"全栈后端","slug":"全栈后端","permalink":"https://primeluoqiu.github.io/categories/%E5%85%A8%E6%A0%88%E5%90%8E%E7%AB%AF/"}],"tags":[],"keywords":[{"name":"全栈后端","slug":"全栈后端","permalink":"https://primeluoqiu.github.io/categories/%E5%85%A8%E6%A0%88%E5%90%8E%E7%AB%AF/"}]},{"title":"广域通信网","slug":"网络工程师/广域通信网","date":"2024-04-19T13:51:36.823Z","updated":"2024-04-19T14:03:00.837Z","comments":true,"path":"2024/04/19/网络工程师/广域通信网/","link":"","permalink":"https://primeluoqiu.github.io/2024/04/19/%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B%E5%B8%88/%E5%B9%BF%E5%9F%9F%E9%80%9A%E4%BF%A1%E7%BD%91/","excerpt":"","text":"广域通信网本章考察较少，一般1-2分，最常考点：帧中继、HDLC 广域网通信基础1.公共交换电话网 PSTNPSTN: Public Switched Telephone Network 为了语音通信建立的网络，20c60s开始用于数据传输 三个部分组成：本地回路、干线和交换机 干线和交换机采用数字传输和交换技术，本地回路基本采用模拟线路 电话线联网时需要在发送端通过调制解调器把数字信号变换成模拟信号，接收端再用同样设备转换成数字信号 2.本地回路DTE(Data Terminal Equipment)数据终端：通信链路的端点 DCE(Data Circuit Equipment)数据电路设备：用于信号变换器、自动呼叫等 DTE：PC&#x2F;电话机 DCE：猫&#x2F;调制解调器&#x2F;Modem 以RS-232-C接口为例说明机械特性及技术特性 机械特性描述DTE和DCE之间物理上的分界线，规定连机器的几何形状，尺寸大小，引线数、引线、排列方式及锁定装置等。 上述接口没有正式规定连机器的标准，只有在其附录中建议用25针的D型连接器，也有很多使用其他连接器，特别是在微型机RS-232-C串行接口上，大多使用9针连接器 电气特性： 上述设备采用的V.28标准电路，速率20kb&#x2F;s，最长15米 信号源产生3-15V的信号，±3V之间是信号电平过渡区 3-15V表示1，控制线和定时线OFF， 功能特性：对接口连线的功能给出明确定义 上述设备采用的是V.24 【2009上】 RS-232-C电气特性采用V.28标准电路，允许的数据速率是(),传输距离不大于() a.1kbps b. 20Kbps c.100Kbps d. 1Mbps a.1m b.15m c.100m d.1000m 【2009上】关于RS-232-C标准的描述中，正确的是 A.可以实现长距离远程通信 B.可以使用9针或25针D型连接器 C.必须采用24根线的电缆进线连接 D.通常用于连接并行打印机 流量控制流量控制和差错控制流量控制指协调发送和接受的步调，避免发送过快 两种协议：TCP、X.25 都考 差错控制：检测和纠正传输错误的机制 检错码：CRC 纠错码：海明码 流量控制有两种协议 停止等待协议 发送方直到接收到接受方发来的应答信号(ACK)后再发送下一帧。如果不应答就等待 $$TFA&#x3D;2t_p+t_f$$ tp是路上时间，tf是发送时间。 滑动窗口协议 滑动窗口主要思想：允许连续发送多个帧而无需等待应答。 TCP&#x2F;X.25都是这种机制 应付差错的办法： 肯定回答 否定回答 超时重传(最常用) 停止等待ARQ(Automatic Repeat reQuest)自动重传协议 选择重发ARQ协议 后退N帧ARQ协议 停止等待ARQ：是停等流控制技术和自动请求重发技术的结合，发送站发送出一帧之后必须等待应答，收到肯定应答后再发送下一帧。收到NAK或者超时都要重发 选择重发ARQ：重传特定的某一帧$$W_发&#x3D;W_收≤2^{k-1}$$后退N帧ARQ：重传此帧和后续的N帧$$W_发&#x3D;W_收≤2^k-1$$HDLC(High Level Data Link Control, 高级数据链路控制)，是一种面向位(bit)的数据链路层控制协议，通常使用CRC-16、CRC-32校验，帧边界**”01111110”** 【2009下】对于选择重发ARQ协议，如果帧编号字段为k位，则窗口大小() A.W≤2^k -1 B.W≤2^K-1 C.W&#x3D;2^k D. W &lt; 2^k - 1 【2019上】采用HDLC协议进行数据传输，帧0-7循环编号为0、1、2、3、4的5帧时，收到了对方应答帧REJ3,此时发送站应该发送的后续3帧为()；若收到对方的应答帧为SREJ3,则发送站应发送的后续3帧为() A 2 3 4 B. 3 4 5 C. 3 5 6 D. 5 6 7 A 2\\3\\4 B. 3\\4\\5 C. 3\\5\\6 D. 5\\6\\7 【2009上】HDLC协议是一种(), 采用()标志作为帧定界符 A.面向比特的同步链路控制协议B B.面向字节技术的同步链路控制协议 C.面向字符的同步链路控制协议 D.异步链路控制协议 A.10000001 B.01111110 C.10101010 D.101101011 X.25与帧中继已经被IP和以太网取代了 X.25公共数据网（了解） X.25分为三个协议层，即物理层、链路层和分组层，分别对应OSI模型低三层 X.25是一种分组交换技术，面向连接，建立虚链路 X.25支持差错控制和流量控制，传输速率：64Kbps 帧中继FR(Frame Relay) 选择常考 帧中继在第二层建立虚链路，提供虚链路服务，本地表示DLCI 基于分组交换的透明传输，可提供面向连接的服务。 只做检错和拥塞控制，没有流量控制和重传机制，开销很少 既可以按需要提供带宽，也可以应对突发的数据传输 CIR(承诺速率) EIR(扩展速率) 帧长可变，长度可达1600-4096字节，可以承载各种局域网的数据帧 可以达到很高的速率，2-45Mbps 不适合对延迟敏感的应用(语音、视频) 数据的丢失依赖于运营商对虚电路的配置 不保障可靠的提交 【2013下】帧中继的网络虚电路建立在(),这种虚电路的特点是() A.数据链路层 B.网络层 C.传输层 D.会话层 A.没有流量控制功能，也没有拥塞控制功能 B.没有流量控制功能，但具有拥塞控制功能 C.具有流量控制功能，但没有拥塞控制功能 D.具有流量控制功能，也具有拥塞控制功能 【2012下】下面用于表示帧中继虚链路标识符是() A.CIR B.LMI C.DLCI D.VPI ISDN和ATM ISDN综合数字业务网，目的是以数字系统代替模拟电话系统（PSTW），把音频、视频、数据业务放在一个网上统一传输 分为窄带ISDN和宽带ISDN，窄带ISDN提供两种用户接口 基本速率BRI&#x3D;2B+D&#x3D;144Kbps 集群速率PRI&#x3D;30B+D&#x3D;2.048Mbps 宽带ISDN即ATM ATM是信元交换，信元为53字节固定长度 ATM依然是以虚链路提供面向连接的服务 ATM典型速率为150M 【2014下】典型运营商提供的ISDN服务有两种不同接口，其中供小型企业和家庭使用的基本速率接口(BRI)速率是(),供大型企业使用的接口速率是() A.128Kb&#x2F;s B.144Kb&#x2F;s C.1024Kb&#x2F;s D.2048Kb&#x2F;s A.128Kb&#x2F;s B.144Kb&#x2F;s C.1024Kb&#x2F;s D.2048Kb&#x2F;s","categories":[{"name":"网络工程师","slug":"网络工程师","permalink":"https://primeluoqiu.github.io/categories/%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B%E5%B8%88/"}],"tags":[],"keywords":[{"name":"网络工程师","slug":"网络工程师","permalink":"https://primeluoqiu.github.io/categories/%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B%E5%B8%88/"}]},{"title":"1.2初识输入输出","slug":"C++Primer/Chapter1/1.2","date":"2024-04-18T15:50:10.094Z","updated":"2024-04-18T15:57:15.380Z","comments":true,"path":"2024/04/18/C++Primer/Chapter1/1.2/","link":"","permalink":"https://primeluoqiu.github.io/2024/04/18/C++Primer/Chapter1/1.2/","excerpt":"","text":"1.2初识输入输出C++语句并未定义任何输入输出，取而代之包含了一个全面的标准库(standard library)来提供IO机制。对于很多用途，我们只需要了解IO库中一部分基本概念和操作。 iostream库包含两个基础类型:istream和ostream。分别对应in和out。一个流就是一个字符序列，是从IO设备读出或写入IO设备的。术语”流”想要表达的是，随着时间的推移，字符是顺序生成或消耗的。 标准输入输出对象标准库定义了4个IO对象。为了处理输入，我们使用一个名为cin的istream的对象。这个对象也被称为标准输入。对于输出，我们使用一个名为cout的ostream类型的对象。此对象也被称为标准输出。标准库还定义了其他两个ostream类型的对象，名为ccer和clog。我们通常用cerr来输出警告和错误信息，因此它也被称为标准错误。而clog用来输出程序运行时的一般性信息。 系统通常将程序所运行得窗口与这些对象关联起来。因此当我们读取cin，数据将从程序正在运行的窗口读入，当我们向cout、cerr和clog写入数据时，将会写到同一个窗口。 一个使用IO库的程序我们先看一下如何将两个数相加。通过IO库，我们可以扩展main程序，使之能提示用户输入两个数，然后输出他们的和 12345678910#include &lt;iostream&gt;int main()&#123; std::cout &lt;&lt; &quot;Enter two numbers: &quot; &lt;&lt; std::endl; int v1 = 0, v2 = 0; std::cin &gt;&gt; v1 &gt;&gt; v2; std::cout &lt;&lt; &quot;The sum of &quot; &lt;&lt; v1 &lt;&lt; &quot; and &quot; &lt;&lt; v2 &lt;&lt; &quot; is &quot; &lt;&lt; v1 + v2 &lt;&lt; std::endl; return 0;&#125; 第一行告诉编辑器我们想要使用iostream库，尖括号中的名字指出了一个头文件。每个使用标准库的设施的程序都必须包含相关的头文件。#include指令和头文件的名字必须写在同一行中。通常情况下，#include指令必须出现在所有函数之外。 向流写入数据在C++中，一个表达式产生一个计算结果，它是由一个或多个运算对象和一个运算符组成。这条语句中的表达式使用了**输出运算符&lt;&lt;**再标准输出上打印消息 1std::cout &lt;&lt; &quot;Enter two numbers:&quot; &lt;&lt; std::endl; &lt;&lt;运算符接受两个运算对象：左侧的运算对象必须是一个ostream对象，右侧的运算对象是要打印的值。此运算符将给定的值写到给定的ostream对象中。输出运算符的计算结果就是其左侧运算对象。也就是说，计算结果就是写入给定值的那个ostream对象。 我们的输出语句使用了两次&lt;&lt;运算符。因为运算符返回其左侧的运算对象，因此第一个运算符的结果成为了第二个运算符的左侧运算对象。这样，我们就可以将输出请求连接起来。 endl是一个操纵符的特殊值。写入endl的效果是结束当前行。并将与设备关联的缓冲区(buffer)中的内容刷到设备中。 缓冲刷新操作可以保证到目前为止程序所产生的所有输出都真正写入输出流中，而不是仅停留在内存中等待写入流。 使用标准库中的名字前缀std::指出cout和endl是定义在名为std的命名空间中的。命名空间可以帮助我们避免不经意的名字定义冲突，以及使用库中相同名字导致的冲突。标准库定义的所有名字都在命名空间std中 不过通过命名空间使用标准库有个副作用：当使用标准库中的一个名字时，必须显式说明我们想使用来自命名空间std中的名字。例如，需要写出std::cout，通过使用**作用域运算符(::)**来指出我们想使用定义在命名空间中std中的名字cout。 从流中读取数据**输入运算符(&gt;&gt;)**与输出运算符类似，他接受一个istream作为其左侧运算对象，接受一个对象作为其右侧运算对象。它从给定的istream读入数据，并存入给定对象中。输入运算符返回其左侧运算对象作为其运算结果。 标准库定义了不同版本的输入输出运算符，来处理输出语句中的不同类型的运算对象。","categories":[{"name":"C++ Primer","slug":"C-Primer","permalink":"https://primeluoqiu.github.io/categories/C-Primer/"}],"tags":[],"keywords":[{"name":"C++ Primer","slug":"C-Primer","permalink":"https://primeluoqiu.github.io/categories/C-Primer/"}]},{"title":"1.1编写一个简单的C++程序","slug":"C++Primer/Chapter1/1.1","date":"2024-04-18T15:50:02.616Z","updated":"2024-04-18T15:57:31.184Z","comments":true,"path":"2024/04/18/C++Primer/Chapter1/1.1/","link":"","permalink":"https://primeluoqiu.github.io/2024/04/18/C++Primer/Chapter1/1.1/","excerpt":"","text":"1.1编写一个简单的C++程序本章内容是编写一个程序来解决简单的书店问题。 ​ 书店保存所有销售记录的档案，每条记录保存了某本书的一次销售的信息(一册或多册)。每条记录包含三个数据项 10-201-70353-X 4 24.99 第一项是书的ISBN号，第二项是售出的册数，最后一项是书的单价。 为了编写这个程序，我们要使用若干C++的基本特性。而且，我们需要了解如何编译及运行程序。 很显然，它需要 定义变量 进行输入和输出 使用数据结构保存数据 检测两条记录是否有相同的ISBN 包含一个循环来处理销售档案中的每条记录 我们首先介绍如何用C++来解决这些子问题，然后编写书店程序 一个函数的定义包含四部分:返回类型(return type) 、 函数名、一个括号包围的形参列表，以及函数体 main函数的返回类型必须为int，即整数类型。int类型是一种内置类型，即语言自身定义的类型。 return语句结束函数的执行。当return语句包括一个值的时候，此返回值的类型必须与函数的返回类型相容。 在大多数系统中，main的返回值被用来指示状态。返回值0表明成功，非0的返回值的含义由系统定义，通常用来指出错误类型 1.1.1 编译、运行程序编写好程序就要编译了。很多PC上的编译器都具备集成开发环境(Integrated Development Environment, IDE),将编译器与其他程序创建和分析工具包装在一起。在开发大型程序的时候，这类集成环境会是非常有用的工具 大部分编译器包括集成IDE的编译器，都会提供一个命令行。接触命令行界面学习C++还是很容易的。一旦掌握了语言，IDE通常很容易学习。 程序源文件命名约定大多数编译器都要求程序源码存储在一个或多个文件中。程序文件通常被称为**源文件(source file)**。源文件通常以一个后缀结尾，告诉系统这个文件是一个c++程序。不同编译器使用不同的后缀命名约定。 命令行运行编译器如果正在使用命令行，那么通常是在一个控制台窗口内编译程序。假定main程序保存在文件prog1.cc中。可以如下方式编译 1$ cc prog1.cc 在Windows中运行的话 1$ prog1 其他 1$ .\\prog1 在Unix中的话是 123$ a.out$./a.out$ echo $? #在执行完一个程序之后，都可以通过echo获得返回值","categories":[{"name":"C++ Primer","slug":"C-Primer","permalink":"https://primeluoqiu.github.io/categories/C-Primer/"}],"tags":[],"keywords":[{"name":"C++ Primer","slug":"C-Primer","permalink":"https://primeluoqiu.github.io/categories/C-Primer/"}]},{"title":"数据通信基础","slug":"网络工程师/数据通信基础","date":"2024-04-18T13:24:40.865Z","updated":"2024-04-18T13:25:30.291Z","comments":true,"path":"2024/04/18/网络工程师/数据通信基础/","link":"","permalink":"https://primeluoqiu.github.io/2024/04/18/%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B%E5%B8%88/%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1%E5%9F%BA%E7%A1%80/","excerpt":"","text":"数据通信基础本章只考上午题，考试一般3-5分，有逐年增大的趋势。 最长考点:PCM、E1、海明码…难点：海明码和CRC 信道特性重点是两个公式 数据通信基本概念首先，通信的目的就是为了传递信息。通信中产生和发送信息的一端叫信源，接收信息的一端叫信宿，信源和信宿之间的通信线路成为信道。 通信系统的模型如此 ​ 噪声 ​ ↓ 信源 -&gt; 变换 -&gt; 信道 -&gt; 变换 -&gt; 信宿 首先，我们要知道，信号分为两种，分别是连续的模拟信号和离散的数字信号，前者类似于声波，后者类似于电脑之间的信息传递。那么为什么中间会有变换呢，是因为，理想状态下肯定是信源发送的是连续的模拟信号，信道也是模拟信号的信道，但是有些时候可能信源是模拟信号，但是信道会是数字信号的信道，这个时候就需要转换了。当然，就像声音在传播的过程中会出现干扰一样，信号在传播的时候也会受到干扰，这就是上面出现的噪声。 信道带宽(常考)模拟信道: 1W = f2 - f1 就是信道能通过的最高频率减最低频率。单位是Hz 数字信道： ​ 数字信道是离散信道，带宽为信道能够达到的最大数据传输速率，单位是bit&#x2F;s 数据传输速率 ​ 指每秒钟能够传输的二进制数据位数，单位为比特&#x2F;秒(记作 bit&#x2F;s b&#x2F;s 或bps) 1B &#x3D; 8bit 码元： ​ 一个数字脉冲称为一个码元(可以理解为时钟周期的信号) 码元速率： 单位时间内信道传送的码元个数。如果码元宽度(脉冲周期)为T，则**码元速率(波特率)**B 1B = 1/T 单位是波特(Baud) 一个码元携带信息量n(位)与码元种类数(N)的关系是$$n &#x3D; log_2N$$ 举例来说，假如有两个码元种类，那么携带的信息数只有0和1，也就是只有一位。那么四个码元种类呢 那么就有 00 01 10 11这四种，对应的肯定是两位了。同理，8种对应的就是3类 信道特性来奎斯特定理在一个理想的（没有噪声）的信道中，若信道带宽为W， 最大码元速率为：$$B &#x3D; 2W (baud)$$ 极限数据速率为$$R &#x3D; Blog_2N&#x3D;2Wlog_2N$$理解：每秒包裹总重&#x3D;每秒发送包裹个数*每个包裹重量 香农定理在一个噪声信道的极限速率和带宽之间的关系。 极限速率公式为: $$ C&#x3D;Wlog_2(1+S&#x2F;N)$$ 分贝与信噪比关系 $$dB &#x3D; 10log_10S&#x2F;N$$ 其中W为带宽，S为信号平均功率，N为噪声平均功率，S&#x2F;N为信噪比 dB&#x3D;10， S&#x2F;N&#x3D;10 dB&#x3D;30 , S&#x2F;N &#x3D;1000 log21001 ≈ log21024 &#x3D; 10 误码率(考的少) 误码率是衡量数据通信系统在正常工作下传输可靠性的指标 定义：传输出错的码元数占传输总码元数的比例，误码率越小，通信可靠性越高 Pe &#x3D; Ne&#x2F;N 其中Ne表示出错数，N表示传送总数 计算机网络通信中，误码率一般要求低于10^-6 数据延时 &lt; 200ms ，语音视频延时 &lt; 50ms 抖动 &lt; 20ms, 丢包率 &lt; 1% 信道延迟(考频较高)信道延迟： 与源端和宿端距离有关，也与具体信道中的信号传播速率有关。 光速为300m&#x2F;&#x2F;us &#x3D; 300000km&#x2F;s 电缆中传播速度一般为光速的77%，即200m&#x2F;us &#x3D; 200000km&#x2F;s 例如500m同轴电缆时延大概为2.5us 卫星信道的时延大约270ms(来回双向的延迟) 发送数据时间&#x3D;线路延迟+调制延迟 路上跑的时间+排队上车的时间 【2014上】：在地面上相距2000km的两地之间通过电缆传输4000比特长的数据包，数据速率为64Kb&#x2F;s，从开始发送到接收完成需要的时间为 a. 48ms b.640ms c.32.5ms d.72.5ms 【2018上】在相隔20km的两地通过电缆以100Mb&#x2F;s的速率传送1518字节长的以太帧，从开始发送到接收完成数据需要的时间约是 a.131us b.221us c.1310us d.2210us 解答： 电缆传输速率是200000km&#x2F;s$$210^4km&#x2F;210^6km &#x3D; 1&#x2F;100ms$$ $$410^3bit&#x2F;6410^3 &#x3D; 1&#x2F;16ms$$ D 注意换算B 传输介质 双绞线：8根铜导线每两根扭在一起(百兆用4根，千兆必须用8根) 分类：直通线&#x2F;交叉线， 屏蔽线和非屏蔽双绞线 为什么要扭在一起，为了消除每跟线和每根线之间的磁场干扰。如果有一个线坏了，那么速度会降速。 直通线是指568A-568A 交叉线是指568A-568B 相同设备的话用的是交叉线，不同设备是交叉线。 光纤：利用光在玻璃或塑料纤维中的全反射原理而达成的光传导工具 光传导比电缆传导的损耗低得多，光纤适合用于长距离的信息传递(双绞线100m， 光纤100km) 光线特点：重量轻，体积小，传输远(衰减小)，容量大(4T&#x2F;s)，抗电磁干扰 光纤分类 单模光纤 当光纤的几何尺寸可以与光波长相比拟时，即纤芯的几何尺寸与光信号波长相差不大时，一般为5~10um； 光纤只允许一种模式在其中传播，单模光纤具有极宽的带宽，特别适用于大容量、长距离的光纤通信（贵） 多模光纤 多模光纤纤芯的几何尺寸远大于光波波长，一般为50um、62.5um；允许多种模式光信号传播 多模光纤仅用于较小容量、短距离的光纤传输通信（便宜） 多模光纤运行波长 850nm或1300nm 单模光纤运行波长 1310nm或1550nm SX（多模光纤）- 颜色橘黄色 光源是发光二极管 LX（单模光纤） - 颜色黄色 光源是激光二极管 LH&#x2F;ZX（单模光纤）传输距离远 10-120km 颜色黄色 光源是激光二极管 光纤是没有带宽的，只有光模块的配合才有带宽这一说。光纤只有单模和多模。 【2018上】：关于单模光纤，下面描述中错误的是 a.芯线由玻璃或塑料制成 b.比多模光纤纤芯小 c.光波在芯线中以多种反射路径传播 d.比多模光纤传输距离远 答案：C 单模不是多模 数据编码单极性码：用正的或负的电压表示数据，高电压表示二进制数1，无电压表示二进制数0。(容易出现的问题：如果有0.5就很难办) 极性码：分别用正负电压表示二进制数0和1，这种电平相差较大，抗干扰能力好。 双极性码：信号在三个电平之间变化，一种典型的双极性编码就是信号交替反转编码(Alternative Mark Inversion) 如下图，0电平表示0， 1则在正负之间交替反转，1跳0不跳 归零编码：在归零编码(Return to Zero, RZ)中，码元中间的信号回归到零电平。 从负电平到零电平的转换边表示码元”1”，从正电平到零电平的转换边表示码元”0” 不归零编码(Not Return to Zero, NRZ):规律是，当出现”1”时电平反转，当出现”0”时电平不翻转，也叫差分码 主要用在终端到调制解调器的接口中。 双相码曼彻斯特编码（重点考点） 曼彻斯特编码是一种双相码，在每个比特中间均有一个跳变，第一个编码自定义，假如下图由高电平向低电平跳变代表”0”，由低电平向高电平跳变代表”1” 曼彻斯特编码常用于以太网中 差分曼彻斯特编码(重点考点) 差分曼彻斯特编码 也是一种双相码 用在令牌环网中 有跳变代表”0”,无跳变代表”1”【有0无1】，第一个也是自定义的 不是比较形状，比较起始电平(上一个的终止与下一个起点) 两种曼彻斯特编码特点 优点：将时钟和数据包含在信号数据流中，也称自同步码 缺点：编码效率低：每个码元都要调制为两个不同的电平，因而调制速率是码元速率的两倍，这对信道的带宽提出了更高的要求，例如当数据传输速率为100Mbps时，需要200MHz的脉冲 **编码效率都是50%**，一般指用于最早的10M以太网编码 4B&#x2F;5B编码（重点考点） 发送数据流每4bit，先使用不归零码(NRZ-I)，编码成5bit，多一位用于解决同步问题 各种编码效率 曼码和差分曼码效率50%，用于以太网 4B&#x2F;5B效率80% 用于百兆以太网 8B&#x2F;10B效率80% 用于千兆以太网 64B&#x2F;66B效率97%，用于万兆以太网 【2012上】曼彻斯特编码的效率是(), 4B&#x2F;5B编码的效率是()% a.40 b.50 c.80 d.100 a.40 b.50 c.80 d.100 【2011下】（不吃饭也要会） 【拓展思考】 (同上) 2.5调制技术(出现频率比较高) 将数字信号转换成模拟信号称为调制，将模拟信号转换为数字信号称为解调 幅度键控(ASK)：用载波的两个不同振幅表示0和1 频移键控(FSK)：用载波的两个不同频率表示0和1 相移键控(PSK)：用载波的起始相位的变化表示0和1 正交幅度调制(QAM)：把两个幅度相同但相位相差90°的模拟信号合成一个模拟信号 码元只取两个相位值叫2相调制，码元取四个相位叫做四相调制，N&#x3D;2 &#x2F; 4 DPSK(Double)是二项 QPSK（Quarter)是四项 【2011下】可以用数字信号对模拟载波的不同参量进行调制，下图所示的调制方式称为() 【2014下】所谓正交幅度调制是把两个()的模拟信号合成一个载波信号 a.幅度相同相位相差90° b.幅度相同相位相差180° c.频率相同相位相差90° d.频率相同相位相差180° a 【2016上】通过正交幅度调制技术把ASK和PSK两种调制模式结合起来组成16种不同的码元，这时数据速率是码元速率的()倍 a.2 b.4 c.8 d.16 b 【2017下】下图展示的编码方式是()。若数据速率为1kb&#x2F;s，则载波速率为()Hz a.DPSK b.BPSK c.QPSK d.MPSK a.1000 b.2000 c. 4000 d.8000 【2018下】以下关于DPSK描述，正确的是() a.采用两种相位，一种固定表示数据”0”,一种固定表示数据”1” b.采用两种相位，通过前后有无相位改变来表示数据”0”和”1” c.采用四种振幅，每个码元表示2比特 d.采用四种频率，每个码元表示2比特 【2019上】设信号的波特率(码元速率)为1000Baud，信道支持的最大数据速率为2000b&#x2F;s,则信道采用的调制技术为() a. BPSK b.QPSK c.BFSK d.4B5B 2.6 脉码调制PCM(出现频率高)解调：把模拟信号转换为数字信号的过程 常用数字化技术就是脉冲编码调制技术，简称脉码调制 PCM数字化过程三个步骤：采样、量化和编码 采样：按照一定时间间隔对模拟信号进行取样，把模拟信号的当前值作为样本 奈奎斯特采样定理：如果模拟信号的最高频率为fmax，若以大于2fmax的采样频率对其进行采样，则采样得到的离散信号序列就能完整的恢复出原始信号 量化：把取样后得到的样本由连续值转换为离散值，离散值的个数决定了量化的精度。 如图，把量化等级分为8级(n &#x3D; log2N的大N)，用000-111这8个二进制数分别代表不同的电平幅度 编码：把量化后的样本值变成相应的二进制代码，可以得到相应的二进制代码序列，其中每个二进制代码都可以用一个脉冲串来表示，这一组脉冲序列就代表了经PCM编码的模拟信号 如：对声音信号数字化时，由于语音最高频率是4kHz，所以取样频率是8kHz。对语音样本用128个等级量化，因而每个样本用7bit表示。在数字信道上传输这种数字化后的语音信号速率是7*8000&#x3D;56kbps 【2013上】 假设模拟信号的频率范围是3~9MHz，采用频率必须大于()时，才能使得到的样本信号不失真。 A.6MHz b.12Mhz c.18Mhz d.20MHz f&#x3D; 2fmax 【2013下】设信道带宽为4000Hz，采用PCM编码，采样周期为125us，每个样本量化后为128个等级，则信道的速率为() a.10kb&#x2F;s b.16Kb&#x2F;s c.56Kb&#x2F;s d.64Kb&#x2F;s 有周期考虑到频率，就是用倒数来做。 N&#x3D; 128 n &#x3D; 7 2.8 通信和交换方式考点比较少，很好理解。 1.数据通信方式 按通信方向分： 单工通信：信息只能在一个方向传送，发送方不能接收，接收方不能发送(电视&#x2F;广播) 半双工通信：通信的双方可以交替发送和接收信息，但不能同时接收或发送(对讲机&#x2F;WIFI&#x2F;HUB) 全双工通信：通信双方可同时进行双向的信息传送(电话、交换机) 2.按同步方式分 两种传输方式：异步传输和同步传输 异步传输：把各个字符分开传输，在字符之间插入一位起始位(0)，在字符之后插入一位停止位(1),起始位对接收方的时钟起置位作用。在字符和停止位之间还要插入一位校验位，一般使用奇偶校验 1位起始位 7位字符 1位校验位 1位停止位 同步传输：比特分组(帧)要大得多。不是独立发送每个字符，而是把他们组合起来一起发送。我们称这些组合为数据帧，或简称帧。数据帧的第一部分包含同步字符，用于通知接收方一个帧已经达到。帧的最后一部分是一个帧结束标记。 【2016下】在异步通信中，每个字符包含1位起始位，7位数据位，1位奇偶位和1位终止位，每秒钟传送100个字符，采用DPSK调制，则码元速率为()， 有效数据速率为() a.200波特 b.500波特 c.1000波特 d.2000波特 a.200b&#x2F;s b.500b&#x2F;s c.700b&#x2F;s d.1000b&#x2F;s 7*100 &#x3D; 700 c 码元速率求B R&#x3D;Blog2N DPSK N &#x3D; 2 R &#x3D; 1000 B &#x3D; 1000 c 2.交换方式 数据交换技术有三种：电路交换、报文交换和分组交换 电路交换：一条物理通路，线路被释放之前处于占用状态 报文交换：从发送方传送到接收方采用存储转发的方式。完整的报文在一个个节点间传送 分组交换：分两种，数据报和虚电路 数据报：每个分组都被独立的处理，每个节点根据一个路由选择算法，为每个分组选择一条路径，使它们的目的地相同。 虚电路：在传送之前，先建立起一条逻辑上的连接(VPN)，每个分组都沿着一条路径传输。(X.25 FR ATM) 减小了延迟，提高了吞吐 分组交换可以按分组纠错，发现错误只需重发出错的分组，通信效率提高。 2.8 数字传输系统 E1&#x2F;T1多路复用技术是把多个低速的信道组合成一个高速的信道的技术 光纤入户：分成上网、电视和电话 这种技术要用到两个设备： 多路复用器(Multiplexer),在发送端根据某种约定的规则吧多个地贷款的信号复合成一个高带宽的信号 多路分配器(Demultiplexer),在接收端根据统一规则把高带宽信号分解成多个低带宽信号 二者统称多路器，简写MUX 以上了解即可 数字传输系统 脉码调制已经介绍，对4kHz语言信道按照8kHz速率采样，128级量化，则每个语音信道的比特流是56Kbps 美国和日本使用T1标准，T1&#x3D;56K*24 + 开销和间隔 &#x3D; 1.544M T2 &#x3D; 4T1 T3&#x3D;7T2 T4&#x3D;6T3 ITU-T标准E1信道数据 数据速率是2.048Mbps，把32个8位一组的数据样本组装成125us的基本帧，其中30个子信道用于语音传送，2个子信道(CH0和16)用于控制信令。 E1每秒语音64Kb E5-E4-…E1每一个前者都是后者的四倍。 【2016上】 T1的载波速率是() a.1.544Mb&#x2F;s b.6.321Mb&#x2F;s c.2.048Mb&#x2F;s d.44.736Mb&#x2F;s 【2011下】E1信道速率是(), 其中每个语音信道的数据速率是() a.1.544Mb&#x2F;s b.2.048Mb&#x2F;s c.6.312Mb&#x2F;s d.44.736Mb&#x2F;s A.56kb&#x2F;s B.64Kb&#x2F;s C.128Kb&#x2F;s D.2048kb&#x2F;s 同步数字序列重点：STM-1 155Mbps STM-4 322Mbps STM-16 2.5Gbps STM-64 10Gbps 同步数字序列(SDH)是光纤信道复用标准，其中最常用的STM-1(OC-3)速率是(15)，STM4(OC-12)速率是(16)(15) A.155.20Mb&#x2F;sB.622.08Mb&#x2F;sC.2488.320Mb&#x2F;sD. 10Gb&#x2F;s(16) A.155.20Mb&#x2F;sB.622.08Mb&#x2F;sC.2488.320Mb&#x2F;sD. 10Gb&#x2F;s 2.9海明码纠错码数据传输中的错误要采用差错控制方法。数据通信中常用的办法是检错和纠错 差错控制原理：传输k位，加入r位冗余，接受方收到进行计算比较 知道差错并请求重传称为检错，知道差错且知道是什么，叫纠错 奇偶校验是最常用的检错方法，能检测出一位错位 原理：在7位ASCII后增加一位，使码字中的1的个数成奇数(奇校验)或偶数(偶校验) 奇校验：整个校验码(包括有效信息和校验位)中1的个数是奇数 偶校验：整个校验码中1的个数为偶数 海明码：通过冗余数据位来检测和纠正差错的编码方式 海明距离：一个码字要变成另一个码字时必须改变的最小位数 例如：7位ASCII码增加一位奇偶位称为8位的码字，这128个8位的码字之间的海明距离是2，所以当其中1位出错时便能检测出来，两位出错无能为力。 海明码原理：在数据中间加入几个校验码，码距均匀拉大，当某位出错，会引起几个校验位的值发生变化。 海明不等式：校验码个数为k，可以表示2^k个信息，一个信息用来表示没有错误，其余2^k-1个表示数据中存在错误，如果满足$$2^k-1&gt;&#x3D;m+k$$(m+k)为编码后的数总长度，则在理论上k个校验码就可以判断是哪一位出了问题。 【2014上&#x2F;2016上】海明码是一种纠错码，一对有效码字之间的海明距离是(), 如果信息位6位，要求纠正1位错，按照海明编码规则，需要增加的校验位至少()位 A.两个码字的比特数之和 B.两个码字的比特数之差 C.两个码字之间相同的比特数 D.两个码字之间不同的比特数 A.3 B.4 C.5 D.6 【2018上】 海明码是一种纠错码，其方法是为需要校验的数据位增加若干校验位，使得校验位的值决定某些被校位的的数据，当被校数据出错时，可根据校验位的值变化找到出错位，从而纠正错误。对于32位的数据，至少增加()个校验位才能构成海明码 A.3 B.4 C.5 D.6 以10位数据为例，其海明码表示为D9D8D7D6D5D4P4D3D2D1P3D0P2P1，其中Di表示数据位，Pj表示校验位，数据位D9由P4P3和P2进行校验(从右至左D9的位序为14，即等于8+4+2，因此用第8位的P4，第4位的P3和第2位的P2校验)，数据D5由()进行校验 A.P4P3 B.P4P2 C.P4P3P1 D.P3P2P1 CRC循环冗余码能检错不能纠错，广泛用于网络通信和磁盘存储 采用CRC进行差错校验，生成多项式为G(X)&#x3D;X^4+X+1信息码字为10111，则计算出CRC校验码是（） 过程分为以下几步 判断校验位数：生成多项式的最高次方是几，校验位就是几位 4位校验位 补齐数据位后面的0 10111 0000 提取生成多项式的系数 G(X)&#x3D;1xX^4+0*X^3 &#x3D; 10011 用第二步的结果，除以第三步的结果(异或运算) 余数就是CRC校验码，余位不够位，前面补0 答案：1100 【2013下】循环冗余校验码CRC-16的生成多项式为G(X) &#x3D; X^16 + X^15 + X^2 + 1，它产生的校验码是()位，接收端发现错误采取的措施是() A.2 B.4 C.16 D.32 A.自动纠错 B.报告上层协议 C.重新生成数据 D.自动请求重发","categories":[{"name":"网络工程师","slug":"网络工程师","permalink":"https://primeluoqiu.github.io/categories/%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B%E5%B8%88/"}],"tags":[],"keywords":[{"name":"网络工程师","slug":"网络工程师","permalink":"https://primeluoqiu.github.io/categories/%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B%E5%B8%88/"}]},{"title":"网络体系结构","slug":"网络工程师/网络体系结构","date":"2024-04-18T13:24:40.861Z","updated":"2024-04-18T13:28:40.517Z","comments":true,"path":"2024/04/18/网络工程师/网络体系结构/","link":"","permalink":"https://primeluoqiu.github.io/2024/04/18/%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B%E5%B8%88/%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/","excerpt":"","text":"第一学时 网络体系结构OSI参考模型两个点 一个是七个模型要记住，再一个是每个模型对应的叫什么。 比如： 应用层-&gt;数据-&gt;进程号 传输层-&gt;数据段-&gt;端口号 -&gt;端到端的传输 网络层-&gt;数据包-&gt;IP地址 数据链路层-&gt;数据帧-&gt; Mac地址 -&gt; 点到点的传输 物理层-&gt;比特流 看几个例题 【2016下】：数据封装的正确顺序是 a.数据、帧、分组、段、比特 b.段、数据、分组、帧、比特 c.数据、段、分组、帧、比特 d.数据、段、帧、分组、比特 【2005上】：在OSI参考模型中，上层协议实体和下层协议实体之间的逻辑接口叫做服务访问点(SAP)。在Internet中，网络层的服务访问点是 a.MAC地址 b.LLC地址 c.IP地址 d.端口号 【2005上+2016下】：在OSI参考模型中，实现端到端的应答、分组排序和流量控制功能的协议层是() a.数据链路层 b.网络层 c.传输层 d.会话层 【2005下】 在ISO OSI&#x2F;RM中 ()实现数据压缩功能。 a.应用层 b.表示层 c.会话层 d.网络层 在OSI参考模型中，数据链路层处理的数据单位是() a.比特 b.帧 c.分组 d.报文","categories":[{"name":"网络工程师","slug":"网络工程师","permalink":"https://primeluoqiu.github.io/categories/%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B%E5%B8%88/"}],"tags":[],"keywords":[{"name":"网络工程师","slug":"网络工程师","permalink":"https://primeluoqiu.github.io/categories/%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B%E5%B8%88/"}]},{"title":"1.6 高阶函数","slug":"ClassesFormUCBerkely/CS61A/1.6","date":"2024-04-14T03:22:11.346Z","updated":"2024-04-14T05:43:52.342Z","comments":true,"path":"2024/04/14/ClassesFormUCBerkely/CS61A/1.6/","link":"","permalink":"https://primeluoqiu.github.io/2024/04/14/ClassesFormUCBerkely/CS61A/1.6/","excerpt":"","text":"1.6 高阶函数我们已知函数是一种抽象方法，描述了与特定参数无关的复合操作 也就是说，在square中我们并不是讨论一个参数的平方，而是讨论一种可以获得任何数字平方的办法，当然也可以通过8*8这样的表达式来计算平方得到结果。从而不显式的提到square 这种虽然看起来很方便，但是对于一些简单的操作是足够的，但是对于复杂的表达式就会变得很麻烦，一般来说，缺少函数定义对我们来说就像是一个原始人，而不是modern people，程序虽然可以计算平方，但是缺少了对平方的概念的能力。 我们对强大的编程语言提出的要求之一就是能通过将名称分配给通用模板(general patterns)来构造抽象，然后直接使用该名称进行工作。函数提供了这种能力。代码中重复出现一些常见模板，它们可以与许多不同的函数一起使用。这些模板也可以通过给它们命名来进行抽象。 为了将某些通用模板表达为具名概念(named concepts)，我们需要构造一种可以**”接受其他函数作为参数”或可以把可以把函数当作返回值**的函数。这种可以操作函数的函数就叫做高阶函数(high-order functions)。 1.6.1 作为函数的参数现在有三个函数，分别是计算自然数之和，计算立方之和，计算一个收敛到Π的总和 12345678910111213141516&gt;&gt;&gt; def sum_naturals(n): total, k = 0, 1 while k &lt;= n: total += k k ++ return total&gt;&gt;&gt; def sum_cubes(n): total, k = 0, 1 while k &lt;= n: total, k = total + k*k*k, k+1 return total&gt;&gt;&gt; def pi_sum(n): total, k = 0, 1 while k &lt;= n: total, k = total + (4*k-3)*(4*k-1) ,k + 1 return total 我们不难看出来，它们在背后共用的其实是一个模板，它们在很大程度上是相同的，仅在名称和用于计算被加项k的函数上有所不同。我们可以通过在同一模板中填充槽位(slots)来生成每个函数: 12345def &lt;name&gt;(n): total, k = 0, 1 while k &lt;= n: total, k = total + &lt;term&gt;(k), k + 1 return total 这种通用模板的封存在证明了有一个实用的抽象手段正在”浮出水面”。这些函数都是用来求和的，我们不妨编写一个表达求和概念的函数，方法是使用通用模板，并将槽位转换为形式参数: 接下来看一个例子，summation将上界n和计算第k项的函数term作为两个参数，并简洁地表达了求和。 12345678910111213def summation(n, term): total, k = 0, 1 while k&lt;=n: total, k = total + term(k), k ++ return totaldef cube(x): return x*x*xdef sum_cubes(n): return summation(n, cube)result = sum_cubes(3) 同样的，我们还可以利用返回其函数的identity函数，我们还可以使用完全相同的summation函数对自然数求和。 1234567891011def summation(n ,term) total, k = 0, 1 while k&lt;=n: total, k = total + term(k), k ++ return totaldef identity(x): return xdef sum_naturals(n): return summation(n, identity)&gt;&gt;&gt; sum_naturals(10)55 summation函数也可以直接调用，而无需为特定数列去定义另一个函数。 pi_sum函数也可以如此，只要抽象的出来就可以。但是得有一个限制用的，例如一个精确值1e6以计算pi的近似值 123456def pi_term(x): return 8 / ((4*x-3) * (4*x-1))def pi_sum(x): return smmation(n, pi_term)&gt;&gt;&gt; pi_sum(1e6) 1.6.2作为通用方法的函数之前引入了”用户定义函数”，在有了高阶函数之后，会看到一种更强大的抽象，用一些函数来表达计算的通用方法，而且和它们调用的特定函数无关。 尽管我们对函数的意义进行了这些概念上的扩展，但我们用于查看“调用表达式如何求解”的环境模型可以优雅地、无需更改地扩展到高阶函数。当将用户定义的函数应用于某些参数时，形式参数将与局部帧中它们的值（参数可能是函数）绑定。 下面的例子实现了迭代改进(iterative improvement)的通用方法，并使它来计算黄金比例的值，黄金比例通常被称为phi，是一个接近1.6的数字。 迭代改进算法从方程的guess解(推测值)开始，重复应用update函数来改进猜测，并调用close来比较当前的guess是否已经足够接近正确值 1234def improve(update, close, guess = 1): #给一个推测值 while not close(guess): #推测之不够接近 guess = update(guess) #更新推测值 return guess #返回正确值 这个improve函数是迭代求精的的通用表达式，它并不指定要解决的问题，而是会将这些细节留给作为参数传入的update和close函数 黄金比例的一个著名特性是它可以通过反复叠加任何正数的倒数加上1来计算，而且它比它的平方小1，我们可以将这些特性表示为与improve一起使用的函数 1234def goleden_update(guess): return 1/guess + 1def square_close_to_successor(guess): return approx_eq(guess * guess, guess + 1) 以上我们调用了approx_eq函数：如果其参数大致相等，则返回True。为了实现approx_eq，我们可以将两个数字差的绝对值与一个小的公差值(tolerance value)进行比较 12def approx_eq(x, y, tolerance=1e-15): retun abs(x - y) &lt; tolerance 使用参数golden_update和square_close_to_successor来调用improve将会计算出黄金比例的有限近似值。 1&gt;&gt;&gt; improve(golden_update, square_close_to_successor) 通过追踪求解的步骤，我们可以看到这个结果是如何计算出来的。首先，将 update、close 和 guess 绑定在构造 improve 的局部帧上。然后在 improve 的函数体中，将名称 close 绑定到 square_close_to_successor ，它会使用 guess 的初始值进行调用。 1234567891011def improve(update, close, guess = 1): while not close(guess): guess = update(guess) return guessdef golden_update(guess): return 1 / guess + 1def square_close_to_successor(guess): return approx_eq(guess * guess, guess + 1)def approx_eq(x, y, tolerance=1e-3): return abs(x - y) &lt; tolerancephi = improve(golden_update, square_close_to_successor) 突然想起来一句话，虽然算法对于程序来讲非常的重要，但是对于一个臃肿的程序运行起来肯定时间很长，但是如果有了算法的加持，那么这个程序跑起来就会很快，所有的进程运行起来就会很流畅。因此就可以在类似例如打开应用的时候做出一些比较精美的打开动画，但是其实，臃肿也不代表不能用，对于现在而言，能够开发出来就已经很不错了，如果一味追求动画的优雅和流畅而连一个正常的APP都开发不出来的话，那么不久本末倒置了。 一点废话，当我没说 这个例子说明了计算机科学中两个相关的重要思想：首先，命名和函数能使我们将大量的复杂事务进行抽象。虽然每个函数定义都很简单，但是求解程序出发的计算过程非常复杂。其次，正是我们对Python有一个及其通用的求解过程，小的组件才能组合成复杂的程序。理解解释程序的求解过程有便于我们验证和检查我们创建的程序。 1.6.3 定义函数III:嵌套定义上面的示例演示了将函数作为参数传递的能力显著地增强编程语言的表达能力。每个通用概念或方程都能映射到自己的小型函数上，但这种方法的一个负面后果是全局帧会变得混乱，因为小型函数的名称必须都是唯一的。另一个问题是我们受到特定函数签名的限制：improve 的 update 参数只能接受一个参数。嵌套函数定义（Nested function definition）解决了这两个问题，但需要我们丰富一下环境模型。 那么上述的方法是不是可以拿来计算一个数的平方根呢？重复以下更新，值会收敛为的平方根。 1234def average(x, y): return (x + y)/2def sqrt_update(x, a): return average(x, a/x) 但是这个双参数更新函数和improve函数不兼容(他有两个参数，而不是一个)，而且它只提供一次更新，但是我们真正想要的是通过重复更新求平方根。这两个问题的解决方案是将函数定义放在其他函数的主体中。 123456def sqrt(a): def sqrt_update(x): return average(x, a/x) def sqrt_close(x): return approx_eq(x * x, a) return improve(sqrt_update, sqrt_close) 与局部赋值一样，这些函数之影响当前局部帧。这些函数尽在求解sqrt时在作用域内。与求解过程一致，局部在调用函数前不会被求解。 词法作用域（Lexical scope）：局部定义的函数也可以访问定义作用域内的名称绑定。在此示例中， sqrt_update 引用名称 a，它是其封闭函数 sqrt 的形式参数。这种在嵌套定义之间共享名称的规则称为词法作用域。最重要的是，内部函数可以访问定义它们的环境中的名称（而不是它们被调用的位置）。 如果想要启用词法作用域，得实现两个扩展 每个用户定义的函数都有一个定义这个函数的父环境。 在调用用户定义的函数的时候，它的局部frame会继承父环境。 在调用创建的sqrt的函数之前，所有的函数都是在全局环境中定义的。因此他们的父级都是全局环境。相比之下，当计算sqrt的前两个子句的时候，在这次调用中，它会创建局部环境关联的函数。 环境先为sqrt添加一个局部frame，然后求解sqrt_update和sqrt_close的def语句。 通过可视化网站我们可以得出Python中词法作用域的两个关键优势 局部函数的名称不会影响定义它的函数的外部名称，因为局部函数的名称将绑定在定义它的当前局部环境中，而不是全局环境中。 局部函数可以访问外层函数的环境，这是因为局部函数的函数体的求值环境会继承定义它的求值环境。 局部定义的函数通常被称为闭包。(closures) 1.6.4 作为返回值的函数通过创建”返回值就是函数”的函数，我们可以在程序中实现更强大的表达能力。带有词法作用域的编程语言的一个重要特性就是，局部定义函数在它们返回时仍持有所关联的环境。 一旦定义了许多简单的函数，函数组合(composition)就称为编程语言中的一种自然的组合方法。也就是说，给定两个函数f(x)和g(x)，我们可能想要定义h(x) = f(g(x))。我们可以使用我们现有的工具定义函数组合: 1234def compose1(f, g): def h(x): return f(g(x)) return h 下面是一个例子,展示了如何正确解析名称f和g，即使它们存在名称冲突 123456789101112131415def square(x): return x * xdef successor(x): return x + 1def compose1(f, g): def h(x): return f(g(x)) return hdef f(x): &quot;Never Called.&quot; return -xsquare_successor = compose1(square, successor)result = square_successor(12) compose1中的1表示这个组合的函数只有一个参数。这个命名惯例不是解释器强制要求的，1只是函数名的一部分。 在这点上，我们已经能够察觉到努力去精确定义计算环境模型的好处：不需要修改环境模型就可以解释如何以这种方式来返回函数。 1.6.5 示例：牛顿法这个拓展的示例展示了函数和局部定义如何协同工作，以简洁地表达一般的思想。我们将实现一种广泛用于机器学习，科学计算、硬件设计和优化的算法。 牛顿法(Newton’s method)是一种经典的迭代方法，用于查找返回值为0地数学函数地参数。这些值(参数)称为函数的零点(Zero)。找到函数的零点通常等同于解决了其他一些有趣的问题，例如求平方根。 这个操作在现代看来是非常便捷的，但是学习计算机科学的一部分是理解这样的量是如何计算的，此处介绍的一般方法适用于求解Python内置方程之外的一大类方程。 牛顿法也是一种迭代改进算法，他会对所有可微函数的零点的猜测值进行改进，这意味着它可以在任意点用直线进行近似处理。牛顿的方法遵循这些线性近似(linear approximations)来找到函数零点。 试想一条穿过点(x, f(x))的直线与函数f(x)在该点拥有相同的斜率。这样的直线称为切线(tangent)，它的斜率我们称为f在x处的导数 这条直线的斜率是函数值变化量与函数自变量的比值。所以，按照f(x)除以这个斜率来平移x，就会得到切线到达0时的自变量的值。 newton_update表示函数f及其导数df沿着这条切线到0的计算过程 1234def newton_update(f, df): def update(x): return x - f(x) / df(x) return update 最后，我们可以使用newton_update、improve算法以及比较f(x)是否接近0来定义find_root函数。 1234def find_zero(f, df): def near_zero(x): return approx_eq(f(x), 0) return improve(newton_update(f, df), near_zero) 计算根：我们可以使用牛顿法来计算任意次方根。 如果我们可以找到最后一个方程的零点，那么我们就可以计算出n次方根。通过绘制n&#x3D;2、3、6，a&#x3D;64的曲线，我们可以将这种关系可视化 我们首先通过定义f和它的导数df来实现square_root函数，使用微积分中的知识，f(x)&#x3D;x²-a的导数是线性方程df(x) &#x3D; 2x。 123456789def square_root_newton(a): def f(x): return x * x - a def df(x): return 2 * x return find_zero(f, df)&gt;&gt;&gt; square_root_newton(64)8.0 推广到n次方根，我们可以得到f(x)&#x3D;x^n-a和它的导数df(x) &#x3D; nx^n-1 123456789101112def power(x, n): &quot;&quot;&quot;返回n个x相乘&quot;&quot;&quot; product, k = 1, 0 while k &lt; n: product, k = product*x, k + 1 return productdef nth_root_of_a(n, a): def f(x): return pow(x, n) - a def df(x): return n * power(x, n-1) return find_zero(f, df) 所有这些计算中的近似误差都可以通过将approx_eq中的公差tolerance改为更小的数字来减小 当1使用牛顿法时，要注意它并不总是收敛的。improve的初始猜测必须足够接近零，并且必须满足有关函数的各种条件。尽管有这个缺点，牛顿法仍是一种用于求解微积分方程的强大的通用计算方法。现代计算机技术中的对数和大整数除法的快速算法，都采用了该方法的变体。 1.6.6 柯里化我们可以使用高阶函数将一个接受多个参数的函数转换为一个函数链，每个函数接受一个参数。 给定一个函数f(x, y)可以定义另一个函数g使得g(x)(y) == f(x, y)。g是一个高阶函数，它接受单个参数x并返回另一个接受单个参数y的函数。这种转化称为柯里化 例如pow函数的柯里化版本 1234567def curried_pow(x): def h(y): return pow(x, y) return h&gt;&gt;&gt; curried_pow(2)(3)8 ​ 感觉就是在嵌套函数的基础上，通过定义一个新的函数，然后传入两个参数，主函数返回定义的新的函数的值即可。 例如我们计算2的前10次方，我们就可以不用专门编写一个函数来实现。而是 12&gt;&gt;&gt; map_to_range(0, 10, curried_pow)... 我们可以类似地使用相同的两个函数来计算其他数字的幂。柯里化允许我们这么做，而无需为每个数字编写特定的函数。 上面，我们对pow进行了柯里化变换，得到了curried_pow。相反，我们可以定义函数来自动进行柯里化，以及逆柯里化变换。 123456789101112131415161718192021222324def curry2(f): &quot;&quot;&quot;返回给定的双参数函数的柯里化版本&quot;&quot;&quot; def g(x): def h(y): return f(x, y) return h return gdef cuury2(g): &quot;&quot;&quot;返回给定的柯里化函数的双参数版本&quot;&quot;&quot; def f(x, y): return g(x, y) return f&gt;&gt;&gt; pow_curried = curried2(pow)&gt;&gt;&gt; pow_curried(2)(5)32&gt;&gt;&gt; map_to_range(0, 10, pow_curried(2))1248...512 curry2函数接受一个双参数函数f并返回一个单参数函数g。当g应用于参数x时，它返回一个单参数函数h。当h应用于参数y时，它调用f(x, y)。因此，curry2(f)(x)(y)等价于f(x, y)。uncurry2函数反转了柯里化变换，因此uncurry2(curry2(f))等价于f 12&gt;&gt;&gt; uncurry2(pow_curried)(2, 5)32 1.6.7 Lambda表达式在Python中，我们可以使用lambda表达式临时创建函数，这些表达式会计算为未命名的函数。一个lambda表达式的计算结果是一个函数，它仅有一个返回表达式作为主体。不允许使用赋值和控制语句。 12&gt;&gt;&gt; def compose(f, g): return lambda x: f(g(x)) 我们可以通过构造相应的英文句子来理解lambda表达式的结构 12lambda x : f(g(x))&quot;A function that takes x and returns f(g(x))&quot; lambda表达式的结果称为lambda函数(匿名函数)。它没有固有名称，但除此之外它的行为与任何其他函数都相同 12345&gt;&gt;&gt; s = lambda x: x * x&gt;&gt;&gt; s&lt;function &lt;lambda&gt; at ......&gt;&gt;&gt; s(12)144 从环境图当中来看的话，lambda表达式的结果也是一个函数，以希腊字母λ(lambda)命名。我们的compose示例就可以用lambda表达式非常简洁的表示出来 12345def compose1(f, g): return lambda x: f(g(x))f = compose1(lambda x: x * x, lambda y: y + 1)result = f(12) 虽然lambda表达式这种方式更短更直接。然而，它确实出了名的难以辨认。 一般来说，Python style更喜欢使用明确的def语句哈不是lambda表达式，但在需要简单函数作为参数或返回值的情况下可以使用它们。 1.6.8 抽象和一等函数作为程序员，我们应该警觉地寻找发现我们程序中的基本抽象，然后对其进行扩展，并加以推广去创建更强大的抽象。要选择符合任务地抽象级别。不过，重要的是我们能够思考这些抽象的概念，然后准备好将其应用到新的环境中。高阶函数的重要性在于，它们使我们将这些抽象显示地表示为我们编程语言中的元素，以便可以像其他元素一样处理。 一般而言，编程语言会对计算元素的操作方式施加限制。拥有最少限制的元素可以获得一等地位(first-class status)。这些一等元素的”权力和特权包括” 可以与名称保定 可以作为参数传递给函数 可以作为函数的结果返回 可以包含在数据结构中 Python授予函数完全的一等地位，由此带来的表达能力的提升是巨大的。 1.6.9 函数装饰器Python提供了一种特殊的语法来使用高阶函数作为执行def语句地一部分，称为装饰器(decorator)。最常见的例子也许就是trace 123456789101112def trace(fn): def wrapped(x): print(&#x27;-&gt;&#x27;, fn, &#x27;(&#x27;, x, &#x27;)&#x27;) return fn(x) return wrapped&gt;&gt;&gt; @trace def triple(x): return 3 * x &gt;&gt;&gt; triple(12)-&gt; &lt;function triple at ... &gt;(12)36 triple的def语句有一个注释(annotation)@trace，它会影响def执行的规则。和往常一样，函数triple被创建了。但是名称triple不会绑定到这个函数上，相反，这个名称会被绑定到在新定义的triple函数调用trace后返回的函数值上。代码中，这个装饰器等价于 123&gt;&gt;&gt; def triple(x): return 3 * x&gt;&gt;&gt; triple = trace(triple) 在本教材相关的项目中，装饰器被用于追踪，以及在从命令行运行程序时选择要调用哪些函数。 对于专家的额外内容：装饰器符号@也可以后跟一个调用表达式。跟在@后面的表达式会先被解析，然后是def语句，最后将装饰器表达式的运算结果应用到新定义的函数上，并将结果绑定到def语句中的名称上","categories":[{"name":"CS61A","slug":"CS61A","permalink":"https://primeluoqiu.github.io/categories/CS61A/"}],"tags":[],"keywords":[{"name":"CS61A","slug":"CS61A","permalink":"https://primeluoqiu.github.io/categories/CS61A/"}]},{"title":"3.1-3 概述和传输层服务、多路复用和解复用、无连接传输UDP","slug":"计算机网络/3.1-3","date":"2024-04-08T12:35:27.048Z","updated":"2024-04-08T12:37:36.010Z","comments":true,"path":"2024/04/08/计算机网络/3.1-3/","link":"","permalink":"https://primeluoqiu.github.io/2024/04/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.1-3/","excerpt":"","text":"","categories":[{"name":"计网","slug":"计网","permalink":"https://primeluoqiu.github.io/categories/%E8%AE%A1%E7%BD%91/"}],"tags":[],"keywords":[{"name":"计网","slug":"计网","permalink":"https://primeluoqiu.github.io/categories/%E8%AE%A1%E7%BD%91/"}]},{"title":"第五周总结 + 第六周学习计划","slug":"每周学习计划/Week6","date":"2024-04-07T13:38:15.326Z","updated":"2024-04-07T13:41:49.446Z","comments":true,"path":"2024/04/07/每周学习计划/Week6/","link":"","permalink":"https://primeluoqiu.github.io/2024/04/07/%E6%AF%8F%E5%91%A8%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/Week6/","excerpt":"","text":"第五周总结其实本周内容还是把最最主要的计网完成了，不过看起来计网后面的题目相对来说还是比较难的。得认真地的看一下对应的题目。然后就是准备蓝桥杯和复习来着，蓝桥杯好像是下周六，本周还是以计网和蓝桥杯为主吧，其余的话看情况学，底层还是要继续的 计划1.计网看完第三章节，然后复习一下之前的两章2.蓝桥杯复习3.CS系列课程，记得更新就好4.看点面向对象的语言","categories":[{"name":"大二下","slug":"大二下","permalink":"https://primeluoqiu.github.io/categories/%E5%A4%A7%E4%BA%8C%E4%B8%8B/"}],"tags":[],"keywords":[{"name":"大二下","slug":"大二下","permalink":"https://primeluoqiu.github.io/categories/%E5%A4%A7%E4%BA%8C%E4%B8%8B/"}]},{"title":"2.9 UDP套接字编程 + 本章小节","slug":"计算机网络/2.9","date":"2024-04-07T03:50:18.322Z","updated":"2024-04-07T03:50:54.070Z","comments":true,"path":"2024/04/07/计算机网络/2.9/","link":"","permalink":"https://primeluoqiu.github.io/2024/04/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.9/","excerpt":"","text":"","categories":[{"name":"计网","slug":"计网","permalink":"https://primeluoqiu.github.io/categories/%E8%AE%A1%E7%BD%91/"}],"tags":[],"keywords":[{"name":"计网","slug":"计网","permalink":"https://primeluoqiu.github.io/categories/%E8%AE%A1%E7%BD%91/"}]},{"title":"2.8 TCP套接字编程","slug":"计算机网络/2.8","date":"2024-04-06T13:57:31.127Z","updated":"2024-04-06T13:59:01.246Z","comments":true,"path":"2024/04/06/计算机网络/2.8/","link":"","permalink":"https://primeluoqiu.github.io/2024/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.8/","excerpt":"","text":"","categories":[{"name":"计网","slug":"计网","permalink":"https://primeluoqiu.github.io/categories/%E8%AE%A1%E7%BD%91/"}],"tags":[],"keywords":[{"name":"计网","slug":"计网","permalink":"https://primeluoqiu.github.io/categories/%E8%AE%A1%E7%BD%91/"}]},{"title":"","slug":"Algorithm/搜索与图论/第一章","date":"2024-04-06T13:55:22.142Z","updated":"2024-04-06T13:54:09.345Z","comments":true,"path":"2024/04/06/Algorithm/搜索与图论/第一章/","link":"","permalink":"https://primeluoqiu.github.io/2024/04/06/Algorithm/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/%E7%AC%AC%E4%B8%80%E7%AB%A0/","excerpt":"","text":"深度优先搜索(DFS)很执着，尽可能的往深搜。当搜不到的时候回溯，然后回溯完之后看看，当前是不是所有的路径都遍历过了。 对于数据结构来讲：使用的是栈 空间：O(n) 不具有最短性 第一次搜索完之后不一定具备最短性 存在两个概念 概念1：回溯概念2：剪枝DFS最重要的是顺序，要考虑是用一个什么样的顺序来比遍历整个方案。想不清楚的话画棵树考虑一下。 对于本题而言，顺序有很多种，这里的搜索顺序是假设我们已经有n个空位了，从第一位开始填，从前往后填，每次填的时候数字不能和前面一样就可以了。最开始状态是n个空，第一位有三种填法，分别对应三个不同的分支。深搜的话会继续往下搜，也就是搜第二个位置，第二个位置也有三种方案。但是深搜的时候不会把方案先画出来，直接走到黑。第二位枚举一下，第一位确定了是1，那第二位肯定不能是1，因为重复了，第二位只能先填2，优先往下走，就只剩第三位，那么第三位就只剩下3了，这个时候分支对应的就是123，已经无路可走，然后回退一步。回到填写第二位的时候，发现第二位还有一条路可以走，还可以填3，那么就填上3，就是有3的分支，那么132，再回溯，无路可走，在回溯，回到根节点，这个时候就要枚举2这个分支。 求全排列的过程，是可以用DFS来做的。搜索顺序可以看成一棵树。当然只是看成一棵树，每次存的时候存储的都是路径，回溯的时候就没了，不需要存数和栈。在回溯的时候一定要记得回复现场。下去的时候是什么样子，回溯回来的话还得是那个样子。走的时候分支看到的状态是一样的。 看一下代码怎么写： ++12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;using namespace std;const int N = 10;int n;int path[N]; //状态用一个全局数组来存,存储的是方案 bool st[N]; //true表示点被用过了void dfs(int u)&#123; if (u == n) &#123; //当完美走到n,说明全部填满了 for(int i = 0; i &lt; n;i ++) cout &lt;&lt; path[i] &lt;&lt; &#x27; &#x27;; puts(&quot;&quot;); &#125; for(int i = 1; i &lt;= n; i ++) &#123; if(!st[i]) &#123; path[u] = i; //i放到当前位置上 st[i] = true; //记录i已经被用过了 dfs(u + 1); //状态处理好之后递归到下一层 st[i] = false; //恢复现场 path不需要回复，会覆盖，递归函数结束之后一定要记得恢复。 &#125; &#125;&#125;int main()&#123; cin &gt;&gt; n; dfs(0); return 0;&#125; 还有一个经典的N皇后问题，有很多种搜索方式 ​ 在n*n的棋盘上放n个皇后，皇后可以横竖斜着走，让任何两个皇后不能互相攻击到，给定一个n，输出所有的方案 比如说：搜索全排列的思路是一样的，搜索顺序是：先看一下同一行同一列只放一个皇后，先看第一行皇后可以放在那一列。枚举每一行皇后可以放到哪里去。从第一位开始枚举。递归枚举第二行皇后放到那…这里要注意剪枝。这是按照全排列的方法来枚举。 也可以先生成一个全排列，然后再判断。也是可以的。 蛋柿呢，也可以边做边判断，假设枚举了一个4，直接判断有没有冲突，如果有冲突，就不用再往下走，直接停止了。可以看作是把枝剪掉，直接回溯，这就是剪枝了。 那么这种方法对应的解决方案是 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;using namespace std;const int N = 20;bool col[N], dg[N], udg[N];char g[N][N];int n;void dfs(int u)&#123; if(u == n) &#123; for(int i = 0; i &lt; n; i ++) puts(g[i]); puts(&quot;&quot;); return; &#125; for(int i = 0; i &lt; n;i ++) &#123; if(!col[i] &amp;&amp; !dg[u + i] &amp;&amp; !udg[n - u + i]) &#123; g[u][i] = &#x27;Q&#x27;; col[i] = dg[u + i] = udg[n - u + i] = true; dfs(u + 1); col[i] = dg[u + i] = udg[n - u + i] = false; g[u][i] = &#x27;.&#x27;; &#125; &#125;&#125;int main()&#123; cin &gt;&gt; n; for(int i = 0; i &lt; n; i ++) for(int j = 0; j &lt; n; j ++) g[i][j] = &#x27;.&#x27;; dfs(0); return 0;&#125; 没有模板，只有顺序和思路。 除了这种方式之外，我们还可以用一种更原始的方式来解决这种问题。也就是说，对于每个点而言，都有两种状态，分别是放或者不放这两种分支，然后我们挨个枚举所有格子，当枚举到n²格子的时候，就结束了。这个更加原始，更加接近题目的选项的方式 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;using namespace std;const int N = 20;bool row[N], col[N], dg[N], udg[N];char g[N][N];int n;void dfs(int x, int y, int s)&#123; if(y == n) y = 0, x ++; if(x == n) &#123; if(s == n) &#123; for(int i = 0;i &lt; n; i ++) puts(g[i]); puts(&quot;&quot;); &#125; return; &#125; //不放皇后 dfs(x, y + 1, s); //放皇后 if(!row[x] &amp;&amp; !col[y] &amp;&amp; !dg[x + y] &amp;&amp; !udg[x - y + n]) &#123; g[x][y] = &#x27;Q&#x27;; row[x] = col[y] = dg[x + y] = udg[x - y + n] = true; dfs(x, y + 1, s + 1); row[x] = col[y] = dg[x + y] = udg[x - y + n] = false; g[x][y] = &#x27;.&#x27;; &#125;&#125;int main()&#123; cin &gt;&gt; n; for(int i = 0; i &lt; n; i ++) for(int j = 0; j &lt; n; j ++) g[i][j] = &#x27;.&#x27;; dfs(0, 0, 0); return 0;&#125; 宽度优先搜索(BFS)按层搜索。同时看很多条路，第一次看第一层，第二次看第二层。第二层搜完之后再搜第三层。每次只扩展一层。 数据结构：队列 空间：O(n^2) 有最短路的概念，第一次扩展到的点，一定是离他最近的点 为什么可以呢？是一圈一圈往外扩展，可以搜到的点是离起点越来越远的。第一次搜到的一定是距离最小的。前提是图里的边权重必须都得是1. 树与图的存储树与图的深度优先遍历树与图的宽度优先遍历拓扑排序","categories":[],"tags":[],"keywords":[]},{"title":"Ts快速入门","slug":"HarmonyOsDeveloper/Ts快速入门","date":"2024-04-05T16:37:05.386Z","updated":"2024-04-05T16:42:07.571Z","comments":true,"path":"2024/04/06/HarmonyOsDeveloper/Ts快速入门/","link":"","permalink":"https://primeluoqiu.github.io/2024/04/06/HarmonyOsDeveloper/Ts%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/","excerpt":"","text":"基础类型赋值语句:let 变量名: 变量类型 = 值 变量类型还是布尔值、数字、字符串(单引号双引号都可以)、数组、元组、枚举、Unknown、Void和Undefined以及联合类型 数字： 所有数字全部都是浮点数，类型是number。支持标准进制 1let decLiteral: number = 2023; 两种定义方式: 元素后+[]，表示由此类型元素组成的一个数组 1let list: number[] = [1, 2, 3]; 第二种:使用数组泛型，Array&lt;元素类型&gt; 1let list: Array&lt;number&gt; = [1, 2, 3]; 元组：元组类型允许表示一个已知元素数量和类型的数组。各元素的类型不必相同。比如，可以定义一对值分别为string和number类型的元组，顺序不可相反 12let x: [string, number];x = [&#x27;hello&#x27;, 10]; 枚举： enum类型是对js标准数据类型的一个补充，使用枚举类型可以为一组数值赋予友好的名字 12enum Color &#123;Red, Green, Blue&#125;;let c: Color = Color.Green; Unknow:为编程阶段还尚不清楚类型的变量指定一个类型。在这种情况下，不希望类型检查器对这些值进行检查而实直接通过编译阶段的检查。便可以使用Unknown Void还是出现在函数返回值类型。 在ts中，undefined和null各自有自己的类型分别叫做undefined和null 联合类型(Union Type): 取值可以为多种类型中的一种 123let myFavouriteNumver: string | number;myFavouriteNumber = &#x27;seven&#x27;;myFavouriteNumber = 7; 条件语句通过一条或者多条的执行结果来决定执行的代码块 if语句1234var num: number = 5if (num &gt; 0) &#123; console.log(&#x27;数字是正数&#x27;)&#125; 其他的和C语言类似 switch…case语句12345678910111213141516171819var grade: string = &#x27;A&#x27;switch(grade) &#123; case &#x27;A&#x27;: &#123; console.log(&#x27;优秀&#x27;); break; &#125; case &#x27;B&#x27;: &#123; console.log(&#x27;良&#x27;); break; &#125; case &#x27;C&#x27;: &#123; console.log(&#x27;及格&#x27;); break; &#125; default: &#123; console.log(&#x27;非法输入&#x27;); break; &#125;&#125; 函数是一组一起执行一个任务的语句，函数声明要告诉编译器函数的名称、返回类型和参数。Ts可以创建有名的函数和匿名函数，创建方法如下 123456789//有名函数function add(x, y) &#123; return x + y;&#125;//匿名函数let myAdd = function(x, y) &#123; return x + y;&#125;; 为函数定义类型为了确保输入输出的准确性，我们可以为函数添加类型: 123456789// 有名函数: 给变量设置为number类型function add(x: number, y: number): number &#123; return x + y;&#125;// 匿名函数: 给变量设置为number类型let myAdd = function(x: number, y: number): number &#123; return x + y;&#125; 可选参数在Ts里可以在参数名旁边使用?实现可选参数的功能。比如，我们想让lastName是可选的: 123456789function buildName(firstName: string, lastName?: string) &#123; if(lastName) return firstName + &#x27; &#x27; + lastName; else return firstName;&#125;let result = buildName(&#x27;Bob&#x27;);let result2 = buildName(&#x27;Bob&#x27;, &#x27;Adams&#x27;); 剩余参数剩余参数会被当做个数不限的可选参数，可以一个都没有，同样也可以有任意个。可以使用省略号(…)进行定义: 12345function getEmployeeName(firstName: string, ...restOfName: string[]) &#123; return firstName + &#x27; &#x27; + restOfName.join(&#x27; &#x27;);&#125;let employeeName = getEmployeeName(&#x27;Joseph&#x27;, &#x27;Samuel&#x27;, &#x27;Luces&#x27;, &#x27;MacKinzie&#x27;); 箭头函数es6版本的ts提供了一个箭头函数，它是定义匿名函数的简写语法，用于函数表达式，省略了function关键字。箭头函数的定义如下，其函数是一个语句块: 123( [param1, param2, ... param n] ) =&gt; &#123; //代码块&#125; 其中，括号内是函数的入参，可以有0到多个参数，箭头后是函数的代码块。我们可以将这个箭头函数赋值给一个变量，如下所示 123let arrowFun = ( [param1, param2, ... param n] ) =&gt; &#123; //代码块&#125; 如何要主动调用这个箭头函数，可以按如下方法调用: 1arrowFun(param1, param2, ... param n) 那么如何将熟悉的函数定义方式转换成箭头函数 1234567function testNumber(num: number) &#123; &#125;let testArrowFun = (num: number) =&gt; &#123; //函数体内容一致&#125; 后面在开发HarmonyOS时会经常用到箭头函数。例如，给一个按钮添加点击事件，其中onClick事件中的函数就是箭头函数 1234Button(&quot;Click Now&quot;) .onClick(() =&gt; &#123; console.info(&quot;Button is click&quot;)&#125;) 类Ts支持基于类的面向对象的编程方式，定义类的关键字为class，后面紧跟类名。类描述了所创建的对象共同的属性和方法。 类的定义例如，我们可以声明一个Person类，这个类有三个成员：一个是属性(包含name和age)，一个是构造函数，一个是getPersonInfo方法，其定义如下所示 12345678910111213class Person &#123; private name: string private age: number constructor(name: string, age: number) &#123; this.name = name; this.age = age; &#125; public getPersonInfo(): string &#123; return &#x27;My name is $&#123;this.name&#125; and age is $&#123;this.age&#125;&#x27;; &#125;&#125; 继承继承就是子类继承父类的特征和行为，使得子类具有父亲相同的行为。Ts中允许使用继承来扩展现有的类，对应的关键字为extend。 123456789101112class Employee extends Person &#123; private department: string constructor(name: string, age: number, department: string) &#123; super(name, age); this.department = department; &#125; public getEmployeeInfo(): string &#123; return this.getPersonInfo() + `and work in $&#123;this.department&#125;` &#125;&#125; 通过上面的Employee类，可以定义一个人物并获取他的基本信息，具体使用场景参考相关学习资料。 模块随着应用越来越大，通常要将代码拆分成多个文件，即所谓的模块（module）。模块可以相互加载，并可以使用特殊的指令 export 和 import 来交换功能，从另一个模块调用一个模块的函数。 两个模块之间的关系是通过在文件级别上使用 import 和 export 建立的。模块里面的变量、函数和类等在模块外部是不可见的，除非明确地使用 export 导出它们。类似地，我们必须通过 import 导入其他模块导出的变量、函数、类等。 导出任何声明(比如变量、函数、类、类型别名和接口)都能通过添加export关键字来导出，例如要导出一个类 123export class NewsData &#123; &#125; 导入1import &#123;NewsData&#125; from &#x27;../common/bean/NewsData&#x27;; 迭代器当一个对象实现了Symbol.iterator属性时，我们认为它是可迭代的。一些内置的类型如Array，Map，Set，String，Int32Array，Uint32Array等都具有可迭代性。 for…of语句for..of会遍历可迭代的对象，调用对象上的Symbol.iterator方法。下面是在数组上使用for..of的简单例子: 12345let someArray = [1, &quot;string&quot;, false]for (let entry of someArray) &#123; console.log(entry); // 1, &quot;string&quot;, false&#125; for…in语句上述两种方式均可迭代一个列表，但是用于迭代的值却不同:for…in迭代的是对象的键，而for..of则迭代的是对象的值 123456789let list = [4, 5, 6];for(let i in list) &#123; console.log(i) // &quot;0&quot;, &quot;1&quot;, &quot;2&quot;&#125;for(let in of list) &#123; console.log(i); //&quot;4&quot;, &quot;5&quot;, &quot;6&quot;&#125; TypeScript是一个开源的编程语言，本章节只有TypeScript的基础语法知识，更多内容参考TypeScript的官方教程（https://www.typescriptlang.org/docs/）。","categories":[{"name":"OpenHarmonyDeveloper","slug":"OpenHarmonyDeveloper","permalink":"https://primeluoqiu.github.io/categories/OpenHarmonyDeveloper/"}],"tags":[],"keywords":[{"name":"OpenHarmonyDeveloper","slug":"OpenHarmonyDeveloper","permalink":"https://primeluoqiu.github.io/categories/OpenHarmonyDeveloper/"}]},{"title":"2.7 CDN(内容分发网络)","slug":"计算机网络/2.7","date":"2024-04-05T06:31:06.791Z","updated":"2024-04-05T06:33:13.372Z","comments":true,"path":"2024/04/05/计算机网络/2.7/","link":"","permalink":"https://primeluoqiu.github.io/2024/04/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.7/","excerpt":"","text":"","categories":[{"name":"计网","slug":"计网","permalink":"https://primeluoqiu.github.io/categories/%E8%AE%A1%E7%BD%91/"}],"tags":[],"keywords":[{"name":"计网","slug":"计网","permalink":"https://primeluoqiu.github.io/categories/%E8%AE%A1%E7%BD%91/"}]},{"title":"2.6 P2P","slug":"计算机网络/2.6","date":"2024-04-04T15:29:50.750Z","updated":"2024-04-04T15:30:55.076Z","comments":true,"path":"2024/04/04/计算机网络/2.6/","link":"","permalink":"https://primeluoqiu.github.io/2024/04/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.6/","excerpt":"","text":"","categories":[{"name":"计网","slug":"计网","permalink":"https://primeluoqiu.github.io/categories/%E8%AE%A1%E7%BD%91/"}],"tags":[],"keywords":[{"name":"计网","slug":"计网","permalink":"https://primeluoqiu.github.io/categories/%E8%AE%A1%E7%BD%91/"}]},{"title":"2.5 DNS","slug":"计算机网络/2.5","date":"2024-04-03T14:32:46.454Z","updated":"2024-04-03T14:42:13.470Z","comments":true,"path":"2024/04/03/计算机网络/2.5/","link":"","permalink":"https://primeluoqiu.github.io/2024/04/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.5/","excerpt":"","text":"","categories":[{"name":"计网","slug":"计网","permalink":"https://primeluoqiu.github.io/categories/%E8%AE%A1%E7%BD%91/"}],"tags":[],"keywords":[{"name":"计网","slug":"计网","permalink":"https://primeluoqiu.github.io/categories/%E8%AE%A1%E7%BD%91/"}]},{"title":"","slug":"Algorithm/数据结构(三)","date":"2024-04-02T14:10:44.252Z","updated":"2024-04-02T14:11:48.550Z","comments":true,"path":"2024/04/02/Algorithm/数据结构(三)/","link":"","permalink":"https://primeluoqiu.github.io/2024/04/02/Algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(%E4%B8%89)/","excerpt":"","text":"title: 哈希表和STL categories: Algorithm 哈希表哈希表实际上就是把一个很大范围的数据结构映射成为一个很小的数据范围的东西。举例来说，比如说想把从0-10的9次方这些数映射到从0到10的五次方左右的一些数。 比如现在有一批数的范围是-10九次方到+10的九次方，然后通过一个哈希函数把它们放进一个很小的(10的五次方)的范围之内。 哈希函数的一些问题，例如： 哈希函数一般怎么写：就是直接模一个数，例如可以直接模10^5。 冲突定义域比较大，映射的结果比较小，那么必然会产生冲突，把两个不一样的数映射到同一个数。按照处理冲突的方式分为开放寻址法和拉链法。 存储结构开放寻址法通俗来讲的话，也叫蹲坑法，什么意思呢，就是说，我们只需要一个数组就可以了，但是这个数组的大小一般要开到题目范围的2-3倍，然后就像大家上厕所一样，当一个坑位被占了的时候，只能去找下一个坑位，然后下一个坑位被占了再找下一个，也就意味着说，我们先通过函数来寻找到k，但是如果那个k被占用了的话，那么就去k+1，如果k+1被占用了，就去k+2… 然后这个方法主要就是find函数的实现，然后插入的话，就是通过find找到对应的位置，然后把x放进去就可以了，而查找的话就是如果对应的位置不是空的，那么就是有的，不然就是没有。删除其实也可以看做另外一种形式的查找，因为并不是真正的删除，而是对那个点做一个标记 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int N = 2e6 + 3, null = 0x3f3f3f3f;int h[N];int find(int x)&#123; int k = (x % N + N) % N; while(h[k] != null &amp;&amp; h[k] != x) &#123; k ++; if(k == N) k = 0; &#125; return k;&#125;int main()&#123; int n; memset(h, 0x3f, sizeof(h)); cin &gt;&gt; n; while(n --) &#123; char op[2]; int x; scanf(&quot;%s%d&quot;, op, &amp;x); int k = find(x); if(op[0] == &#x27;I&#x27;) h[k] = x; else &#123; if(h[k] != null) puts(&quot;Yes&quot;); else puts(&quot;No&quot;); &#125; &#125; return 0;&#125; 拉链法简单来讲，就是说，先开出来一个空间，然后例如我们把h(11)映射到了3，h(23)也映射到了3，这个时候，我们就在3的下面拉一个线，类似拉链一样。多一个点就多一个线。然后一般哈希表只会存在两种操作，分别是添加和查找，添加很简单，只需要通过对应的哈希函数找到它的位置，然后添加一条拉链就可以了，查找的话，就是先看出来这个数值哈希完之后是什么，如果是某个点，然后顺着那个点去查找是不是有那个值。一般不会有删除操作的，就算有，也不是真的把那个数值删了，而是给那个点打个标记，例如布尔变量，然后就删除掉了。 这里要注意一个点，我们的哈希函数模的那个值最好是一个质数，而且距离2的多少次方比较远，这样能够保证冲突的概率是最小的。 接下来，看一下我们拉链法的模板 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int N = 1e6 + 3;int h[N], e[N], ne[N], idx;void insert(int x)&#123; int k = (x % N + N) % N; e[idx] = x; ne[idx] = h[k]; h[k] = idx ++;&#125;bool find(int x)&#123; int k = (x % N + N) % N; for(int i = h[k]; i != -1; i = ne[i]) &#123; if(e[i] == x) return true; &#125; return false;&#125;int main()&#123; int n; scanf(&quot;%d&quot;, &amp;n); memset(h, -1, sizeof(h)); while(n --) &#123; char op[2]; int x; scanf(&quot;%s%d&quot;, op, &amp;x); if(op[0] == &#x27;I&#x27;) insert(x); else &#123; if(find(x)) puts(&quot;Yes&quot;); else puts(&quot;No&quot;); &#125; &#125; return 0;&#125; 字符串哈希方式一种特殊的方式：字符串前缀哈希法。 求哈希之前，先预处理出来所有前缀的哈希。 那么如何处理出来所有前缀的哈希呢？ 我们可以把每个字符串看成是一个P进制的数，例如”ABCD”是一个p进制的数，然后我们将它转化成为一个十进制的数，那么”ABCD”如果分别代表第一位第二位第三位和第四位的话，那么它可以转化成$$1p^3+2p^2+3p^1+4p^0$$那么当这个字符串比较长的时候，这个数值就会变得很大，那么我们不妨给它模一个Q让他变小，然后我们就把范围缩小到了0-Q-1 不过有两个值得注意的点 首先是任何一个字母都不能映射成0，毕竟0在任何进制上转换成十进制的时候都是0。 这个是建立在我们rp(人品)足够好的前提下，也就是说不存在冲突的情况。 不过这倒是有个经验值可以保证在99.99%的前提下不会出现冲突，就是指当p &#x3D; 131&#x2F;13331，且Q &#x3D; 2^64的时候，就可以了 这么处理的好处是什么呢？ 就是说我们可以通过一个公式来计算出所有子串的哈希值。 那么，具体是什么公式呢？ 就是说，有一个线段，例如从L-R，那么我们把从1-L这一段让它和L-R这一段对齐，那么用这两段相减就可以了。那么最后的公式就是 h[R] - h[L] * p ^ (R - L + 1) Q是等于2^64,如果我们这个时候开一个unsigned long long的话，那么只要溢出的话就相当于是自动模上2^64了 预处理的话就是 h(i) = h(i - 1) * p + str[i] 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;using namespace std;typedef unsigned long long ULL;const int N = 1e6 + 10, P = 131;int n, m;char str[N];ULL h[N], p[N]; //p[N]用来存储公式中的L-R+1ULL get(int l, int r)&#123; return h[r] - h[l - 1] * p[r - l + 1];&#125;int main()&#123; scanf(&quot;%d%d%s&quot;, &amp;n, &amp;m, str + 1); p[0] = 1; for(int i = 1; i &lt;= n; i ++) &#123; p[i] = p[i - 1] * P; h[i] = h[i - 1] * P + str[i]; &#125; while (m --) &#123; int l1, r1, l2, r2; scanf(&quot;%d%d%d%d&quot;, &amp;l1, &amp;r1, &amp;l2, &amp;r2); if(get(l1, r1) == get(l2, r2)) puts(&quot;Yes&quot;); else puts(&quot;No&quot;); &#125; return 0;&#125; STLvector实际上就是一个变长数组，倍增的思想。 有这样的一些函数 size()返回元素个数 empty()返回是否为空 clean()清空这个vector front()/ back()最前面的和最后面的 push_back() / pop_back()在最后插入和把最后一个删掉 begin() / end()第0个和最后一个的后一个，也就是迭代器。 string字符串，一些常用的函数例如substr()、c_str() queue, priority_queue队列,push(), pop() ,front() stack栈,push(), pop(), front() deque双端队列，也就是在队列的基础上让队列的头和尾都可以插入和删除 set, map, multiset, multimap基于平衡二叉树(红黑树)，动态维护有序序列 unordered_map, unordered_set, unordered_multiset, unordered_multimap哈希表 bitset压位","categories":[],"tags":[],"keywords":[]},{"title":"2.3 & 2.4 FTP & Email","slug":"计算机网络/2.3.4","date":"2024-04-02T11:50:04.609Z","updated":"2024-04-02T11:51:37.209Z","comments":true,"path":"2024/04/02/计算机网络/2.3.4/","link":"","permalink":"https://primeluoqiu.github.io/2024/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.3.4/","excerpt":"","text":"","categories":[{"name":"计网","slug":"计网","permalink":"https://primeluoqiu.github.io/categories/%E8%AE%A1%E7%BD%91/"}],"tags":[],"keywords":[{"name":"计网","slug":"计网","permalink":"https://primeluoqiu.github.io/categories/%E8%AE%A1%E7%BD%91/"}]},{"title":"Week5 and Daily Schedule","slug":"每周学习计划/Week5","date":"2024-04-01T13:54:40.572Z","updated":"2024-04-07T13:41:25.771Z","comments":true,"path":"2024/04/01/每周学习计划/Week5/","link":"","permalink":"https://primeluoqiu.github.io/2024/04/01/%E6%AF%8F%E5%91%A8%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/Week5/","excerpt":"","text":"Daily ScheduleTotal Schedule 《计算机网络》-郑铨老师的 2.3-2.10(第二章看完) CS61A 看完第一章 每天更新一点算法内容 每天任务的话，先看周一吧，周一相对来说课不算多，下午有一节毛概，毛概课的话得补半节课的数电笔记和作业","categories":[{"name":"大二下","slug":"大二下","permalink":"https://primeluoqiu.github.io/categories/%E5%A4%A7%E4%BA%8C%E4%B8%8B/"}],"tags":[],"keywords":[{"name":"大二下","slug":"大二下","permalink":"https://primeluoqiu.github.io/categories/%E5%A4%A7%E4%BA%8C%E4%B8%8B/"}]},{"title":"Week4 总结","slug":"每周学习计划/Week4总结","date":"2024-04-01T13:51:52.141Z","updated":"2024-04-01T13:54:24.593Z","comments":true,"path":"2024/04/01/每周学习计划/Week4总结/","link":"","permalink":"https://primeluoqiu.github.io/2024/04/01/%E6%AF%8F%E5%91%A8%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/Week4%E6%80%BB%E7%BB%93/","excerpt":"","text":"本周内容学习的不多，不过计网内容算是比较完美的达成了，就是昨天身体不大舒服，不然熬一下基本上任务就完成了。这种每周都有任务的感觉还是蛮爽的。然后其实还是很喜欢这种每天都有一定的任务量的感觉，这样的话完成之后内心也会收获一份成就感。 CS61A的进度不算很快，也不知道是不是学习方法的问题，现在进展速度奇慢，61B也没来得及看，更别提61C和CSAPP了，下周还有蓝桥杯要准备。加油吧，还要再重温一下算法的相关知识。","categories":[{"name":"大二下","slug":"大二下","permalink":"https://primeluoqiu.github.io/categories/%E5%A4%A7%E4%BA%8C%E4%B8%8B/"}],"tags":[],"keywords":[{"name":"大二下","slug":"大二下","permalink":"https://primeluoqiu.github.io/categories/%E5%A4%A7%E4%BA%8C%E4%B8%8B/"}]},{"title":"哈希表","slug":"Algorithm/hashtable","date":"2024-04-01T13:51:04.389Z","updated":"2024-04-01T13:51:37.676Z","comments":true,"path":"2024/04/01/Algorithm/hashtable/","link":"","permalink":"https://primeluoqiu.github.io/2024/04/01/Algorithm/hashtable/","excerpt":"","text":"模拟堆接下来看模拟堆，模拟堆比起之前就是多了两个数组，这两个数组属于互为反函数的类型。例如 hp[k] = j那么ph[j] = k，一个是对应着在堆里的下标，另一个对应的是下标对应的值。 那么对应的，在进行交换的时候，就不能只考虑值之间的交换了，就还得考虑数组之间的交换。这个时候，就需要一个全新的函数了 因为题目中要考虑第k个数，那么就需要两个数组来存储第k个数是什么ph[k]存的是第k个插入的数在堆里的下标是什么,还需要一个hp[k],用来存的是堆的某个点是第几个插入的点。 123456void swap_head(int a, int b) &#123; swap(ph[hp[a]], ph[hp[b]]); swap(hp[a], hp[b]); swap(a, b); &#125; 然后就是把所有的swap函数进行更换为堆里面特有的swap。这个方法不常用，但是djikstra堆优化是常用的，所以要了解一下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string.h&gt;using namespace std;const int N = 100010;int n, m, a, b;int h[N], cnt, ph[N], hp[N];void heap_swap(int a, int b)&#123; swap(ph[hp[a]], ph[hp[b]]); swap(hp[a], hp[b]); swap(h[a], h[b]);&#125;void down(int u)&#123; int t = u; if(u * 2 &lt;= cnt &amp;&amp; h[u * 2] &lt; h[t]) t = u * 2; if(u * 2 + 1 &lt;= cnt &amp;&amp; h[u * 2 + 1] &lt; h[t]) t = u * 2 + 1; if(u != t) &#123; heap_swap(u, t); down(t); &#125;&#125;void up(int u)&#123; while(u / 2 &amp;&amp; h[u / 2] &gt; h[u]) &#123; heap_swap(u, u / 2); u &gt;&gt;= 1; &#125;&#125;int main()&#123; int n, m = 0; cin &gt;&gt; n; while(n --) &#123; char op[10]; int k, x; scanf(&quot;%s&quot;, op); if(!strcmp(op, &quot;I&quot;)) &#123; scanf(&quot;%d&quot;, &amp;x); cnt ++; m ++; ph[m] = cnt, hp[cnt] = m; h[cnt] = x; up(cnt); &#125; else if(!strcmp(op, &quot;PM&quot;)) printf(&quot;%d\\n&quot;, h[1]); else if(!strcmp(op, &quot;DM&quot;)) &#123; heap_swap(1, cnt); cnt --; down(1); &#125; else if(!strcmp(op, &quot;D&quot;)) &#123; scanf(&quot;%d&quot;, &amp;k); k = ph[k]; heap_swap(k, cnt); cnt --; down(k), up(k); &#125; else &#123; scanf(&quot;%d%d&quot;, &amp;k, &amp;x); k = ph[k], h[k] = x; down(k), up(k); &#125; &#125; return 0;&#125; 哈希表哈希表实际上就是把一个很大范围的数据结构映射成为一个很小的数据范围的东西。举例来说，比如说想把从0-10的9次方这些数映射到从0到10的五次方左右的一些数。 比如现在有一批数的范围是-10九次方到+10的九次方，然后通过一个哈希函数把它们放进一个很小的(10的五次方)的范围之内。 哈希函数的一些问题，例如： 哈希函数一般怎么写：就是直接模一个数，例如可以直接模10^5。 冲突定义域比较大，映射的结果比较小，那么必然会产生冲突，把两个不一样的数映射到同一个数。按照处理冲突的方式分为开放寻址法和拉链法。 存储结构开放寻址法通俗来讲的话，也叫蹲坑法，什么意思呢，就是说，我们只需要一个数组就可以了，但是这个数组的大小一般要开到题目范围的2-3倍，然后就像大家上厕所一样，当一个坑位被占了的时候，只能去找下一个坑位，然后下一个坑位被占了再找下一个，也就意味着说，我们先通过函数来寻找到k，但是如果那个k被占用了的话，那么就去k+1，如果k+1被占用了，就去k+2… 然后这个方法主要就是find函数的实现，然后插入的话，就是通过find找到对应的位置，然后把x放进去就可以了，而查找的话就是如果对应的位置不是空的，那么就是有的，不然就是没有。删除其实也可以看做另外一种形式的查找，因为并不是真正的删除，而是对那个点做一个标记 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int N = 2e6 + 3, null = 0x3f3f3f3f;int h[N];int find(int x)&#123; int k = (x % N + N) % N; while(h[k] != null &amp;&amp; h[k] != x) &#123; k ++; if(k == N) k = 0; &#125; return k;&#125;int main()&#123; int n; memset(h, 0x3f, sizeof(h)); cin &gt;&gt; n; while(n --) &#123; char op[2]; int x; scanf(&quot;%s%d&quot;, op, &amp;x); int k = find(x); if(op[0] == &#x27;I&#x27;) h[k] = x; else &#123; if(h[k] != null) puts(&quot;Yes&quot;); else puts(&quot;No&quot;); &#125; &#125; return 0;&#125; 拉链法简单来讲，就是说，先开出来一个空间，然后例如我们把h(11)映射到了3，h(23)也映射到了3，这个时候，我们就在3的下面拉一个线，类似拉链一样。多一个点就多一个线。然后一般哈希表只会存在两种操作，分别是添加和查找，添加很简单，只需要通过对应的哈希函数找到它的位置，然后添加一条拉链就可以了，查找的话，就是先看出来这个数值哈希完之后是什么，如果是某个点，然后顺着那个点去查找是不是有那个值。一般不会有删除操作的，就算有，也不是真的把那个数值删了，而是给那个点打个标记，例如布尔变量，然后就删除掉了。 这里要注意一个点，我们的哈希函数模的那个值最好是一个质数，而且距离2的多少次方比较远，这样能够保证冲突的概率是最小的。 接下来，看一下我们拉链法的模板 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int N = 1e6 + 3;int h[N], e[N], ne[N], idx;void insert(int x)&#123; int k = (x % N + N) % N; e[idx] = x; ne[idx] = h[k]; h[k] = idx ++;&#125;bool find(int x)&#123; int k = (x % N + N) % N; for(int i = h[k]; i != -1; i = ne[i]) &#123; if(e[i] == x) return true; &#125; return false;&#125;int main()&#123; int n; scanf(&quot;%d&quot;, &amp;n); memset(h, -1, sizeof(h)); while(n --) &#123; char op[2]; int x; scanf(&quot;%s%d&quot;, op, &amp;x); if(op[0] == &#x27;I&#x27;) insert(x); else &#123; if(find(x)) puts(&quot;Yes&quot;); else puts(&quot;No&quot;); &#125; &#125; return 0;&#125; 字符串哈希方式","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://primeluoqiu.github.io/categories/Algorithm/"}],"tags":[],"keywords":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://primeluoqiu.github.io/categories/Algorithm/"}]},{"title":"2.2 Web & HTTP","slug":"计算机网络/2.2","date":"2024-04-01T09:17:42.879Z","updated":"2024-04-01T11:08:04.359Z","comments":true,"path":"2024/04/01/计算机网络/2.2/","link":"","permalink":"https://primeluoqiu.github.io/2024/04/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.2/","excerpt":"","text":"","categories":[{"name":"计网","slug":"计网","permalink":"https://primeluoqiu.github.io/categories/%E8%AE%A1%E7%BD%91/"}],"tags":[],"keywords":[{"name":"计网","slug":"计网","permalink":"https://primeluoqiu.github.io/categories/%E8%AE%A1%E7%BD%91/"}]},{"title":"0401日记","slug":"Dairy/0401","date":"2024-04-01T09:17:30.561Z","updated":"2024-04-19T14:03:04.293Z","comments":true,"path":"2024/04/01/Dairy/0401/","link":"","permalink":"https://primeluoqiu.github.io/2024/04/01/Dairy/0401/","excerpt":"","text":"今天到目前为止似乎有一点点恢复，但是嗓子还是时不时的痛一会，早上花了110块钱报了软考，网络工程师，得等到蓝桥杯结束之后再看情况准备这个了。不过好在今天状态还行，学习的内容也不算很多。不过感觉也还好，该学习的时候学习，该放松的时候就好好放松一下。","categories":[{"name":"Dairy","slug":"Dairy","permalink":"https://primeluoqiu.github.io/categories/Dairy/"}],"tags":[],"keywords":[{"name":"Dairy","slug":"Dairy","permalink":"https://primeluoqiu.github.io/categories/Dairy/"}]},{"title":"3月31号日记","slug":"Dairy/0331","date":"2024-03-31T15:27:26.331Z","updated":"2024-03-31T15:36:28.667Z","comments":true,"path":"2024/03/31/Dairy/0331/","link":"","permalink":"https://primeluoqiu.github.io/2024/03/31/Dairy/0331/","excerpt":"","text":"今天身体不大舒服，早上起来之后就直接嗓子痛，很难受，然后晚上的话嗓子似乎好了一些，但是头有点晕，然后右胳膊也不是很舒服，一种酸痛的感觉。然后想学感觉脑子也跟不上了，这周任务还是没有完成，身体还是要好好养着的，不能太累，也不能太慵懒。也许是最近喝水不太多，也许是这两天做裁判有点累，今天还没休息的过来。然后就出去玩了一天，下午还洗了个澡。应该问题不大，下周有一个清明节，除了复习蓝桥杯之外应该还可以多学一点别的东西，任务应该是可以完成了。本周真的蛮可惜的，就差半个小时就把这周的任务做完了。但是身体实在是扛不住了，早点休息为好。 剩下的下周任务的明天早上看看能不能早点起来写吧。还是要加油。希望的曙光就在眼前了。加油！ 五一还是想回家把驾照考了。然后就没什么事情了，主要是考完之后就没什么事情了，还可以早过实习期。只要从学校跑出去，学校的事情就不管了，虽然不一定。但是还是要试试。","categories":[{"name":"Dairy","slug":"Dairy","permalink":"https://primeluoqiu.github.io/categories/Dairy/"}],"tags":[],"keywords":[{"name":"Dairy","slug":"Dairy","permalink":"https://primeluoqiu.github.io/categories/Dairy/"}]},{"title":"3月30号日记","slug":"Dairy/0330","date":"2024-03-30T13:22:10.277Z","updated":"2024-03-30T13:47:23.634Z","comments":true,"path":"2024/03/30/Dairy/0330/","link":"","permalink":"https://primeluoqiu.github.io/2024/03/30/Dairy/0330/","excerpt":"","text":"今天的志愿工作做的还不错，就是上午第一次给他们做评分的时候因为紧张，还有一些没注意过得地方出了不少差错。有两个组因为因为不小心的失误都少扣了十分，然后还好有一组没什么影响，但是有一组还是不得不扣了，不然的话名词会发生变化。这样的话就没有公平性可言了。不过这一上午的裁判工作还算是比较完善，没出什么大的差错，也没有遇见那种喜欢叨叨的同学和家长以及指导老师，大家都很不错，不过比起高中那边，听说有很多都在抬杠，包括指导老师。学生抬杠就算了，指导老师也跟着一起抬，这就没啥意思了。为人师长，自己不好好看看规则，然后就带着学生来比赛了。还带着学生一起抬杠，咱这也不是抬杠大赛，不是你声音大就可以赢了。以至于最后初中这边的比赛结束之后，高中那边的还没结束。然后就到了中午吃饭，这个饭啊，emm，只能说和昨天是天壤之别了。不过好歹也算是对付了两口，不至于大下午空着肚子执裁。下午的小学生组确实相对来说轻松一点，不过中间还是出现了一点小插曲，例如有一个小同学还是比较心急的想要碰一下，但是我们提醒到位，再加上也就是轻微碰了一下器材，也没有对实验造成什么实质上的印象，于是我们就没有让他重置了。当时在场的所有人都没有吭声，一直到结束之后换了下一组那个男人才开始说起来，这会已经没有时间再处理了。那个男人还在那里口若悬河的说说说。我们和主裁说了很多话，就是不听。对此只有一句话，就是菜就多练，输不起就别玩。换做是他的学生他是不是就不会吭声了，这个时候如果有别人像他一样，他是会觉得那个人不太行呢，还是怎么说呢？这就不好评价了。不过执裁的路途中还是学到了很多的。包括如何执裁，如何让同学和老师们信服执裁过程而没有意义，面对小朋友的时候该凶一点就要凶一点，该温柔的时候就应该温柔一点。都要有个度，例如，像下午小学场的小孩子们总是完美的结束之后不知道喊停，为了公平起见，我都是按照大概接触的时间给他们算的，这样也是一种相对来说的公平。然后比赛的时候有一次我就比较严声的跟他们说，我说你们不说，我给你们按什么时间算呢，是按照你喊的时间呢，还是按照结束的时间呢，结束之后一定要自己喊停。有的孩子喊早了，我还是一样的，我说你喊早了我应该怎么给你算呢，是按照早一点的算呢，还是等到了终点之后再算呢。希望他们可以记得住这次经历，并在以后的比赛中不要再犯这样的错误了。 不过有一说一今天是真的累，已经没有任何心力再学下去了，目前的任务其实也就是计网的2.2，不过这周的任务完成情况还得看明天结束这一周之后的任务状态。也不知道明天早上会睡到几点，因为今天实在是太累了，从早上执裁到下午。真的是做了一天的事情，走来走去，还要耗费精力去做这些事情，一不留神可能就漏掉了一个问题，然后就容易导致一些差错。下午的过程明显相对来说要顺利很多。晚上吃完饭回新工科之后，可能身体还好，但是思想是真的懈怠了，一点力气都没有了，或许这就是耗费了一天精力之后的感受吧。不过这一趟的收获还真的是蛮多的。而且在上午制裁的过程中，还无意中注意到了有一个正在做介绍的好像是体育馆的老师还是科技馆的老师，给那些领导讲解的时候，那个领导说他讲的还不错，然后问他在哪工作，那个人就说在科技馆这边工作，然后领导说他干得还不错，问之前怎么没见过他。他说好像是今天要接待领导，然后专门好好收拾了一下自己。看来这哥们的仕途应该要稍微往上一点点了，多少也是给领导留下来了一个好印象，没准哪天之后就会因为一些原因被提拔起来。哈哈哈哈 这两天嗓子似乎不大舒服，可能是扁桃体有点发炎，得多喝点水了。好好休息一下，也比较累，少熬会夜。加油吧","categories":[{"name":"Dairy","slug":"Dairy","permalink":"https://primeluoqiu.github.io/categories/Dairy/"}],"tags":[],"keywords":[{"name":"Dairy","slug":"Dairy","permalink":"https://primeluoqiu.github.io/categories/Dairy/"}]},{"title":"1.5 控制","slug":"ClassesFormUCBerkely/CS61A/1.5控制","date":"2024-03-29T13:50:16.549Z","updated":"2024-03-29T13:50:53.432Z","comments":true,"path":"2024/03/29/ClassesFormUCBerkely/CS61A/1.5控制/","link":"","permalink":"https://primeluoqiu.github.io/2024/03/29/ClassesFormUCBerkely/CS61A/1.5%E6%8E%A7%E5%88%B6/","excerpt":"","text":"1.5 控制现在可以定义的函数能力十分有限，因为还没有引入一种方法来进行比较，并根据比较的结果执行不同的操作。控制语句将赋予我们这种能力，就是根据逻辑比较的结果来控制执行流程的语句。 语句与我们目前研究过的表达式有着根本的不同，他们没有值。执行一个控制语句决定了解释器接下来应该做什么，而不是计算某些东西 1.5.1 语句到目前为止，虽然思考的是如何计算表达式，但我们已经见过了三种语句：赋值(assignment)、def和return语句。尽管这些Python代码都包含表达式作为他们的一部分，但它们本身并不是表达式。 语句不会被求解，而会被执行。每个语句都描述了对解释器状态的一些更改，并且执行语句就会应用该更改。正如在return和赋值语句中看到的那样，执行语句可能涉及求解其包含的子表达式。 表达式也可以作为语句执行，在这种情况下，它们会被求值，但是它们的值会被丢弃。执行纯函数没有效果，但执行非纯函数会因为调用函数而产生效果。 思考一下，例如: 12&gt;&gt;&gt; def square(x): mul(x, x) 这个例子是有效的Python代码，但是不能达到预期。表达式本身是一个有效的语句，但语句的效果是调用mul函数，然后把结果丢弃。如果想对表达式的结果做什么，需要用赋值语句存储它或用return语句返回它： 12&gt;&gt;&gt; def square(x) return mul(x, x) 有时，在调用print等非纯函数时，拥有一个主体为表达式的函数确实有意义。 12&gt;&gt;&gt; def print_square(x) print(square(x)) 在最高层级上，Python解释器的工作是执行由语句组成的程序。然而，很多有趣的计算工作都来自对表达式的求值。语句用来管理程序中不同表达式之间的关系，以及它们产生的结果。 1.5.2 复合语句通常，Python代码是一系列语句。简单语句是不以冒号结尾的单行，而由其他语句(简单语句和复合语句)组成被称为复合语句。复合语句通常跨越多行，以单行头部(header)开始，并以冒号结尾，其中冒号标识语句的类型。头部和缩进的句体(suite)一起称为子句。复合语句由一个或多个子句组成： 123456789&lt;header&gt;: &lt;statement&gt; &lt;statement&gt; ...&lt;separating header&gt; &lt;statement&gt; &lt;statement&gt; ...... 我们可以用这些术语来理解我们之前介绍过的语句。 表达式、返回语句和赋值语句都是简单语句。 def语句是复合语句，def头后面的句体定义了函数体。对每类header 都有专门的求值规则来规定其何时执行以及是否执行其句体中的语句。我们说”the header controls its suite”, 例如，在def语句中，return表达式不会立即求值，而是存储起来供以后调用该函数时使用。 我们现在也可以理解多行程序了。 要执行一系列语句，会先执行第一个语句，如果不重定向控制，那么就继续执行其余部分这个定义解释了递归定义序列(sequence)的基本结构：一个序列可以分解成它的第一个元素和其余元素。语句序列的”其余部分”本身也是语句序列!因此，我们可以递归地应用这个执行规则。这就是将递归视为数据结构的观点 此规则的重要结论时语句会按顺序执行，但由于重定向控制(redirected control),后面的语句可能永远不会被执行到。 缩进必须要缩进相同的量。 1.5.3 定义函数II:局部赋值函数的主体不仅仅是包含单个返回语句的return组成，事实上，还可以定义超出单个表达式的一系列操作。 每当用户定义的函数被调用时，其具体中的子句序列将会在局部环境中执行-&gt;该环境通过调用函数创建的局部帧开始。return语句会重定向控制：每当执行一个return语句时，函数应用程序就会终止，return表达式的值会被作为被调用函数的返回值。 赋值语句可以出现在函数体中，例如 1234def percent_difference(x, y): difference = abs(x - y) return 100 * difference / xresult = percent_difference(40, 50) 这个函数利用了两步计算，首先计算两个数的差的绝对值，然后求出它与第一个数的百分比并返回 赋值语句的作用是将名称和当前环境中的第一帧的值绑定。因此，函数体内的赋值语句不会影响全局帧。”函数只能操纵其局部帧”是创建模块化程序的关键，而在模块化程序中，纯函数仅通过它们接收和返回的值与外界交互。 当然，上述函数也可以只用一条赋值语句实现，但是返回表达式会更复杂 return 100 * abs(x - y) 到目前为止，局部赋值并没有增强函数定义的表达能力，而当它与其他控制语句结合时，就会增强。此外，局部赋值在”通过中间量赋名来解释复杂表达式的含义”方面也起着至关重要的作用。 1.5.4 条件语句Python有一个用于计算绝对值的内置函数。 12&gt;&gt;&gt; abs(-2)2 我们希望可以实现这样一个函数。但是我们想清楚我们要表达的是，如果x为正，就为正，为负取反。那么可以用条件语句来表示 123456def absolute_value(x): if(x &gt;= 0): return x else: return -xresult = absolute_value(x) 这个absolute_value函数的实现提出了几个重要问题： 条件语句(Condition statement):Python中的条件语句是由一系列头部和句体组成的：必须的if子句、可选的elif子句序列，最后是可选的else子句： 123456if &lt;expression&gt;: &lt;suite&gt;elif &lt;expression&gt;: &lt;suite&gt;else: &lt;suite&gt; 执行条件语句的时候，每个子句都会按顺序被考虑。执行条件子句的计算过程如下。 求解头部的表达式 如果它是真值，则执行该句体。然后跳过条件语句中的所有后续子句。 如果达到else语句(仅当所有if和elif表达式的计算结果为假值时才会发生),则执行其句体。 布尔上下文(Boolean contexts)：上面，执行过程提到了”假值 a false value”和”真值 a true value”。条件块头部语句内的表达式被称为布尔上下文：它们值的真假对控制流很重要，另外，它们的值不会被赋值或返回。Python包含多个假值，包括**0, None, 和布尔值false**，所有其他数字都是真值。 布尔值(Boolean Value)：Python中有两个布尔值:True和False。布尔值表示逻辑表达式中的真值。内置的比较运算符&gt;,&lt;,&gt;&#x3D;,&lt;&#x3D;,&#x3D;&#x3D;, !&#x3D;会返回这些值。 1234&gt;&gt;&gt; 4 &gt; 2False&gt;&gt;&gt; 5 &gt;= 5True 第二个例子在operator模块中的ge 12&gt;&gt;&gt; 0 == -0True 这个对应的是operator中的eq。Python会区分赋值和相等比较符号，许多语言都是这样 布尔运算符(Boolean operator):Python中还内置了三个基本的逻辑运算符： 123456&gt;&gt;&gt; True and FalseFalse&gt;&gt;&gt; True or FalseTrue&gt;&gt;&gt; not FalseTrue 逻辑表达式具有相应的求值过程。而这些过程利用了这样的一个理论-&gt;有时，逻辑表达式的真值可以在不对其所有子表达式求值的情况下确定，这一特性称为短路，例如(or) 求解表达式 &lt;left&gt; and &lt;right&gt; 的步骤如下： 求解子表达式 &lt;left&gt;。 如果左边的结果为假值 v，则表达式的计算结果就是 v。 否则，表达式的计算结果为子表达式 &lt;right&gt; 的值。 求解表达式 &lt;left&gt; or &lt;right&gt; 的步骤如下： 求解子表达式 &lt;left&gt;。 如果左边的结果为真值 v，则表达式的计算结果就是 v。 否则，表达式的计算结果为子表达式 &lt;right&gt; 的值。 求解表达式 not &lt;exp&gt; 的步骤如下： 求解 &lt;exp&gt;，如果结果为假值，则值为 True ，否则为 False。 这些值、规则和运算符为我们提供了一种组合比较结果的方法。执行比较并返回布尔值的函数通常以 is 开头，后面不跟下划线（例如 isfinite, isdigit, isinstance 等）。 1.5.5 迭代除了选择要执行的语句外，控制语句还用于重复。如果我们编写的每一行代码只执行一次，那么编程将是一项非常低效的工作只有通过重复执行语句，我们才能释放计算机的全部潜力。我们之前已经见过了一种重复形式:一种函数只用定义一次，就可以被多次调用。迭代控制(Iterative control)结构是另一种多次执行相同语句的机制。 思考一下之前学过的斐波那契数列，其中每个数都是前两个数的和。$$0, 1, 1, 2, 3, 5, 8, 13, 21 …$$每个值都是通过重复应用sum-previous-two的规则构建的，第一个和第二个值固定为0和1. 我们可以使用while语句来枚举n项斐波那契数列。我们需要跟踪已经创建了多少个值(k),和第k个值(curr)及其前身(pred)。单步执行此函数并观察斐波那契数列如何一个一个的演化，并绑定到curr 1234567891011def fib(n): &quot;&quot;&quot; Compute the nth Fibonacci number, for n &gt;= 2 &quot;&quot;&quot; pred, curr = 0, 1 #Fibonacci numbers 1 and 2 k = 2 while k &lt; n: pred, curr = curr, pred + curr k = k + 1 return curr result = fib(8) 请记住，单行赋值语句可以用逗号分隔多个名称和值同时赋值。该行： pred, curr = curr, pred + curr 在更新左侧的绑定之前求出所有 = 右侧的内容 → 这种事件顺序对于此函数的正确性至关重要。 while 子句包含一个头部表达式，后跟一个句体： 12while &lt;expression&gt;: &lt;suite&gt; 要执行 while 子句： 求解头部的表达式。 如果是真值，则执行后面的句体，然后返回第 1 步。 在第 2 步中，while 子句的整个句体在再次计算头部表达式之前执行。 为了防止 while 子句的句体无限期地执行，句体应该总是在每次循环中更改一些绑定。 不会终止的 while 语句被称为无限循环（infinite loop）。按 &lt;Control&gt;-C 可以强制 Python 停止循环。 1.5.6 测试测试一个函数就是去验证函数的行为是否符合预期。 测试是一种系统地执行验证的机制。它通常采用另一个函数的形式，其中包含对一个或多个对被测试函数的调用样例，然后根据预期结果验证其返回值。与大多数旨在通用的函数不同，测试需要选择特定参数值，并使用它们验证函数调用。测试也可用作文档：去演示如何调用函数，以及如何选取合适的参数值。 断言（Assertions）：程序员使用 assert 语句来验证是否符合预期，例如验证被测试函数的输出。assert 语句在布尔上下文中有一个表达式，后面是一个带引号的文本行（单引号或双引号都可以，但要保持一致），如果表达式的计算结果为假值，则显示该行。 1&gt;&gt;&gt; assert fib(8) == 13, &#x27;第八个斐波那契数应该是 13&#x27; 当被断言的表达式的计算结果为真值时，执行断言语句无效。而当它是假值时，assert 会导致错误，使程序停止执行。 fib 的测试函数应该测试几个参数，包括 n 的极限值。 1234&gt;&gt;&gt; def fib_test(): assert fib(2) == 1, &#x27;第二个斐波那契数应该是 1&#x27; assert fib(3) == 1, &#x27;第三个斐波那契数应该是 1&#x27; assert fib(50) == 7778742049, &#x27;在第五十个斐波那契数发生 Error&#x27; 当在文件中而不是直接在解释器中编写 Python 时，测试通常是在同一个文件或带有后缀 _test.py 的相邻文件中编写的。 文档测试（Doctests）：Python 提供了一种方便的方法，可以将简单的测试直接放在函数的文档字符串中。文档字符串的第一行应该包含函数的单行描述，接着是一个空行，下面可能是参数和函数意图的详细描述。此外，文档字符串可能包含调用该函数的交互式会话示例： 123456789101112&gt;&gt;&gt; def sum_naturals(n): &quot;&quot;&quot;返回前 n 个自然数的和。 &gt;&gt;&gt; sum_naturals(10) 55 &gt;&gt;&gt; sum_naturals(100) 5050 &quot;&quot;&quot; total, k = 0, 1 while k &lt;= n: total, k = total + k, k + 1 return total 然后，可以通过 doctest 模块 来验证交互，如下。 123&gt;&gt;&gt; from doctest import testmod&gt;&gt;&gt; testmod()TestResults(failed=0, attempted=2) 如果仅想验证单个函数的 doctest 交互，我们可以使用名为 run_docstring_examples 的 doctest 函数。不幸的是，这个函数调用起来有点复杂。第一个参数是要测试的函数；第二个参数应该始终是表达式 globals() 的结果，这是一个用于返回全局环境的内置函数；第三个参数 True 表示我们想要“详细”输出：所有测试运行的目录。 12345678910111213&gt;&gt;&gt; from doctest import run_docstring_examples&gt;&gt;&gt; run_docstring_examples(sum_naturals, globals(), True)Finding tests in NoNameTrying: sum_naturals(10)Expecting: 55okTrying: sum_naturals(100)Expecting: 5050ok 当函数的返回值与预期结果不匹配时，run_docstring_examples 函数会将此问题报告为测试失败。 当你在文件中编写 Python 时，可以通过使用 doctest 命令行选项启动 Python 来运行文件中的所有 doctest： 1python3 -m doctest &lt;python_source_file&gt; 有效测试的关键是在实现新功能后立即编写（并运行）测试。在实现之前编写一些测试也是一种很好的做法，以便在你的脑海中有一些示例输入和输出。调用单个函数的测试称为单元测试（unit test）。详尽的单元测试是良好程序设计的标志。 总结来看，本节的主要内容是对于函数的控制，函数不仅包含了能够返回值的return语句，还可以对函数进行多种复杂的语句，例如复合语句。然后就是有关局部赋值，也就是在函数内部定义一个变量用来进行赋值的操作。接下来就是有关条件的if-else语句和布尔值，在这里，要对逻辑表达式的求值过程中的短路有所了解。接下来就是函数内部的迭代，这里利用到了while语句，通过while语句来更新斐波那契数列的pred和curr，最后就是对于函数的测试，我们要看我们写的函数是不是满足我们的心理预期。测试的方式有很多种，包括但不限于断言和文档测试。最后，我们了解到有效测试的关键是在实现新功能后立即编写(并运行)测试。在实验之前编写一些测试也是一种很好的做法。详尽的单元测试是良好程序设计的标志。","categories":[{"name":"CS61A","slug":"CS61A","permalink":"https://primeluoqiu.github.io/categories/CS61A/"}],"tags":[],"keywords":[{"name":"CS61A","slug":"CS61A","permalink":"https://primeluoqiu.github.io/categories/CS61A/"}]},{"title":"3月29日日记","slug":"Dairy/0329","date":"2024-03-29T13:37:01.094Z","updated":"2024-03-29T13:49:58.154Z","comments":true,"path":"2024/03/29/Dairy/0329/","link":"","permalink":"https://primeluoqiu.github.io/2024/03/29/Dairy/0329/","excerpt":"","text":"今天下午去做了志愿之前的准备工作，虽然似乎并没有干什么，但是还是感觉到身体有一阵疲惫的感觉。晚上回来的路上甚至靠在车的座位的背部小憩了一会。这个志愿工作也签署了保密协议，不过感觉跟之前的在严谨性上差了好多。晚上的餐食还不错，小小的炫了点饭。也是没想到居然会拿蒜薹炒一点牛肉。这个是没想到的。 一下午基本上过去之后就是在那边坐着，然后开了个预备大会，然后就是吃饭啥的，然后在吃饭之前的比赛场馆里面看到有一些看起来比较高科技的所谓的能够通过脑电波来测试专注力，虽然但是，我还是觉得是有一定的技术成分，但是似乎也并不高。有参考意义，但不多。就像手上带的手表和购买的体脂秤所评价出来的心率道理是一样的。两个数据基本上就从来都没有对准过。 还是在减肥的路上，但是目前好像又涨了一些，体重目前保持在了95附近，但是也不知道下个月能不能到90左右，是有在坚持运动和锻炼，但是主要还是早上起不来，起得来的话早上出去走两圈还是很舒服的，晚上睡的也晚，其实是可以早点休息的，不过主要似乎也不是很困，然后熬着熬着夜就深起来了，倒也没什么办法。晚上上床之后还是看看书，有啥好一点的电子书看着看着应该也就困了。 希望明天的志愿活动不要出什么差错，完完整整的度过这一整天就好","categories":[{"name":"Dairy","slug":"Dairy","permalink":"https://primeluoqiu.github.io/categories/Dairy/"}],"tags":[],"keywords":[{"name":"Dairy","slug":"Dairy","permalink":"https://primeluoqiu.github.io/categories/Dairy/"}]},{"title":"2.0-2.1应用层概述及应用层原理","slug":"计算机网络/2.0.1","date":"2024-03-28T15:08:54.880Z","updated":"2024-03-28T15:22:22.428Z","comments":true,"path":"2024/03/28/计算机网络/2.0.1/","link":"","permalink":"https://primeluoqiu.github.io/2024/03/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.0.1/","excerpt":"","text":"","categories":[{"name":"计网","slug":"计网","permalink":"https://primeluoqiu.github.io/categories/%E8%AE%A1%E7%BD%91/"}],"tags":[],"keywords":[{"name":"计网","slug":"计网","permalink":"https://primeluoqiu.github.io/categories/%E8%AE%A1%E7%BD%91/"}]},{"title":"1.4设计函数","slug":"ClassesFormUCBerkely/CS61A/1.4 设计函数","date":"2024-03-27T14:06:19.040Z","updated":"2024-03-27T14:07:07.517Z","comments":true,"path":"2024/03/27/ClassesFormUCBerkely/CS61A/1.4 设计函数/","link":"","permalink":"https://primeluoqiu.github.io/2024/03/27/ClassesFormUCBerkely/CS61A/1.4%20%E8%AE%BE%E8%AE%A1%E5%87%BD%E6%95%B0/","excerpt":"","text":"1.4 设计函数函数是所有程序(无论大小)的基本组成部分，并且是我们使用编程语言来表达计算过程的主要媒介。本节内容是如何设计一个好的函数。 那么好函数共有的品质就是：它们都强化了”函数就是抽象”理念。 每个函数应该只负责一个任务，且该任务要用一个简短的名称来识别，并在一行文本中进行描述。按顺序执行多个任务的函数应该分为多个函数。 不要重复自己(Don’t repeat yourself)是软件工程的核心原则。这个所谓的DRY原则直出，多个代码片段不应该描述重复的逻辑。相反，逻辑应该只实现一次，为其指定一个名称后多次使用。 定义通用函数。比如作为pow函数的一个特例的平方函数就不在Python库中，因为pow函数可以将数字计算为任意次方。 这些准则提高了代码的可读性，减少了错误的数量，并且通常最大限度地减少了便携的代码总量。将复杂的任务分解为简洁的功能是一项需要经验才能掌握的技能。不过好在Python提供了多种特性来支持工作 1.4.1 文档函数定义通常包括描述函数的文档，称为”文档字符串 docstring”，它必须在函数体中缩进。文档字符串通常使用三个引号，第一行描述函数的任务，随后的几行可以描述参数并解释函数的意图 123456789&gt;&gt;&gt; def pressure(v, t, n): &quot;&quot;&quot; 计算理想气体的压力，单位为帕斯卡 v -- 气体体积，单位为立方米 t -- 绝对温度，单位为开尔文 n -- 气体粒子 &quot;&quot;&quot; k = 1.38e - 23 #玻尔兹曼常数 return n * k * t / v 当你使用函数名称作为参数调用help时，你会看到它的文档字符串(键入q以退出Python help)。 1&gt;&gt;&gt; help(pressure) 编写Python程序时，除了最简单的函数之外，都要包含文档字符串。要记住，虽然代码只编写一次，但是会在之后阅读多次。Python文档包含了文档字符串准则，它会在不同的Python项目中保持一致。 注释：Python中的注释可以附加到#号后的行尾。例如，上面代码中的#后面的注释描述了k变量的含义。这些注释不会出现在Python的help中，而且会被解释器忽略，它们只为了注释而出现 1.4.2 参数默认值定义通用函数的结果是引入了额外的参数。具有许多参数的函数可能调用起来很麻烦并且难以阅读。 在Python中，我们可以为函数的参数提供默认值。当调用该函数时，具有默认值的参数是可选的。如果未提供，则将默认值绑定到形参上。例如，如果程序通常用于计算”一摩尔”粒子的压力，则可以提供此值作为默认值 123456789&gt;&gt;&gt; def pressure(v, t, n = 6.022e23): &quot;&quot;&quot; 计算理想气体的压力，单位为帕斯卡 v -- 气体体积，单位为立方米 t -- 绝对温度，单位为开尔文 n -- 气体粒子 &quot;&quot;&quot; k = 1.38e - 23 #玻尔兹曼常数 return n * k * t / v =符号在此等示例中表示两种不同的含义，具体取决于使用它的上下文。在def语句中,=不执行赋值，而是指示调用pressure函数时使用的默认值。相比之下，函数体中对k的赋值语句中将名称k与玻尔兹曼常数的近似值进行了绑定。 1234&gt;&gt;&gt; pressure(1, 273.15)2269.974834&gt;&gt;&gt; pressure(1, 237.15, 3 * 6.022e23)6809.924502 pressure函数的定义接受三个参数，但上面的第一个调用表达式中值提供了两个。在这种情况下，n的值取自def语句的默认值。如果提供了，那么默认值就会被忽略 作为准则，函数主体中使用的大多数数据值都应该表示为具名参数(named arguments)的默认值，这样会使他们更易于检查，并且可以被函数调用者更改。一些永远不会改变的值，例如基本常量k可以绑定在函数体或全局帧中。","categories":[{"name":"CS61A","slug":"CS61A","permalink":"https://primeluoqiu.github.io/categories/CS61A/"}],"tags":[],"keywords":[{"name":"CS61A","slug":"CS61A","permalink":"https://primeluoqiu.github.io/categories/CS61A/"}]},{"title":"1.8历史","slug":"计算机网络/1.8","date":"2024-03-27T12:03:09.041Z","updated":"2024-03-27T12:10:08.736Z","comments":true,"path":"2024/03/27/计算机网络/1.8/","link":"","permalink":"https://primeluoqiu.github.io/2024/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.8/","excerpt":"","text":"","categories":[{"name":"计网","slug":"计网","permalink":"https://primeluoqiu.github.io/categories/%E8%AE%A1%E7%BD%91/"}],"tags":[],"keywords":[{"name":"计网","slug":"计网","permalink":"https://primeluoqiu.github.io/categories/%E8%AE%A1%E7%BD%91/"}]},{"title":"1.3定义新函数","slug":"ClassesFormUCBerkely/CS61A/1.3 定义新函数","date":"2024-03-26T05:47:33.393Z","updated":"2024-03-27T14:07:05.154Z","comments":true,"path":"2024/03/26/ClassesFormUCBerkely/CS61A/1.3 定义新函数/","link":"","permalink":"https://primeluoqiu.github.io/2024/03/26/ClassesFormUCBerkely/CS61A/1.3%20%E5%AE%9A%E4%B9%89%E6%96%B0%E5%87%BD%E6%95%B0/","excerpt":"","text":"1.3定义新函数通过对Python的了解，我们确定了强大的编程语言中会有一些必须出现的元素 原始的内置数据和函数：数字和算术运算 组合方式：嵌套函数 受限的抽象方式：将名称与值绑定 接下来的内容是函数定义，这是一种更强大的抽象技术，通过它可以将名称与复合操作绑定为一个单元。 首先来研究一下平方的概念。因为平方就是一个数乘它本身。这在Python中可以表示为 12&gt;&gt;&gt; def square(x): return mul(x, x) 上述定义了一个名为square的新函数，这个用户定义的函数并不会内置到解释器中，它表示将一个值和自身相乘的复合运算，定义时的括号里的x是作为被乘的东西的名称，称为形式参数， 同时也将此函数与square绑定。 如何定义函数：函数定义包含def语句、&lt;name 函数名&gt;和一个以逗号分隔的&lt;formal parameters形式参数&gt;列表，然后是一个被称为函数体的return语句，它指定了调用函数时要计算的表达式，也就是函数的&lt;return expression 返回表达式&gt;： 12def &lt;name&gt;(&lt;formal parameters&gt;): return &lt;return expression&gt; 函数的第二行必须进行缩进，大多数程序员使用四个空格。返回表达式会作为新定义的函数的一部分存储，并且在最终调用该函数时才进行求值。 定义了square之后，我们可以调用它： 123456&gt;&gt;&gt; square(21)441&gt;&gt;&gt; square(add(2, 5))49&gt;&gt;&gt; square(square(3))81 我们还可以将square作为一个建构单元来定义其他函数。例如，我们可以很容易地定义一个函数sum_squares, 给定任意两个数字作为参数，返回他们的平方和： 1234&gt;&gt;&gt; def sum_squares(x, y) return add(square(x), square(y))&gt;&gt;&gt; sum_squares(3, 4)25 用户定义函数的使用方式与内置函数完全相同。实际上，从sum_square的定义中我们不能判断square是内置于解释器中，还是从模块中导入的，又或是用户定义的。 def语句和赋值语句都将名称与值绑定，并且绑定后对于之前绑定的东西就会直接失效，也就是throw掉了，例如下述的g首先指的是一个没有参数的函数，然后是指一个数字，最后是一个含有两个参数的函数。 12345678910&gt;&gt;&gt; def g(): return 1&gt;&gt;&gt; g()1&gt;&gt;&gt; g = 2&gt;&gt;&gt; g2&gt;&gt;&gt; def g(h, i) reurn h + i&gt;&gt;&gt; g(1, 2) 1.3.1 环境Python子集已经蛮复杂的，但是程序的含义还并不明显，如果形参与内置函数同名怎么办？两个函数可以共享名称而不混淆么？ 求解表达式的环境由帧序列组成，他们可以被描述为一些盒子，每个帧都包含了一些绑定，他们将名称和对应的值相关联。全局帧(global frame) 只有一个。赋值和导入语句会将条目添加到当前环境的第一帧。目前，我们的环境仅由全局帧组成。![[..&#x2F;..&#x2F;Pasted image 20240326211337.png]]这个环境图显示了当前环境中的绑定，还有名称和值的绑定。(OnlinePythonTutor)[https://www.composingprograms.com/tutor.html]中演示，可以用来查看环境图 函数也会出现在环境图中。import语句将名称和内置函数绑定。def语句将名称与用户自定义的函数绑定。导入mul并定义square后的结果环境如下图所示：![[..&#x2F;..&#x2F;Pasted image 20240326211659.png]]每个函数都是一行，以func开头，后面是函数名称和形式参数。mul等内置函数没有正式的参数名称，所以都是使用...代替。函数名称重复两次，一次在环境帧中，另一次是作为函数定义的一部分。函数定义中出现的名称叫做**内在名称(intrinsic name)，帧中的名称叫做绑定名称(bound name)**。两者之间有一个区别：不同的名称可能指的是同一个函数，但函数本身只有一个内在名称。 绑定到帧中的函数名称是在求值过程中使用，而内在名称在求职中不起作用。如下面的实例 1234f = maxmax = 3result = f(2, 3, 4)max(1, 2) #casue an error 当max函数和数值3绑定之后，它就不能再用作函数错误信息是&quot;TypeError: &#39;int&#39; object is not callable&quot;,报告了名称max(当前绑定到数字3)是一个整数而不是函数，所以它不能用作调用表达式中的运算符。 函数签名：每个函数允许采用的参数数量有所不同。为了跟踪这些要求，我们绘制了每个函数的名称及其形式参数。用户定义的square只需要x一个参数，提供或多或少的参数都将导致错误。对函数形式参数的描述被称为函数的签名。 函数max可以接收任意数量的参数，所以它被呈现为max(...)。因为原始函数从未明确定义，所以无论采用多少个参数，所有的内置函数都将呈现为&lt;name&gt;(...) 1.3.2调用用户定义的函数为了求出操作符为用户定义函数的调用表达式，Python解释器遵循了以下计算过程。与其他调用表达式一样，解释器将对操作符和操作数表达式求值，然后用生成的实参调用具名函数。 调用用户定义的函数会引入局部帧(local frame)，它只能访问该函数。通过一些实参调用用户定义的函数： 在新的局部帧中，将实参绑定到函数的形参上。 在此以帧开始的环境中执行函数体。求值函数体的环境由两个帧组成：一是包含形式参数绑定的局部帧，然后是包含其他所有内容的全局帧。函数的每个实例都有自己独立的局部帧。","categories":[{"name":"CS61A","slug":"CS61A","permalink":"https://primeluoqiu.github.io/categories/CS61A/"}],"tags":[],"keywords":[{"name":"CS61A","slug":"CS61A","permalink":"https://primeluoqiu.github.io/categories/CS61A/"}]},{"title":"1.7 协议层次和服务模型","slug":"计算机网络/1.7","date":"2024-03-25T14:08:13.610Z","updated":"2024-03-27T12:10:17.105Z","comments":true,"path":"2024/03/25/计算机网络/1.7/","link":"","permalink":"https://primeluoqiu.github.io/2024/03/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.7/","excerpt":"","text":"","categories":[{"name":"计网","slug":"计网","permalink":"https://primeluoqiu.github.io/categories/%E8%AE%A1%E7%BD%91/"}],"tags":[],"keywords":[{"name":"计网","slug":"计网","permalink":"https://primeluoqiu.github.io/categories/%E8%AE%A1%E7%BD%91/"}]},{"title":"计网第二个实验","slug":"SchoolHomework/计网/Experiment2","date":"2024-03-25T05:46:43.090Z","updated":"2024-04-22T16:32:59.112Z","comments":true,"path":"2024/03/25/SchoolHomework/计网/Experiment2/","link":"","permalink":"https://primeluoqiu.github.io/2024/03/25/SchoolHomework/%E8%AE%A1%E7%BD%91/Experiment2/","excerpt":"","text":"五、实验步骤 1.数据规划（课程目标1） 表1-交换机VLAN划分及端口 设备名 VLAN编号 VLAN名称 端口范围 连接计算机 LSW1 vlan 10 技术部 E 0&#x2F;0&#x2F;1 - E 0&#x2F;0&#x2F;2 PC1, PC3 LSW2 vlan 20 财务部 E 0&#x2F;0&#x2F;1 - E 0&#x2F;0&#x2F;2 PC2, PC4 表2-PC计算机IP地址及端口信息 设备名 端口 IP地址信息 网关 PC1 E 0&#x2F;0&#x2F;1 10.10.1.1 255.255.255.0 PC2 E 0&#x2F;0&#x2F;2 10.10.1.2 255.255.255.0 PC3 E 0&#x2F;0&#x2F;3 10.10.1.3 255.255.255.0 PC4 E 0&#x2F;0&#x2F;4 10.10.1.4 255.255.255.0 2.启动有eNSP模拟器，按实验要求和规划，搭建网络拓扑。（课程目标3） 上图IP地址应为10.10.1.3，当时打错了，后面有纠正 3.设备配置。（课程目标3）本次配置比起实验一来说，就是多了对于两个交换机的控制，其余的配置都是一样的，当我们配置完每台PC的IP之后，我们就可以进入交换机进行配置了。首先我们进入LSW(交换机1)，然后我们首先关闭之后可能会出现的提示信息 1undo info-center enable 接下来，我们首先配置第一个交换机所连接的两台PC和对应连接的一台交换机的端口。操作还是和之前一样的操作 12sysvlan batch 10 20 首先进入sys然后创建两个vlan 10和20 123interface G 0/0/1 //G是一种端口的名称，指千兆以太网端口，而上个实验的E指的是普通以太网端口port link-type accessport default vlan 10 这是第一台PC的配置 123interface G 0/0/2port link-type accessport default vlan 20 这是第二台PC的配置接下来是本实验的核心内容，就是配置24端口的两台交换机，使得他们可以通过vlan10 和 vlan20这两个线路。这样的话就可以连接起来这两台交换机了。 123interface G 0/0/24port link-type trunkport trunk allow-pass vlan 10 20 这样的话，这个交换机和交换机之间的线缆就可以通过10和20的接口了。剩下的就是配置第二台交换机的配置，方法和上述方法一样，重复一下即可。 123456789101112undo info-center enablesysvlan batch 10 20interface G 0/0/1 //G是一种端口的名称，指千兆以太网端口，而上个实验的E指的是普通以太网端口port link-type accessport default vlan 10interface G 0/0/2port link-type accessport default vlan 20interface G 0/0/24port link-type trunkport trunk allow-pass vlan 10 20 我们不难看出vlan10和20这两个线路均有24接口通过。那么实验就完成了，接下来验证实验就可以了。 4.验证。（课程目标3）PC2验证PC1配置由图可知，pc1可以连3，2可以连4，这样的话我们的实验目的也就完成了 拓扑图如上。六、实验心得或存在的问题（课程目标1)本次实验学到了有关不同楼层的两台交换机之间应该如何配置，以至于达到楼层之间的互联而不与同楼层之间的互联。本次实验还学习到了有关link-type trunk以及trunk接口是用于交换机之间连接的端口，trunk口可以1加入多个vlan，以及接收和发送多个Vlan的Tagged帧。还了解到了G口是千兆以太网口，E口是以太网口的知识点。","categories":[{"name":"Expriment","slug":"Expriment","permalink":"https://primeluoqiu.github.io/categories/Expriment/"}],"tags":[],"keywords":[{"name":"Expriment","slug":"Expriment","permalink":"https://primeluoqiu.github.io/categories/Expriment/"}]},{"title":"Week4 and Daily Schedule","slug":"每周学习计划/Week4","date":"2024-03-24T13:23:47.317Z","updated":"2024-04-01T13:56:17.189Z","comments":true,"path":"2024/03/24/每周学习计划/Week4/","link":"","permalink":"https://primeluoqiu.github.io/2024/03/24/%E6%AF%8F%E5%91%A8%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/Week4/","excerpt":"","text":"Daily ScheduleTotal Schedule 《计算机网络》-郑铨老师的 1.7-2.2 CS61B Week 7- 10 CS61A 看完第二章 CSAPP 看完第二章 CS61C 前两周内容 每天任务的话，先看周一吧，周一相对来说课不算多，下午有一节毛概，毛概课的话得补半节课的数电笔记和作业 Monday《计算机网络》 1.7 CS61A CS61B CSAPP 还得看点算法，要不都快要蓝桥杯考试了，顶不住了 目前先准备这些，看明天的收效，希望明天早上可以起得来然后走两圈锻炼锻炼。","categories":[{"name":"大二下","slug":"大二下","permalink":"https://primeluoqiu.github.io/categories/%E5%A4%A7%E4%BA%8C%E4%B8%8B/"}],"tags":[],"keywords":[{"name":"大二下","slug":"大二下","permalink":"https://primeluoqiu.github.io/categories/%E5%A4%A7%E4%BA%8C%E4%B8%8B/"}]},{"title":"第三周总结","slug":"每周学习计划/第三周总结","date":"2024-03-24T13:07:37.059Z","updated":"2024-03-24T13:34:07.396Z","comments":true,"path":"2024/03/24/每周学习计划/第三周总结/","link":"","permalink":"https://primeluoqiu.github.io/2024/03/24/%E6%AF%8F%E5%91%A8%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/%E7%AC%AC%E4%B8%89%E5%91%A8%E6%80%BB%E7%BB%93/","excerpt":"","text":"本周学习任务完成情况： 郑铨《计算机网络》:已看完1.6，还差一节视频 CS61B 目标未完成，达成率 0 CS61A 仅仅看了1.4之前的，还差一章 CSAPP：差一节的知识点和两节的对于知识点的总结 CS61C：甚至还没看课 总结：怎么说呢，本周的事情相对来说比较多，很多时候为了处理一些事情不得不去花费一晌的时间。究其根本的话还是因为考虑的事情太多太繁杂，像极了酷安的那张经典图片，某物在拥有前，拥有时，以及拥有后的心情状态。 其实有的时候也是，覆水难收是肯定的事情，硬要做一些可能看起来不是那么的合常理的事情的时候，往往就会产生很多负面的因素，谁能想到收到的手机会是一个被拿去抵债的手机呢。不过其实经此一事的话，二手的市场还真的水深，得亏是那个老哥很好说话，再加上我的态度也是非常的到位，以至于目前来说似乎并没有产生什么不和平的因素。就感觉也还好。本周这种事情占得时间还是蛮多的。课程的任务量其实也还好，就是笔记和每周的作业。感觉也还OK，起码目前基本上emm也算是个应付的态势吧 有的时候还是心不静，心乱的话效率也不会很高。每次学习的时候也不妨像他们一样手机扣一下，然后就在一边放着。电脑端挂个微信就行，不过似乎我好像也不会被别人找的样子hhh 这两周的锻炼还算是有所成效，减重了一些，但不多，想要减重还是得每天坚持锻炼，然后规律作息、规律作息、规律作息，重要的事情说三遍hhh，早上倒也还是能起得来，就是太困了，归根结底还是晚上睡的太晚，十二点半左右能睡的话第二天的精神状态想必就会好很多了。早上起来之后的感觉也不会太困。 啧，其实有的时候也在想，如果我要不是天天学习，或者说如果我真的把这大学四年荒废过去会怎么样，虽然我妈对我的要求确实不高，也就是混口饭吃的程度。不过再怎么说都是要勤奋的，无论是在后面的学习上，还是之后的找工作上。去哪里，找什么样的工作，这些虽然都是后话，但是也是在茫然之中会考虑到的一些事情。 时间…时间… 还有多久呢…","categories":[{"name":"大二下","slug":"大二下","permalink":"https://primeluoqiu.github.io/categories/%E5%A4%A7%E4%BA%8C%E4%B8%8B/"}],"tags":[],"keywords":[{"name":"大二下","slug":"大二下","permalink":"https://primeluoqiu.github.io/categories/%E5%A4%A7%E4%BA%8C%E4%B8%8B/"}]},{"title":"CSAPP Chapter1.7 硬件被谁管理啊","slug":"CSAPP/第一章/1.7操作系统管理硬件","date":"2024-03-24T02:51:49.635Z","updated":"2024-03-24T02:43:36.991Z","comments":true,"path":"2024/03/24/CSAPP/第一章/1.7操作系统管理硬件/","link":"","permalink":"https://primeluoqiu.github.io/2024/03/24/CSAPP/%E7%AC%AC%E4%B8%80%E7%AB%A0/1.7%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E7%A1%AC%E4%BB%B6/","excerpt":"","text":"从hello的例子可以可以看出来，当shell加载运行包括最后输出的时候，shell和hello都没有直接对硬件进行访问(包括键盘，显示器，主存或者磁盘)。取而代之的是，他们依靠操作系统提供的服务。我们可以把操作系统看成是应用程序和硬件之间插入的一层软件。所有应用程序对硬件的操作尝试都必须通过操作系统操作系统有两个基本功能， 防止硬件被失控的应用程序滥用 向应用程序提供简单一致的机制来控制复杂而又通常大不相同的低级硬件设备。 操作系统通过几个基本的抽象概念(进程、虚拟内存和文件)来实现这两个功能，如下图所示，文件是对I&#x2F;O设备的抽象表示，虚拟内存是对主存和磁盘I&#x2F;O设备的抽象表示，进程则是对处理器、主存和I&#x2F;O设备的抽象表示 1.7.1 进程像hello这样的程序在现代系统上运行时，操作系统会提供一种假象，就像系统上只有这个程序在运行。程序看上去是独占地只用处理器、主存和I&#x2F;O设备。处理器看上去就像在不间断的一条接一条地执行程序中的指令，即该程序的代码和数据是系统内存中唯一的对象。这些假象是通过进程的概念来实现的，进程是计算机科学中最重要和最成功的概念之一。 进程是操作系统对一个正在运行的程序的一种抽象。在一个系统上可以同时运行多个进程，而每个进程都好像在独占的使用硬件。而并发运行，则是说一个进程的指令和另一个进程的指令是交错执行的。在大多数系统中，需要运行的进程数是多于可以运行它们的CPU个数的。传统系统在一个时刻只能执行一个程序，而先进的多核处理器同时能够执行多个程序。无论是在单核还是多核系统中，一个CPU看上去都像是在并发地执行多个进程，这是通过处理器在进程间切换来实现的。操作系统实现这种操作执行的机制称为上下文交换。为了简化讨论，我们只考虑包含一个CPU的单处理器系统的情况。后面还会讨论 操作系统保持跟踪进程运行所需的所有状态信息。这种状态，也就是上下文，包括许多信息，比如PC和寄存器文件的当前值，以及主存的内容。在任何一个时刻，单处理器系统都只能执行一个进程的代码。当操作系统决定要把控制权从当前进程转移到某个新进程时，就会进行上下文切换，即保存当前进程的上下文、恢复新进程的上下文，然后将控制权传递到新进程。新进程就会从它上次停止的地方开始。那么hello程序运行场景的基本理念看下面。![[https://hansimov.gitbook.io/~gitbook/image?url=https:%2F%2F4154149387-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-legacy-files%2Fo%2Fassets%252F-MHt_spaxGgCbp2POnfq%252F-MHzietxOnE2XCBTZHJ7%252F-MHziqrI26zhGJA9_NLL%252F01-12%2520%25E8%25BF%259B%25E7%25A8%258B%25E7%259A%2584%25E4%25B8%258A%25E4%25B8%258B%25E6%2596%2587%25E5%2588%2587%25E6%258D%25A2.png%3Falt=media%26token=5df4420b-e3c7-46ca-8192-ba207aa49f15&amp;width=400&amp;dpr=3&amp;quality=100&amp;sign=7323c7a530eb087f04ecfa52db5f03b77529e0c73a5744a490b2389fecb6b30ehttps://hansimov.gitbook.io/~gitbook/image?url=https:%2F%2F4154149387-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-legacy-files%2Fo%2Fassets%252F-MHt_spaxGgCbp2POnfq%252F-MHzietxOnE2XCBTZHJ7%252F-MHziqrI26zhGJA9_NLL%252F01-12%2520%25E8%25BF%259B%25E7%25A8%258B%25E7%259A%2584%25E4%25B8%258A%25E4%25B8%258B%25E6%2596%2587%25E5%2588%2587%25E6%258D%25A2.png%3Falt=media%26token=5df4420b-e3c7-46ca-8192-ba207aa49f15&amp;width=400&amp;dpr=3&amp;quality=100&amp;sign=7323c7a530eb087f04ecfa52db5f03b77529e0c73a5744a490b2389fecb6b30e]] 实例当中有两个并发的进程：shell和hello。最开始，只有shell进程在运行，也就是等待命令行上的输入。当我们让他运行hello程序时，shell通过一个专门的函数，也就是系统调用，来执行我们的请求，系统调用会将控制权传递给操作系统。操作系统保存shell进程的上下文，创建一个新的hello进程及其上下文，并将控制权传回给它，shell进程会继续等待下一个命令行输入。 如图所示，从一个进程到另一个进程的转换是由操作系统内核(kernel) 管理的。内核是操作系统代码常驻主存的部分。当应用程序需要操作系统的某些操作时，比如读写文件，它就执行一条特殊的系统调用(system call) 指令，将控制权传递给内核。然后内核执行被请求的操作并返回应用程序。注意，内核不是一个独立的进程。相反，它是系统管理全部进程所用代码和数据结构的集合。 实现进程这个抽象概念需要低级硬件和操作系统软件之间的紧密合作。 1.7.2 线程尽管通常我们认为一个进程只有单一的控制流，但是在现在系统中，一个进程实际上可以由多个称为线程的执行单元组成，每个线程都运行在进程的上下文中，并共享的代码和全局数据。由于网络服务器中对并行处理的需求，线程称为越来越重要的编程模型，因为多线程之间比多进程之间更容易共享数据，也因为线程一般来说都比进程更高效。当有多处理器可用的时候，多线程也是一种使得程序可以运行得更快的方法，我们将在后面讨论 1.7.3 虚拟内存虚拟内存是一个抽象概念，它为每一个进程提供了一个假象，即每个进程都在独占地使用主存。每个进程看到的内存都是一致的，称为虚拟地址空间。下图所示的Linux进程的虚拟地址空间(其他Unix系统的设计也与此类似)。在Linux中，地址空间最上面的区域是保留给操作系统中的代码和数据的，这对所有进程来说都一样。地址空间的底部区域存放用户进程定义的代码和数据。图中的地址是从下往上增大的。每个进程看到的虚拟地址空间由大量准确定义的区构成，每个区都有专门的功能。先做简单的了解，逐步向上介绍 程序代码和数据：对所有的进程来说，代码是从同一固定地址开始，紧接着的是C全局变量相对应的数据位置。代码和数据区是直接按照可执行目标文件的内容初始化的，在示例中就是可执行文件hello。 堆：代码和数据区后紧随的是运行时堆。代码和数据区在进程一开始运行时就被指定了大小，与此不同，当调用像malloc和free这样的C标准库函数的时候，堆可以在运行时动态地扩展和收缩。 共享库：大约在地址空间的中间部分是一块用来存放像C标准库和数学库这样的共享库的代码和数据的区域。共享库的概念非常强大，也相当难懂。 栈：位于用户虚拟地址空间顶部的是用户栈，编译器用它来实现函数调用。和堆一样，用户栈在程序执行期间可以动态地扩展和收缩。特别的，每次我们调用一个函数时，栈就会增长；从一个函数返回时，栈就会收缩。 内核虚拟内存：地址空间顶部的区域是为内核保留的。不允许应用程序读写这个区域的内容或者直接调用内核代码定义的函数。相反，它们必须调用内核来执行这些操作。 虚拟内存的运作需要硬件和操作系统软件之间精密复杂的交互，包括对处理器生成的每个地址的硬件翻译。基本思想是把一个进程虚拟内存存储在磁盘上，然后用主存作为磁盘的高速缓存。 1.7.4 文件文件就是字节序列，仅此而已。每个I&#x2F;O设备，包括磁盘、键盘、显示器甚至网络，都可以看成是文件。系统中的所有输入输出都是通过使用一小组称为Unix I&#x2F;O的系统调用读写文件来实现的。 文件这个简单而精致的概念是十分强大的，因为它向应用程序提供了一个统一的视图，来看待系统中可能含有的所有各式各样的I&#x2F;O设备。例如，处理磁盘文件内容的应用程序员可以非常幸福，因为他们无需了解具体的磁盘技术。进一步说，同一个程序可以在使用不同磁盘技术的不同系统上运行。","categories":[{"name":"CSAPP","slug":"CSAPP","permalink":"https://primeluoqiu.github.io/categories/CSAPP/"}],"tags":[],"keywords":[{"name":"CSAPP","slug":"CSAPP","permalink":"https://primeluoqiu.github.io/categories/CSAPP/"}]},{"title":"CSAPP Chapter1.6 存储设备形成也是有结构的","slug":"CSAPP/第一章/1.6存储设备形成层次结构","date":"2024-03-24T02:51:49.634Z","updated":"2024-03-24T02:40:48.774Z","comments":true,"path":"2024/03/24/CSAPP/第一章/1.6存储设备形成层次结构/","link":"","permalink":"https://primeluoqiu.github.io/2024/03/24/CSAPP/%E7%AC%AC%E4%B8%80%E7%AB%A0/1.6%E5%AD%98%E5%82%A8%E8%AE%BE%E5%A4%87%E5%BD%A2%E6%88%90%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/","excerpt":"","text":"也就是说，在处理器中和一个较大较慢的设备(例如主存)之间插入要给更小更快的存储设备(例如高缓)的想法已经成为一个普遍的观念。实际上，每个计算机中的存储设备都被组织成了一个存储器层次结构，如图所示![[https://hansimov.gitbook.io/~gitbook/image?url=https:%2F%2F4154149387-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-legacy-files%2Fo%2Fassets%252F-MHt_spaxGgCbp2POnfq%252F-MHzhX2vrq6mFP3tN9EU%252F-MHzi1Edm9hUsnQdAkkL%252F01-09%2520%25E4%25B8%2580%25E4%25B8%25AA%25E5%25AD%2598%25E5%2582%25A8%25E5%2599%25A8%25E5%25B1%2582%25E6%25AC%25A1%25E7%25BB%2593%25E6%259E%2584%25E7%259A%2584%25E7%25A4%25BA%25E4%25BE%258B.png%3Falt=media%26token=afb8208e-17dc-475f-9f61-acf0bd0ca891&amp;width=400&amp;dpr=3&amp;quality=100&amp;sign=17fc4e7af9f4033010d24045648add7168e149dc6885e9e1a1730033b06fd7f2]] 在这个层次结构中，从上到下，设备之间的访问速度越来越慢，容量越来越大，并且每字节的造价也越来越低。寄存器文件在层次结构中位于最顶层，也就是第0级或者L0，主存在第4存… 存储器层次结构的主要思想是上一层的存储器作为低一层存储器的高速缓存。因此寄存器文件就是L1的高速缓存，L1是L2的高速缓存..在某些具有分布式文件系统的网络系统中，本地磁盘就是存储在其他系统中磁盘上的数据的高速缓存。正如可以运用不同的高速缓存的知识来提高程序性能一样，程序员同样可以利用对整个存储器层次结构的理解来提高程序性能。","categories":[{"name":"CSAPP","slug":"CSAPP","permalink":"https://primeluoqiu.github.io/categories/CSAPP/"}],"tags":[],"keywords":[{"name":"CSAPP","slug":"CSAPP","permalink":"https://primeluoqiu.github.io/categories/CSAPP/"}]},{"title":"CSAPP Chapter1.5 多来点高速缓存嘛","slug":"CSAPP/第一章/1.5高速缓存至关重要","date":"2024-03-24T02:51:49.633Z","updated":"2024-03-24T02:40:19.983Z","comments":true,"path":"2024/03/24/CSAPP/第一章/1.5高速缓存至关重要/","link":"","permalink":"https://primeluoqiu.github.io/2024/03/24/CSAPP/%E7%AC%AC%E4%B8%80%E7%AB%A0/1.5%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E8%87%B3%E5%85%B3%E9%87%8D%E8%A6%81/","excerpt":"","text":"上述简单的运行过程中，我们不难发现系统花费了大量的时间把信息从一个地方挪到另一个地方。例如hello最初放在磁盘上，当程序加载的时候，被复制到主存，最后从主存上复制到显示设备。复制总是需要随时间的。这些复制就是开销，所以系统设计者的一个主要目标就是使这些复制操作尽可能快的完成。 根据机械原理，较大的存储设备要比比较小的存储设备运行的慢，而快速设备的造价远高于同类的低速设备，比如说，一个典型系统上的磁盘驱动器可能比主存大1000倍，但是对处理器而言，从磁盘驱动器上读取一个字的时间开销要比从主存中的开销大1000万倍。 类似得，一个典型的寄存器文件只存储几百byte的信息，而主存里面可以存放几十亿字节。然而，处理器从寄存器文件中读数据比从主存中读取几乎要快100倍，而且随着半导体技术的进步，处理器和主存之间的差距还在增大。加快处理器的运行速度比加快主存的运行速度要容易和便宜得多。针对这种处理器和主存之间的差异，系统设计者就采用了更小更快的存储设备，称为高速缓存存储器(cache memory, 简称cache或高速缓存)，作为暂时的集结区域，存放处理器近期可能需要的信息。这是一个典型系统中的高速缓存存储器，位于CPU上的L1高速缓存的荣富良可以达到数万字节。访问速度几乎和访问寄存器文件一样快。一个容量为数十万到百万字节的更大的L2告诉换曾黁通过一条特殊的总线连接到CPU。 进程访问L2高速缓存的时间要比访问L1告诉换从的时间长5倍，但是这仍然比访问主存的时间快5-10倍。L1和L2告诉换从使用一种叫做静态随机访问存储器的硬件技术实现的。比较新的，处理能力更强大的系统甚至有三级高速缓存：L1、L2、L3.系统可以获得一个很大的存储器，同时访问速度也很快，原因是利用了高速缓存的局部性原理，即程序具有访问局部区域里的数据和代码的趋势。通过让高速缓存里存放可能经常访问的数据，大部分的内存操作都能在快速的高速缓存中完成。![[Pasted image 20240318151738.png]] 本书得出的重要结论之一就是，意识到高速缓存存储器存在的应用程序员能够利用高速缓存将程序的的性能提升一个数量级。","categories":[{"name":"CSAPP","slug":"CSAPP","permalink":"https://primeluoqiu.github.io/categories/CSAPP/"}],"tags":[],"keywords":[{"name":"CSAPP","slug":"CSAPP","permalink":"https://primeluoqiu.github.io/categories/CSAPP/"}]},{"title":"CSAPP Chapter1.3 处理器是干嘛的","slug":"CSAPP/第一章/1.4处理器读并解释储存在内存中的指令","date":"2024-03-24T02:51:49.632Z","updated":"2024-03-24T02:39:50.330Z","comments":true,"path":"2024/03/24/CSAPP/第一章/1.4处理器读并解释储存在内存中的指令/","link":"","permalink":"https://primeluoqiu.github.io/2024/03/24/CSAPP/%E7%AC%AC%E4%B8%80%E7%AB%A0/1.4%E5%A4%84%E7%90%86%E5%99%A8%E8%AF%BB%E5%B9%B6%E8%A7%A3%E9%87%8A%E5%82%A8%E5%AD%98%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E6%8C%87%E4%BB%A4/","excerpt":"","text":"在我们创建完hello的可执行文件之后，用shell运行如下 123linux &gt; ./hellohello, worldlinux &gt; shell是一个命令行解释器，它输出一个提示符，然后等待一个命令行，执行这个命令。如果命令行第一个单词不是一个内置的指令，那么它就会假设这是一个可执行文件的名字，它将加载并运行这个文件。此例中，加载运行了hello，然后等待程序终止，输出消息，然后终止。然后输出一个提示符，等待下一个输入。 1.4.1 系统的硬件组成1.总线也就贯穿整个系统的一组电子管道。携带信息字节并在各个部件间传递。通常总线被设计成传送定长的字节块，也就是字。字中的字节数（即字长）是一个基本的系统参数，各个系统中都不尽相同。现在的的大多数机器字长是4或8字节32&#x2F;64位。 2.I&#x2F;O设备这是系统和外部世界的联系通道。示例系统包括四个I&#x2F;O设备：作为用户输入的键盘和鼠标，作为用户输出的显示器，以及用于长期存储数据和程序的磁盘驱动器。最开始的hello就存放在磁盘上。 每个I&#x2F;O都通过以一个控制器或适配器与I&#x2F;O总线相连。控制器和适配器之间的的区别而在于他们的封装方式。控制器是I&#x2F;O设备本身或者系统的主印制电路板(主板)上的芯片组。而适配器是一块插在主板插槽上的卡。这些设备的功能都是在I&#x2F;O总线和I&#x2F;O设备之间传递信息· 1ALU:算数/逻辑单元 PC：程序计数器 USB：通用串行总线 3.主存主存是一个临时存储设备，在处理器执行程序时，用来存放程序和程序处理的数据。从物理上来说，主存是由一组动态随机存储器(DRAM) 芯片组成的。从逻辑上来说，存储器是一个线性的字节数组，每个字节都有其唯一的地址(数组索引)，这些地址是从零开始的。一般来说，组成程序的每条机器指令都由不同数量的字节构成。一般来说，组成程序的每条机器指令都有不同数量的字节构成。与C程序变量相对应的数据项大小是根据类型变化的。 4.处理器中央处理单元(CPU),简称处理器，是解释(或执行)存储在主存中指令的引擎。处理器的核心是一个大小为一个字的存储设备(或寄存器) ，称为程序计数器&#x2F;指令计数器(PC)。在任何时刻，PC都指向主存中某条机器语言指令(即含有该条指令的地址) 从系统通电开始到断电，处理器一直在不断地执行程序计数器指向的指令，再更新程序计数器，使其指向下一条指令。处理器看上去是按照一个非常简单的指令执行模型来操作的，这个模型是由指令集架构(Arm, x86,)决定的。在这个模型中，指令按照严格的顺序执行，而执行一条指令包含执行一系列的步骤。处理器从程序计数器指向的内存处读取指令，解释指令中的位，执行该指令指示的简单操作，然后更新PC，使其指向下一条指令，而这条指令并不一定和在内存中刚刚执行的指令相邻。 这样的简单操作并不多，它们围绕着主存、寄存器文件和算数&#x2F;逻辑单元进行。寄存器文件是个小的存储设备，由一些单个字长的寄存器组成，每个寄存器都有唯一的名字。ALU计算新的数据和地址值。下面是一些简单操作的例子，CPU在指令的要求下可能会执行这些操作 加载：从主存复制一个字节或者一个字到寄存器，以覆盖寄存器原来的内容。 存储：从寄存器复制一个字节或者一个字到主存的某个位置，以覆盖这个位置上原有的内容 操作：把两个寄存器的内容复制到ALU，ALU对这两个字做算术运算，并将结果存放到一个寄存器中，以覆盖该寄存器中原来的内容 跳转：从指令本身中抽取一个字，并将这个字复制到PC中，以覆盖PC中原来的值 处理器看上去是它的指令集架构的简单实现，但是实际上现代处理器使用了非常复杂的机制来加速程序的执行。因此，我们将处理器的指令集架构和处理器的微体系结构区分开来：指令集架构描述的是每条机器代码指令的效果；而微体系结构描述的是处理器实际上是如何实现的。 1.4.2运行Hello程序目前先暂时省略一些细节。 起初，shell程序执行它的指令，等待我们输入一个命令。当我们在键盘上输入字符串”.&#x2F;hello”后，shell程序将字符逐一读入寄存器，再把它存放到内存中。如下图所示 当我们在键盘上敲回车键之后，shell程序就知道我们已经结束了命令的输入，然后shell执行一系列指令来加载可执行的hello文件，这些指令将hello目标文件中的代码和数据从磁盘复制到主存。数据包括最后会被输出的字符串”hello, world\\n” 利用直接存储器存取(DMA)技术，数据可以不通过处理器而直接从磁盘到达主存。这个步骤如下图所示![[https://hansimov.gitbook.io/~gitbook/image?url=https:%2F%2F4154149387-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-legacy-files%2Fo%2Fassets%252F-MHt_spaxGgCbp2POnfq%252F-MHzfLHp5XFUFTsUJAKx%252F-MHzfN_gwQJSG2YnC5Gk%252F01-06%2520%25E4%25BB%258E%25E7%25A3%2581%25E7%259B%2598%25E5%258A%25A0%25E8%25BD%25BD%25E5%258F%25AF%25E6%2589%25A7%25E8%25A1%258C%25E6%2596%2587%25E4%25BB%25B6%25E5%2588%25B0%25E4%25B8%25BB%25E5%25AD%2598.png%3Falt=media%26token=9a49507e-f20d-4af8-b277-bebf57cc597f&amp;width=400&amp;dpr=3&amp;quality=100&amp;sign=74b6cf3ac9a458f0c5b3b6cbc5920a9cd3dcc59d6250e0badd63c26859b486f3]] 一旦目标文件hello中的代码和数据被加载到主存，处理器就开始执行hello程序的main程序中的机器语言指令。这些指令将”Hello,world\\n”字符串中的字节从主存复制到寄存器文件，再从寄存器文件中复制到显示设备，最终显示在屏幕上。步骤如下所示![[https://hansimov.gitbook.io/~gitbook/image?url=https:%2F%2F4154149387-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-legacy-files%2Fo%2Fassets%252F-MHt_spaxGgCbp2POnfq%252F-MHzfVZwd5iIwJfDkOPj%252F-MHzffvOB90toXVTON5G%252F01-07%2520%25E5%25B0%2586%25E8%25BE%2593%25E5%2587%25BA%25E5%25AD%2597%25E7%25AC%25A6%25E4%25B8%25B2%25E4%25BB%258E%25E5%25AD%2598%25E5%2582%25A8%25E5%2599%25A8%25E5%2586%2599%25E5%2588%25B0%25E6%2598%25BE%25E7%25A4%25BA%25E5%2599%25A8.png%3Falt=media%26token=d0480c36-9640-4159-bc71-8f5db262a6ba&amp;width=400&amp;dpr=3&amp;quality=100&amp;sign=a45f19ed618ab752f842b7f269e3b6411ec8fa6f81166c73190f0156510d0c4a]]","categories":[{"name":"CSAPP","slug":"CSAPP","permalink":"https://primeluoqiu.github.io/categories/CSAPP/"}],"tags":[],"keywords":[{"name":"CSAPP","slug":"CSAPP","permalink":"https://primeluoqiu.github.io/categories/CSAPP/"}]},{"title":"CSAPP Chapter1.3 了解编译系统如何工作是大有益处的","slug":"CSAPP/第一章/1.3了解编译系统如何工作是大有益处的","date":"2024-03-24T02:51:49.631Z","updated":"2024-03-24T02:25:47.980Z","comments":true,"path":"2024/03/24/CSAPP/第一章/1.3了解编译系统如何工作是大有益处的/","link":"","permalink":"https://primeluoqiu.github.io/2024/03/24/CSAPP/%E7%AC%AC%E4%B8%80%E7%AB%A0/1.3%E4%BA%86%E8%A7%A3%E7%BC%96%E8%AF%91%E7%B3%BB%E7%BB%9F%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E6%98%AF%E5%A4%A7%E6%9C%89%E7%9B%8A%E5%A4%84%E7%9A%84/","excerpt":"","text":"益处大致有三点 优化程序性能。尽管已经无需为了写出高效代码而了解编译器的内部工作。不过为了在C中做出更好对的编码选择，我们确实需要了解一些机器代码以及编译器将不同的C转化成机器代码的方式。例如在C语言程序中有if-else和switch两种语句。那么这两种哪个更高效呢，while和for之间哪个更有效呢？这些都是可以得到了解的 理解链接时出现的错误。根据经验来讲，一些令人困扰的程序错误往往都与链接器操作有关，尤其是试图构建大型的软件系统时。例如链接器报告说无法解析一个引用，这是什么意思？静态变量和全局变量的区别是什么等一系列问题 避免安全漏洞。多年来，缓冲区溢出错误时造成大多数网络和Internet服务器上安全漏洞的主要原因。存在这些错误是因为很少有程序员能够理解需要限制从不受信任的源接受数据的数量和格式。 学习安全编程的第一步就是理解数据和控制信息存储在程序栈上的方式会引起的后果。等","categories":[{"name":"CSAPP","slug":"CSAPP","permalink":"https://primeluoqiu.github.io/categories/CSAPP/"}],"tags":[],"keywords":[{"name":"CSAPP","slug":"CSAPP","permalink":"https://primeluoqiu.github.io/categories/CSAPP/"}]},{"title":"CSAPP Chapter1.2 程序被其他程序翻译成不同的格式","slug":"CSAPP/第一章/1.2程序被其他程序翻译成不同的格式","date":"2024-03-24T02:51:49.630Z","updated":"2024-03-24T02:36:29.315Z","comments":true,"path":"2024/03/24/CSAPP/第一章/1.2程序被其他程序翻译成不同的格式/","link":"","permalink":"https://primeluoqiu.github.io/2024/03/24/CSAPP/%E7%AC%AC%E4%B8%80%E7%AB%A0/1.2%E7%A8%8B%E5%BA%8F%E8%A2%AB%E5%85%B6%E4%BB%96%E7%A8%8B%E5%BA%8F%E7%BF%BB%E8%AF%91%E6%88%90%E4%B8%8D%E5%90%8C%E7%9A%84%E6%A0%BC%E5%BC%8F/","excerpt":"","text":"为了在系统上运行Hello.c程序，每条C语句必须被其他程序转化成一系列的低级机器语言指令。然后这些指令按照一种称为可执行程序的格式打好包，并以二进制磁盘文件的形式存放起来。目标程序也成为可执行目标文件 高级语言 -&gt; 低级指令 -&gt; 指令打包并以二进制文件存放。 ![[https://hansimov.gitbook.io/~gitbook/image?url=https:%2F%2F4154149387-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-legacy-files%2Fo%2Fassets%252F-MHt_spaxGgCbp2POnfq%252F-MHzZfEIY91yIzOD0Rce%252F-MHzZpZI-gs8CNcwHIyv%252F01-03%2520compilation%2520systems.png%3Falt=media%26token=91ca688e-1cfc-4ec6-8b99-d52e672bbac7&amp;width=400&amp;dpr=3&amp;quality=100&amp;sign=ad2978e04a286ea0e07b7bbfb5d2a96b78a69a9b23614f1df17e662f4615f344]] 预处理阶段，通过以字符#开头的命令，修改原始程序。如#include&lt;iostream&gt;命令就是告诉预处理器读取系统头文件stdio.h的内容，然后直接插入程序文本中。然后得到了另一个C程序，通常以.i作为文件扩展名。 编译阶段：通过编译器将文本文件翻译成hello.s，也就是汇编语言程序，该程序包含main的定义1234567main: subq $8, %rsp movl $.LC0, %edi call puts movl $0, %eax addq $8, %rsp ret 2-7行每条都以一种文本格式描述了一条低级语言指令。(汇编语言为所有不同高级语言的不同编译器提供了通用的输出语言) 汇编阶段；通过汇编器将hello.s翻译成机器语言指令。把这些指令打包成可重定位目标程序。并保存到hello.o中(这是一个二进制文件)，里面包含的是main的指令代码。 链接阶段：hello程序调用了printf函数，是标准C库中的一个函数。函数存在于一个名为printf.o的单独的预编译好了的目标文件中，而这个文件必须以某种方式合并到hello.c的程序中，链接器负责合并，结果得到hello文件，是一个可执行文件。可以被加载到内存中，由系统执行。也就是说，一个C程序都是先从预处理阶段开始的，先读取头文件然后插入程序中，然后通过编译器翻译成汇编语言，再通过汇编器翻译成机器语言指令生成hello.o，接下来引入在hello中调用的printf函数，而该函数存在于一个单独编译好的目标文件printf.o中，然后连接器负责合并这两个.o的目标文件，然后最后得出一个可执行文件。","categories":[{"name":"CSAPP","slug":"CSAPP","permalink":"https://primeluoqiu.github.io/categories/CSAPP/"}],"tags":[],"keywords":[{"name":"CSAPP","slug":"CSAPP","permalink":"https://primeluoqiu.github.io/categories/CSAPP/"}]},{"title":"CSAPP Chapter1.1 信息就是位+上下文","slug":"CSAPP/第一章/1.1信息就是位+上下文","date":"2024-03-24T02:51:49.625Z","updated":"2024-03-24T02:25:25.510Z","comments":true,"path":"2024/03/24/CSAPP/第一章/1.1信息就是位+上下文/","link":"","permalink":"https://primeluoqiu.github.io/2024/03/24/CSAPP/%E7%AC%AC%E4%B8%80%E7%AB%A0/1.1%E4%BF%A1%E6%81%AF%E5%B0%B1%E6%98%AF%E4%BD%8D+%E4%B8%8A%E4%B8%8B%E6%96%87/","excerpt":"","text":"第一节：信息就是位＋上下文我们在创建第一个hello.c的时候，这些文件都是由ASCII码组成的，也就是用一个唯一的单字节大小的值来表示每个字符。而只由ASCII字符构成的文件成为文本文件，其他的文件被称为二进制文件。 这件事说明了一个基本思想：系统中所有的信息都是由一串bit表示的。区分不同数据对象的唯一方法是我们读到这些数据对象时的上下文。例如在不同的上下文中，一个同样的字节序列可能表示一个整数、浮点数、字符串、机器指令。","categories":[{"name":"CSAPP","slug":"CSAPP","permalink":"https://primeluoqiu.github.io/categories/CSAPP/"}],"tags":[],"keywords":[{"name":"CSAPP","slug":"CSAPP","permalink":"https://primeluoqiu.github.io/categories/CSAPP/"}]},{"title":"模拟堆","slug":"Algorithm/duiyouhua","date":"2024-03-23T14:13:09.233Z","updated":"2024-03-23T14:14:47.893Z","comments":true,"path":"2024/03/23/Algorithm/duiyouhua/","link":"","permalink":"https://primeluoqiu.github.io/2024/03/23/Algorithm/duiyouhua/","excerpt":"","text":"模拟堆接下来看模拟堆，模拟堆比起之前就是多了两个数组，这两个数组属于互为反函数的类型。例如 hp[k] = j那么ph[j] = k，一个是对应着在堆里的下标，另一个对应的是下标对应的值。 那么对应的，在进行交换的时候，就不能只考虑值之间的交换了，就还得考虑数组之间的交换。这个时候，就需要一个全新的函数了 因为题目中要考虑第k个数，那么就需要两个数组来存储第k个数是什么ph[k]存的是第k个插入的数在堆里的下标是什么,还需要一个hp[k],用来存的是堆的某个点是第几个插入的点。 123456void swap_head(int a, int b) &#123; swap(ph[hp[a]], ph[hp[b]]); swap(hp[a], hp[b]); swap(a, b); &#125; 然后就是把所有的swap函数进行更换为堆里面特有的swap。这个方法不常用，但是djikstra堆优化是常用的，所以要了解一下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string.h&gt;using namespace std;const int N = 100010;int n, m, a, b;int h[N], cnt, ph[N], hp[N];void heap_swap(int a, int b)&#123; swap(ph[hp[a]], ph[hp[b]]); swap(hp[a], hp[b]); swap(h[a], h[b]);&#125;void down(int u)&#123; int t = u; if(u * 2 &lt;= cnt &amp;&amp; h[u * 2] &lt; h[t]) t = u * 2; if(u * 2 + 1 &lt;= cnt &amp;&amp; h[u * 2 + 1] &lt; h[t]) t = u * 2 + 1; if(u != t) &#123; heap_swap(u, t); down(t); &#125;&#125;void up(int u)&#123; while(u / 2 &amp;&amp; h[u / 2] &gt; h[u]) &#123; heap_swap(u, u / 2); u &gt;&gt;= 1; &#125;&#125;int main()&#123; int n, m = 0; cin &gt;&gt; n; while(n --) &#123; char op[10]; int k, x; scanf(&quot;%s&quot;, op); if(!strcmp(op, &quot;I&quot;)) &#123; scanf(&quot;%d&quot;, &amp;x); cnt ++; m ++; ph[m] = cnt, hp[cnt] = m; h[cnt] = x; up(cnt); &#125; else if(!strcmp(op, &quot;PM&quot;)) printf(&quot;%d\\n&quot;, h[1]); else if(!strcmp(op, &quot;DM&quot;)) &#123; heap_swap(1, cnt); cnt --; down(1); &#125; else if(!strcmp(op, &quot;D&quot;)) &#123; scanf(&quot;%d&quot;, &amp;k); k = ph[k]; heap_swap(k, cnt); cnt --; down(k), up(k); &#125; else &#123; scanf(&quot;%d%d&quot;, &amp;k, &amp;x); k = ph[k], h[k] = x; down(k), up(k); &#125; &#125; return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://primeluoqiu.github.io/categories/Algorithm/"}],"tags":[],"keywords":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://primeluoqiu.github.io/categories/Algorithm/"}]},{"title":"1.6分组延时、丢失和吞吐量","slug":"计算机网络/1.6","date":"2024-03-23T06:21:33.296Z","updated":"2024-03-23T12:46:00.036Z","comments":true,"path":"2024/03/23/计算机网络/1.6/","link":"","permalink":"https://primeluoqiu.github.io/2024/03/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.6/","excerpt":"","text":"","categories":[{"name":"计网","slug":"计网","permalink":"https://primeluoqiu.github.io/categories/%E8%AE%A1%E7%BD%91/"}],"tags":[],"keywords":[{"name":"计网","slug":"计网","permalink":"https://primeluoqiu.github.io/categories/%E8%AE%A1%E7%BD%91/"}]},{"title":"1.5Internet结构和ISP","slug":"计算机网络/1.5","date":"2024-03-23T06:21:32.774Z","updated":"2024-03-23T06:28:30.826Z","comments":true,"path":"2024/03/23/计算机网络/1.5/","link":"","permalink":"https://primeluoqiu.github.io/2024/03/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.5/","excerpt":"","text":"","categories":[{"name":"计网","slug":"计网","permalink":"https://primeluoqiu.github.io/categories/%E8%AE%A1%E7%BD%91/"}],"tags":[],"keywords":[{"name":"计网","slug":"计网","permalink":"https://primeluoqiu.github.io/categories/%E8%AE%A1%E7%BD%91/"}]},{"title":"1.4接入网和网络媒体","slug":"计算机网络/1.4","date":"2024-03-23T06:21:32.245Z","updated":"2024-03-23T06:28:32.286Z","comments":true,"path":"2024/03/23/计算机网络/1.4/","link":"","permalink":"https://primeluoqiu.github.io/2024/03/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.4/","excerpt":"","text":"","categories":[{"name":"计网","slug":"计网","permalink":"https://primeluoqiu.github.io/categories/%E8%AE%A1%E7%BD%91/"}],"tags":[],"keywords":[{"name":"计网","slug":"计网","permalink":"https://primeluoqiu.github.io/categories/%E8%AE%A1%E7%BD%91/"}]},{"title":"1.3网络核心","slug":"计算机网络/1.3","date":"2024-03-23T06:21:31.662Z","updated":"2024-03-23T06:28:32.926Z","comments":true,"path":"2024/03/23/计算机网络/1.3/","link":"","permalink":"https://primeluoqiu.github.io/2024/03/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.3/","excerpt":"","text":"","categories":[{"name":"计网","slug":"计网","permalink":"https://primeluoqiu.github.io/categories/%E8%AE%A1%E7%BD%91/"}],"tags":[],"keywords":[{"name":"计网","slug":"计网","permalink":"https://primeluoqiu.github.io/categories/%E8%AE%A1%E7%BD%91/"}]},{"title":"1.2网络边缘","slug":"计算机网络/1.2","date":"2024-03-23T06:21:30.368Z","updated":"2024-03-23T06:28:33.782Z","comments":true,"path":"2024/03/23/计算机网络/1.2/","link":"","permalink":"https://primeluoqiu.github.io/2024/03/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.2/","excerpt":"","text":"","categories":[{"name":"计网","slug":"计网","permalink":"https://primeluoqiu.github.io/categories/%E8%AE%A1%E7%BD%91/"}],"tags":[],"keywords":[{"name":"计网","slug":"计网","permalink":"https://primeluoqiu.github.io/categories/%E8%AE%A1%E7%BD%91/"}]},{"title":"1.1什么是Internet","slug":"计算机网络/1.1什么是Internet","date":"2024-03-23T06:15:09.395Z","updated":"2024-03-23T06:28:38.121Z","comments":true,"path":"2024/03/23/计算机网络/1.1什么是Internet/","link":"","permalink":"https://primeluoqiu.github.io/2024/03/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.1%E4%BB%80%E4%B9%88%E6%98%AFInternet/","excerpt":"","text":"","categories":[{"name":"计网","slug":"计网","permalink":"https://primeluoqiu.github.io/categories/%E8%AE%A1%E7%BD%91/"}],"tags":[],"keywords":[{"name":"计网","slug":"计网","permalink":"https://primeluoqiu.github.io/categories/%E8%AE%A1%E7%BD%91/"}]},{"title":"CS61A.Chapter1","slug":"ClassesFormUCBerkely/CS61A/第一章：使用函数构造抽象","date":"2024-03-22T16:54:16.698Z","updated":"2024-03-23T12:51:07.757Z","comments":true,"path":"2024/03/23/ClassesFormUCBerkely/CS61A/第一章：使用函数构造抽象/","link":"","permalink":"https://primeluoqiu.github.io/2024/03/23/ClassesFormUCBerkely/CS61A/%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0%E6%9E%84%E9%80%A0%E6%8A%BD%E8%B1%A1/","excerpt":"","text":"之所以计算机科学的巨大生产力能够成为可能，都是因为其建立在一套优雅而强大的基本思想之上。所有计算都始于三点：信息的表示、处理的逻辑、设计抽象来管理逻辑的复杂性，掌握这些基础知识需要我们去精确理解计算机程序的构造和解释。 1.1.4 第一个例子Python内置了一些常见编程功能，例如处理文本，显示图形以及通过互联网进行通信。下面这行Python代码 1&gt;&gt;&gt; from urlib.request import urlopen 是一个import语句，它会导入一个用于”访问互联网数据”的功能，该功能特别提供了一个名为urlopen的函数，可以访问URL上的内容 语句和表达式Python代码由表达式和语句组成，从广义上讲，计算机程序由一下指令组成 计算一些值 执行一些操作语句通常描述操作，Python解释器每执行一条语句，计算机就会执行相应的操作。另外，表达式通常用于描述计算，当Python计算一个表达式时，它会计算出该式的值。 下面的赋值语句 1shakespeare = urlopen(&#x27;https://www.composingprograms.com/shakespeare.txt&#x27;) 将名称shakespeare与=后面的表达式的值相连，这个表达式将urlopen函数应用在了一个URL身上。 函数: 函数封装了操作数据的逻辑。urlopen就是一个函数，而网址是一个数据，莎士比亚的戏剧是另一个数据。从前者到后者的准换过程可能会很复杂，但我们可以将这种复杂性隐藏在一个函数中，从而能够使用一个简单的表达式来跳过该过程。函数是本章的主题 另一个赋值语句 1&gt;&gt;&gt; words = set(shakespare.read().decode().split()) 将words与莎士比亚戏剧中出现的共33721个单词的集合相连。其命令链调用了read、decode、split，每个函数都会操作一个中间的计算实体：从URL中read(读取)数据，然后将数据decode(解码)为文本，最后将文本split(拆分)为单词放在一个set中。 对象:set就是一种对象，支持如计算交际和集合关系(membership)等计算。对象无缝整合了数据以及用于操作该数据的逻辑，并隐藏了二者的复杂性对象是第二章的主题 最后，这个表达式 12&gt;&gt;&gt; &#123;w for w in words if len(W) == 6 and w[::1] in words&#125; &#123;&#x27;redder&#x27;, &#x27;drawer&#x27;, &#x27;reward&#x27;, &#x27;diaper&#x27;, &#x27;repaid&#x27;&#125; 是一个符合表达式，它的计算结果是反向拼写同时也为单词的莎士比亚单词集合。神秘符号w[::-1]表示枚举单词中的每个字母，其中-1代表反向枚举，当在交互式对话中输入表达式时，Python会在下一行打印值。 解释器：符合表达式的求解需要以一个可预测的方式来精确解释代码的过程。实现在这样的过程，用于计算复合表达式的程序就称为解释器。解释器的设计和实现是第三章的主题 与其他计算机程序相比，编程语言的解释器具有独特的通用性。Python在设计时并不会考虑莎士比亚，但它的高度灵活性使我们能够只用少量的语句和表达式来处理大量的文本。 最后，这些核心概念都是紧密相关的：函数是对象，对象是函数，解释器是二者的实例。但是，清楚的理解每一个概念及其在组织代码中的作用对于掌握编程艺术至关重要。 1.1.5 ERROR Python正在等待命令。即使可能还不了解完整的机会和结构，所以总会有一些失误的情况。因为计算机在极其灵活的同时也十分古板，计算机的特性在斯坦福的入门课程中被描述为 当尝试使用Python解释器时，计算机的古板会立即显现出来：即使是最小的拼写和格式更改也会导致预料之外的输出和错误。 学着解释错误和找到错误的原因被称为调试，关于调试的一些指导原则是： 增量测试：每个编写良好的程序都可以单独测试的小型模块化组件组成。尽快测试已经编写的所有内容，以尽早发现问题并获得对组件的信心。 隔离错误：语句输出中错误常可归因于特定的模块化组件。所以在诊断问题时，先追踪错误到最小的代码片段，然后再试着修复问题 检查假设：解释器会一字不漏地执行指令——不多也不少。当某些代码的行为与程序员假设的行为不匹配时，它们的输出就是不合预期的。明确假设，然后将调试的工作集中在验证假设上。 咨询别人：你不是一个人！如果你不理解错误信息，请询问朋友、老师或者搜索引擎，如果已经找出了一个错误，但却不知道如何更正，可以请其他人查看。 增量测试、模块化设计、明确的假设和团队合作时贯穿本书的主题，希望它们也贯穿你的计算机科学职业生涯。","categories":[{"name":"CS61A","slug":"CS61A","permalink":"https://primeluoqiu.github.io/categories/CS61A/"}],"tags":[],"keywords":[{"name":"CS61A","slug":"CS61A","permalink":"https://primeluoqiu.github.io/categories/CS61A/"}]},{"title":"1.2编程要素","slug":"ClassesFormUCBerkely/CS61A/1.2 编程要素","date":"2024-03-22T16:54:16.694Z","updated":"2024-03-27T12:11:30.273Z","comments":true,"path":"2024/03/23/ClassesFormUCBerkely/CS61A/1.2 编程要素/","link":"","permalink":"https://primeluoqiu.github.io/2024/03/23/ClassesFormUCBerkely/CS61A/1.2%20%E7%BC%96%E7%A8%8B%E8%A6%81%E7%B4%A0/","excerpt":"","text":"编程语言不仅是一种指挥计算机执行任务的手段，它还应该成为一种框架，使我们能够在其中组织自己有关计算过程的思想。程序也会在社区之间互相分享，那么程序必须是人类可读，且恰巧能够被机器执行。 这样，当我们描述一种语言的时候，就需要特别注意该语言所提供的能够将简单思想组合成复杂思想的工具。那么每一种强大的语言都有这样三种机制 原始表达式和语句：语言所关心的最简单的个体。 组合方法：由简单元素组合构建复合元素 抽象方法：命名复合元素，并将其作为单元进行操作。在编程中，我们只会处理两种元素：函数和数据(之后会发现他们之间的区分实际上没那么明显)。不那么正式的说法是：数据是我们想要操作的东西。而函数是操作这些数据的规则的描述。 因此，任何强大的编程语言都必须能表达基本的数据和函数，并且提供对函数和数据进行组合和抽象的方法。 1.2.1 表达式下面就一点一点了解Python语言。先从一种基本表达式开始，也就是键入的数字，十进制的表达式 12&gt;&gt;&gt; 4242 表达式表达的数字可以与数学运算符组成一个复合表达式，解释器将对其进行求值： 1234&gt;&gt;&gt; -1 - -10&gt;&gt;&gt;1/2 + 1/4 + 1/8 + 1/16 + 1/32 + 1/64 + 1/1280.9921875 这些数学表达式使用的是中缀表示法，指的是运算符出现在操作数之间。Python包含多种形成复合表达式的方法，后面会慢慢介绍 1.2.2 调用表达式最重要的一种复合表达式就是调用表达式，它将函数运用于一些参数上。回想一下高中学过的函数概念：函数就是从一些输入参数到输出值的映射。例如, max函数会输出一个最大的输入值，也就是将多个输入映射到了单个输出上。Python中函数应用的方式与传统数学相同 12&gt;&gt;&gt; max(7.5, 9.5)9.5 这个调用表达式包含子表达式(subexpression):在括号之前是运算符表达式，而括号里面是一个以逗号分隔的操作数表达式的列表![[..&#x2F;..&#x2F;Pasted image 20240322110143.png]]运算符指定了一个函数，在对这个调用表达式进行求值时，我们会说，使用参数7.5和9.5来调用函数max，最后返回9.5 调用表达式中参数的顺序是很重要的。例如，pow函数的第二个参数是第一个参数的幂 1.2.3 导入库函数Python定义了大量的函数，但是默认情况下不能直接用名字来进行调用。Python将已知函数和其他东西组织起来放到了模块中，而这些共同组成了Python库。我们在需要的时候直接调用就可以了。例如math提供了各种熟悉的数学函数 123&gt;&gt;&gt; from math import sqrt&gt;&gt;&gt; sqrt(256)16.0 operator模块提供了中缀运算符对应的函数: 12345&gt;&gt;&gt; from operator import add, sub, mul&gt;&gt;&gt; add(14, 28)42&gt;&gt;&gt; sub(100, mul(7, add(8, 4)))16 import语句需要指定模块名称(例如operator 或 math), 然后列出要导入该模块里的具名函数(例如sqrt)。一个函数被导入后就可以被多次调用。 使用运算符函数和运算符号之间并没有任何区别。尝试使用函数可能会被阅读文档更能使我们了解函数的行为。 1.2.4 名称和环境编程语言的一个要素就是使用名称来引用计算对象，如果一个值被赋予了名称，我们就说名称绑定到了值上面。 在Python中，我们可以使用赋值语句建立新的绑定。 12345&gt;&gt;&gt; radius = 10&gt;&gt;&gt; radius10&gt;&gt;&gt; 2 * radius20 名称也可以通过import语句绑定。 123&gt;&gt;&gt; from path import pi&gt;&gt;&gt; pi * 71 / 2331.00023... = 在Python中被称为是赋值符号(assignment operator, 其他语言也是)，赋值是最简单的抽象方法，它允许我们使用简单名称来指代符合操作的结果，例如上面计算的area。这样，复杂的程序由复杂性递增的计算对象逐步构建。 将名称和值绑定买之后通过名称检索可能得值，就意味着解释器必须维护某种内存来记录名称、值和绑定，这种内存就是环境(environment)。 名称也可以与函数绑定。例如，名称max就和我们之前使用的max函数进行了绑定。与数字不同，函数很难以文本实现，当询问一个函数时，Python会输出一个标识来描述 12&gt;&gt;&gt; max&lt;built-in function max 赋值语句可以为现有函数赋予新名称。 12345&gt;&gt;&gt; f = max&gt;&gt;&gt; f&lt;bulit-in function max&gt;&gt;&gt;&gt; f(2, 3, 4)4 之后再次赋值可以将已有名称与新值绑定。 123&gt;&gt;&gt; f = 2&gt;&gt;&gt; f2 在Python中，名称通常被称为·”变量名 variable names”或”变量 variables”,因为它们可以在执行程序中的过程与不同的值绑定。当一个变量通过赋值语句与一个新值绑定，它就不再绑定以前的值。甚至可以将内置名称和新值绑定。 1234&gt;&gt;&gt; x = 2&gt;&gt;&gt; x = x + 1&gt;&gt;&gt; x3 还可以在单个语句中为多个变量分配值，左右都用括号隔开 12345&gt;&gt;&gt; area, circumference = pi * radius * radius, 2 * pi * radius&gt;&gt;&gt; area314.15926535...&gt;&gt;&gt; circumference62.8318530717... 更改一个变量的值不会影响其他变量。即使下列代码中area的值由最初的radius绑定，但改变radius的值并不能更新area的值，我们需要另一个赋值语句来更新它。 12345&gt;&gt;&gt; radius = 11&gt;&gt;&gt; area314.159..&gt;&gt;&gt; area = pi * radius * radius380.132711 对于多重赋值，所有=右边的表达式都会先求值，然后再和左边的名称绑定。在这个规则下，我们可以在单个语句内交换两个变量的值。 123456&gt;&gt;&gt; x, y = 3, 4.5&gt;&gt;&gt; y, x = x, y&gt;&gt;&gt; x4.5&gt;&gt;&gt; y3 1.2.5 求解嵌套表达式第一章的目标之一是在 **”以程序的角度思考”**，举一个恰当的例子，就是在思考一下在求解嵌套表达式时，解释器自身的操作过程 为了求值一个表达式，Python将执行以下操作： 求解运算符子表达式和操作数字表达式 将操作数子表达式的值作为运算值表达式的函数的参数这个简单的过程也说明了了有关流程的一些要点第一步规定：为了求出调用表达式，必须首先求出其他表达式。因此求值程序本质上是递归的，也就是说它会自己调用自己作为步骤之一。例如，此式子需要应用四次求值过程。 12&gt;&gt;&gt; sub(pow(2, add(1, 10)), pow(2, 5))2016 如果把每个需要求解的表达式都抽出来，我们可以看到这个求值过程的称此结构![[Pasted image 20240325143703.png]]树从上到下增长，树中的每个点叫做节点，这里表示的是表达式和表达式的值。 求解根节点(即顶部的完整表达式)，需要先求解子表达式，也就是分支节点。叶子节点表示函数或者数值。内部节点有两部分：想要应用的求值规则的调用表达式，以及该表达式结果。观察可得，操作数的值会向上流动，从叶子节点开始一步步向上组合。 接下来，观察第一步的重复应用，将我们带到我们需要求解的原始表达式，而不是调用表达式，如数字和名称，我们规定基本逻辑为： 数字的值就是它们所表示的数值 名称的值是环境中关联此名称的对象注意环境在决定表达式中的符号意义上有重要作用。在Python中，不指定任何环境信息去谈论一个值是没有意义的，例如名称x和add。环境为求解提供了上下文信息，对理解程序执行过程有重要作用。 1&gt;&gt;&gt; add(X, 1) 这个求解步骤并不能对所有Python代码求值，它仅能求解调用表达式、数字和名称。例如，它并不能处理赋值语句。 1&gt;&gt;&gt; x = 3 因为赋值语句的目的是将名称与值绑定，它并不返回值，也不应用参数去求解函数。也就是说，赋值语句不但求解但”被执行”，它们只是做出一些改变但不产生值。每种类型的表达式或语句都有自己的求解或执行过程。 注意：当我们说”一个数字求解为一个数值”时，实际上是Python解释器将数字求解为数值，是解释器赋予了编程语言这个意义。鉴于解释器是一个始终表现一致的固定程序，我们就可以说数组(以及表达式)会在python程序的上下文中被求解为值。 1.2.6非纯函数print在本节中，我们将区分两种类型的函数。纯函数(Pure functions):函数有一些输入(参数)并返回一些输出(调用返回结果)。 12&gt;&gt;&gt; abs(-2)2 可以将内置函数abs描述为接受输入并产生输出的小型机器。![[Pasted image 20240325152212.png]]abs就是纯函数，纯函数在调用时除了返回值不会造成其他影响，而且在使用相同的参数调用纯函数时总是会返回相同的值。 非纯函数(Non-pure functions): 除了返回值，调用一个非纯函数还会产生其他改变解释器和计算机状态的副作用(side effect)。一个常见的副作用就是使用print函数产生(非返回值的)额外输出。 12&gt;&gt;&gt; print(1, 2, 3)1 2 3 虽然print和abs在这些例子中看起来很相似，但它们的工作方式基本1不同。print返回的值始终为None，这是一个不代表任何内容的特殊Python值。而叫不是Python解释器并不会自动打印None值，所以print函数的额外输出就是它的副作用![[Pasted image 20240325153052.png]]下面这个调用print的嵌套表达式就展示了非纯函数的特征 1234&gt;&gt;&gt; print(print(1), print(2))12None None 可以尝试画一个表达式树来解释求解该表达式会产生特殊输出的原因。小心使用print函数!它返回None意味着它不应该应用于赋值语句。 1234&gt;&gt;&gt; two = print(2)2&gt;&gt;&gt; print(two)None 纯函数不能有副作用，或是随着时间推移的改变的限制，但是对其施加这些限制会带来很大的好处。首先，纯函数可以更可靠地组成复合调用表达式。在上面的实例中可以看到在操作数表达式中使用非纯函数print并不能返回有用的结果，但另一方面，我们已经能看出来max, pow, sqrt等函数可以在嵌套表达式中有效使用。 第二，纯函数更容易测试。相同的参数列表会返回相同的值，我们可以将其与预期的返回值进行比较。 第三，纯函数对于编写可以同时计算多个调用表达式的并发程序来说是必不可少的。","categories":[{"name":"CS61A","slug":"CS61A","permalink":"https://primeluoqiu.github.io/categories/CS61A/"}],"tags":[],"keywords":[{"name":"CS61A","slug":"CS61A","permalink":"https://primeluoqiu.github.io/categories/CS61A/"}]},{"title":"acwing -堆排序","slug":"Algorithm/sort","date":"2024-03-21T13:54:55.018Z","updated":"2024-03-21T13:56:15.931Z","comments":true,"path":"2024/03/21/Algorithm/sort/","link":"","permalink":"https://primeluoqiu.github.io/2024/03/21/Algorithm/sort/","excerpt":"","text":"如何手写一个堆维护一个数据集合支持的基本操作： 插入一个数 求集合当中的最小值 删除最小值 还有操作可以支持 删除任意一个元素 修改任意一个元素 堆是一个二叉树，完全二叉树，树除了最后一层节点之外，上面的所有节点都是满的。最后一层节点从左到右排列。小根堆有个性质：每个点都小于左右儿子，一个递归定义，根节点就是整个数据结构的最小值。堆的存储：(全新的存储方式):用一个一维数组来存。堆状数据结构几乎都可以用一位数组来存储。 存储的话，数组的第一个节点是根节点，然后从x开始，x的左儿子是2x, x的右儿子是2x+1有两种操作，分别是up 和 down，五个操作都可以用这两个函数来解决。 down操作实际上就是在这三个数字里面找到最小的数字，然后把最大的数字和最小的数字进行交换，然后把相对来说小的数推上去 插入一个数：heap [++size] &#x3D; x; up(size); 求集合当中的最小值:heap[1]; 删除最小值 用堆的最后一个元素来覆盖掉堆顶的元素，然后再把堆顶down一下即可。删除头节点比较困难，尾节点比较简单。 heap[1] &#x3D; heap[size]; size –;down(1); 删除任意一个元素: heap[k] &#x3D; heap[size]; heap –; down(k); up(k); 分情况讨论，变大就down一遍，变小就up一下，或者直接不管，up，down一边就行。 修改任意一个元素:heap[k] &#x3D; x; down(k); up(k);下标从1开始 然后我们来看一道题： 1输入一个长度为n的整数数列，从小到大输出前m小的数。 通过读题我们可以看出来，在这里我们只需要down这个操作，我们来看一下down这个操作是怎么实现的 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1e6 + 10;int n, m;int h[N], cnt; //存的heap和存了多少元素//我们只需要把数组建成堆，然后每一次输出堆顶，第一次输出就是第一小的数，然后是第二小的数，然后balabala//需要第二个操作和第三个操作，然后我们发现只需要实现down就可以了。void down(int u)&#123; int t = u; if(u * 2 &lt;= cnt &amp;&amp; h[u * 2] &lt; h[t]) t = u * 2; if(u * 2 + 1 &lt;= cnt &amp;&amp; h[u * 2 + 1] &lt; h[t]) t = u * 2 + 1; if(u != t) &#123; swap(h[u], h[t]); down(t); &#125;&#125;int main()&#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for(int i = 1; i &lt;= n; i ++) scanf(&quot;%d&quot;, &amp;h[i]); cnt = n; //正常输入，然后建堆，如果是一个一个往里面插入的话，时间复杂度是(nlogn)的，有一种时间复杂度是O(n)的方法是从1/2开始往下down for(int i = n / 2; i; i --) down(i); while(m --) &#123; printf(&quot;%d &quot;, h[1]); h[1] = h[cnt]; cnt --; down(1); &#125; return 0;&#125; 至于为什么是O(n)的呢？ down操作很简单，用t来表示三个点里面的最小值，首先判断一下有没有左儿子。 1234567891011void down(int u)&#123; int t = u; if(u * 2 &lt;= size &amp;&amp; h[u * 2] &lt; h[t]) t = u * 2; if(u * 2 + 1 &lt;= size &amp;&amp; h[u * 2 + 1] &lt; h[t]) t = u * 2 + 1; if(u != t) &#123; swap(h[u], h[t]); down(t); &#125;&#125;","categories":[{"name":"acwing","slug":"acwing","permalink":"https://primeluoqiu.github.io/categories/acwing/"}],"tags":[],"keywords":[{"name":"acwing","slug":"acwing","permalink":"https://primeluoqiu.github.io/categories/acwing/"}]},{"title":"Lecture 5 - List3","slug":"计算机网络/Lecture5 - List3 DLList And Arrays","date":"2024-03-20T14:21:05.839Z","updated":"2024-03-21T13:56:27.690Z","comments":true,"path":"2024/03/20/计算机网络/Lecture5 - List3 DLList And Arrays/","link":"","permalink":"https://primeluoqiu.github.io/2024/03/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Lecture5%20-%20List3%20DLList%20And%20Arrays/","excerpt":"","text":"之前说到的SLList还是很不错的，不过目前来看的话它存在了一个新的问题，就是对于addLast函数而言，还是相对来说比较缓慢地，效率也是比较低的。 就像是最一开始的size函数，那么我们有什么办法可以提高它的效率呢，我们可以在中间人那里再定义一个last函数用来保存最后一个节点的地址，不过这样的话，就会有新的操作效率较慢了 那便是remove操作，那么如果我们想要删除一个节点的话，那么我们只能首先遍历到节点那里，然后删除这个节点的指针，然后再将last的那个指针指向删除的节点的前一个节点。这听起来实在是太麻烦了，所以这种方法似乎也是不可取的。那么还有什么别的方法吗 那么，我们就想到能不能就是给每一个节点添加一个当前节点的前置节点的指针呢？答案是可以的 这种每个节点都有两个链接的列表叫做双向链表 完成这种方法之后，我们的添加在头部和尾部，删除头部和尾部的方法就会变得十分的快，不过在中间的节点操作相对来说就会比较慢。 不过这样的链表还是会存在一个 限制有这样一种情况：最后一个节点的next指针有的时候指向最开始的哨兵节点，有的时候指向我们称之的最开始的节点(real node)。那么就有可能需要我们在后面再去写相关的判断语句来判断它是否真的是哨兵节点。 为了避免这种麻烦的情况，我们尝试让他变得更纯粹一些。 所以为了完善我们的方法的最自然的方法就是添加第二个哨兵，然后让着第二个哨兵来指向最后一个节点，我们不再是一个指向最后一项的一个指针，而是在开始和末尾两端都添加一个哨兵（因为此时我们已经有了prev和next指针），这样的话，前面就有一个哨兵，后面也有一个哨兵了，那么这样再添加节点或者项目的时候，就只需要将节点滑入这两个哨兵之间就可以了 那么其实还有一种办法，这里依旧还是只有一个哨兵，它既是前面的哨兵也是后面的哨兵 ![[../一些截图（笔记用）/Pasted image 20240226134251.png]] 就像这里的，先指向哨兵节点，然后指向3，指向9，最终再回到sentinal.所以这实际上更像一个循环。 不过即便是这样，还是会有一个限制，就是说在现实世界中不太好使，就是说，如果我们要添加的东西是数字时，它会非常的好用，但是如果我们添加的是字符串或者字符呢？我们又该怎么办，例如 123456public class SLListLauncher &#123; public static void main(String[] args) &#123; SLList s1 = new SLList(&quot;Bone&quot;); s1.addFirst(&quot;thugs&quot;); &#125;&#125; 也就是说，我们不能将字符串转化成整数这样的报错。 我们可以选择重新创建一个全新的SLList类，不过这意味着我们还需要重新写一遍我们的类。这听起来可太麻烦了。 不过，还有一种方法就是使SLList参数化，我们可以参数化SLList将采用的类型，这应该如何操作呢 就是我们要在SLList后面添加新的尖括号&lt;&gt;，然后在尖括号里面添加任意的字符串，例如LochNess，这是充当创建SLList时尚未决定的类型的占位符，因此这个时候我们将使用LochNess来代替int项，然后这个时候我们也会将我们创建一个节点的名字改成 123private class StuffNode(LochNess i, StuffNode n) &#123; ...&#125; 定义是这样的 123456public class SLList&lt;LochNess&gt; &#123; private class StuffNode &#123; public LochNess item; public StuffNode next; &#125;&#125; 这个时候我们只需要将main函数修改一下即可 现在想要创建一个SLList的话，需要指定一个类型 1SLList&lt;String&gt; s1 = new SLList&lt;String&gt;(&quot;bone&quot;); //定义并实例化 然后就正常工作了。 在我们使用的时候，我们往&lt;&gt;里传什么，对应的函数里的&lt;&gt;也会传什么，所以它基本上是一个类型变量或类型参数 在更现代的java中，不再需要在实例化方面指定类型，也是行得通的。 在指定类型的时候，只需要指定一次计科，可以在其他地方多次使用它。使用的时候尖括号内的首字母需要大写!!!","categories":[{"name":"CS61B","slug":"CS61B","permalink":"https://primeluoqiu.github.io/categories/CS61B/"}],"tags":[],"keywords":[{"name":"CS61B","slug":"CS61B","permalink":"https://primeluoqiu.github.io/categories/CS61B/"}]},{"title":"Hello World","slug":"计算机网络/Lecture4-List 2 SLLists","date":"2024-03-20T14:21:05.838Z","updated":"2024-03-20T14:24:22.475Z","comments":true,"path":"2024/03/20/计算机网络/Lecture4-List 2 SLLists/","link":"","permalink":"https://primeluoqiu.github.io/2024/03/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Lecture4-List%202%20SLLists/","excerpt":"","text":"Video 1:Class A:Introducing the SLListLast Time in 61B: Recursive Implementation of a List 12345678910public class IntList &#123; public int first; public IntList rest; public IntList(int f, IntList r) &#123; first = f; rest = r; &#125;&#125;... While functional, “naked”linked lists like the one above are hard to use. Users of this class are probably going to need to know references very well, and be able to think recursively.Let’s make our users’ lives easier.这些代码对于我们来讲是比较容易看懂的，但是对于用户来讲可能就比较费解，那么我们需要一些其他的方式来重新叙写我们的IntList。对它进行更新换代，以至于让我们的用户理解起来也很方便 Improvement #1: Rebaranding and Culling123456789public class IntNode &#123; public int item; public IntNode next; public IntNode(int i, IntNode n) &#123; item = i; next = n; &#125;&#125; IntNode is now dumb, has no methods.We will reintroduce functionality in the coming slides. Not much of an improvement obviously, but this next weird trick will be more impressive. Class B:Introducing the SLList Bureaucracy这个也提供了一些小方面的改善。下一步，我们创建另一个类，命名为SLList，这个类表示是一个整数列表，隐藏了内部是单纯的数字的真相。这个列表的工作原理是我们已经有一个IntList类 123456789101112131415package Lecture4; /* An SLList is a list of integers, which hides the terrible truth * of thr nakedness within. */ public class SLList &#123; public IntNode first; public SLList(int x) &#123; first = new IntNode(x, null); &#125; public static void main(String[] args) &#123; /*Create a list of one integer, namely 10*/ SLList L = new SLList(10); &#125; &#125; 那么我们为什么要做这种看起来似乎没什么意义的事情呢？这是一个线索，如果考虑一下某个程序员如何创建列表，那么他实际上不必指定null，只需要添加一个数字即可。在之前，当我们想要创建一个列表，我们需要 1IntNode X = new IntNode(10, null); 而现在我们只需要 1SLList Y = new SLList(10); SLList is easier to instantiate(no need to specify null), but wait, there’s more. 123456public class SLList &#123; public IntNode first; public SLList(int x) &#123; front = new IntNode(x, null); &#125;&#125; Next: Let’s add addFirst and getFirst method to SLList. Class C: Introducing the SLList Methods在我们拿走了IntNode能做的所有事情之后，我们将会在SLList中还原他，接下来是我们准备还原的一部分addFirst getFirst当我们想要完成第一个函数的addFirst的时候，我们可以从之前的IntList当中寻找灵感，在这里我们创建一个新的点的时候![[..&#x2F;..&#x2F;Pasted image 20240126093348.png]]用到的是L = new IntList，那么我们在这里也是 1234// Add x to the front of the list.public void addFirst(int x) &#123; first = new IntNode(x, null); &#125; 至于getFirst的话，相对来说我们只需要返回第一个的item，相对来说会简单很多 1234// Returns the first item in the listpublic int getFirst() &#123; return first.item;&#125; SLLists vs. IntLists对比一下之前写的和最近写的 123456789SLList L = new SLList(15);L.addFirst(10);L.addFirst(5);int x = L.getFirst();IntList L = new IntList(15, null);L = new IntList(L, 10);L = new IntList(L, 5);int x = L.first; While functional, “naked”linked lists like the IntList class are hard to use. Users of IntList are need to know Java references well, and be able to think recursively. SLList is much simpler to use. Simply use the provided methods. Why not just add an addFirst method to the IntList class? Turn out there is no efficent way to do this. See exercise in LectureCode repository. Video 2: Access Control and Nested Classes我们不难发现，SLList是很好用的，想要添加，删除，或者获取内容的话，最好使用该类提供的方法，不过，根据java的工作效益，可以尝试做一些奇怪的事情。 123456789101112public class SLList &#123; public IntNode first; public SLList(int x) &#123; first = new IntNode(x, null); &#125; public void addFirst(int x) &#123; first = new IntNode(x, first); &#125; ...&#125; Users of our classes might be tempted to try to manipulate our secret IntNode directly in uncouth ways! 123SLList L = new SLList(15);L.addFirst(10);L.first.next.next = L.first.next; 显然，这是不被允许的。可以猜一下会发生什么![[..&#x2F;..&#x2F;Pasted image 20240127092904.png]]![[..&#x2F;..&#x2F;Pasted image 20240127092922.png]]它最终会指向自身，我们最终毁掉了这个列表。很显然，我们并不想被类似这样的调用其他方法来毁掉我们的列表，因此我们可以在我们的程序之前添加注释，类似 1/*Don&#x27;t mess up my programmer*/ 但是这很显然没有下述方式来的更加畅快 Access Control 123456789101112public class SLList &#123; public IntNode first; public SLList(int x) &#123; first = new IntNode(x, null); &#125; public void addFirst(int x) &#123; first = new IntNode(x, first); &#125; ...&#125; We can prevent programmers from making such mistakes with the private keyword.我们可以给类的成员声明为private而不是声明为public例如 1private IntNode first; 现在，好处是，这不仅是自行记录的，而且还有编译器强制执行，那么在别的类中访问这个变量就会报错因此private关键字的作用是防止其他类中的代码使用该类的成员(包括变量，方法…)不过，java中有一个有趣的功能称为反射。允许绕过这些修饰符，不过很少使用。 Why Restrict Access?Hide implementation details from users of your class. Less for user of class to understand. Safe for you to change private methods.(implementation).E.g:Car analogy: Public: Pedals, Steering Wheel Private:Fuel line, Rotary valve. Despite the term ‘access control’: Nothing to do with protection against hackers, spies, and other evil entities.至于为什么要限制通过呢，也就是说为什么要用private，一个方面是为了对使用你的类的人隐藏实施细节，他们不需要了解这个原理是什么，他们有对应的输入和输出即可。其次，对你来讲去修改这种私有方法是很安全的。例如在一个车的系统当中，公共的部分有例如踏板，轮胎这些，而私有的例如燃油管线（现在有纯电车）。不过，当有人获取到你的源码之后，这些所谓的安全也就不存在了。 总结一下，私有就是你可以随便处置但是用户不可以，公共就是都可以访问你的方法等一系列东西。 Improvement 4: Nested ClassesCan combine two classes into one file pretty simply. 123456789101112131415public class SLList &#123; public class IntNode &#123; //Nested class definition public int item; public IntNode next; public IntNode(int i, IntNode n) &#123; item = i; next = n; &#125; &#125; // Could have made IntNode a private nested class if we wanted.private IntNode first; //Instance variables, constructors, and methods of SLList typical go below nested class definition.public SLList(int x) &#123; first = new IntNode(x, null); &#125;...&#125; 一个嵌套的类定义，那么，嵌套的类有什么好处呢？ Why Nested Classes?Nested Classes are useful when a class doesn’t stand on its own and is obvious subordinate(从属，下属) to another class. Make the nested(嵌套的) class private if other classes should never use the nested class. In my opinion, probably makes sense to make IntNode a nested private class. Hard to imagine other classes having a need to manipulate IntNodes Static Nested Classes If the nested class never uses any instance variables or methods of the outer class, declare it static Static classes cannot access outer class’s instance variables or methods. Results in a minor savings of memory. See book for more details.123456789101112public class SLList &#123; private static class IntNode &#123; //we can declare IntNode static, since it never use any of SLList&#x27;s instance variables or methods. public int item; public int IntNode next; public IntNode(int i, IntNode n) &#123; item = i; next = n; &#125; &#125; ...&#125; Unimportant note:For private nested classes, access modifiers are irrelevant.如果嵌套类从不需要查找，那么可以添加staitc关键字。 Video3: addLast and sizeAdding more SLList Functionality To motivate our remaining improvements, and to give more functionality to our SLList class, let’s add: .addLast(int x) .size()Recommendation: Try writing them yourself before watching how I do it.添加了两个其他的方法。 12345678910public void addLast(int x) &#123; IntNode p = first; /*Move p until it reaches the end of the list. */ while(p.next != null) &#123; p = p.next; &#125; p.next = new IntNode(x, null); &#125; 当想要尝试.size()的时候，我们发现试图搞清楚基本情况是比较困难的。如果使用递归的话情况也是很奇怪，如果想要用递归来做的话，那么就无从下手。原因是SLList这个数据结构本身就不是递归的，它没有SLList指针。因此只能采用相对来说通用性更强一些的策略了、 通常会创建一个私有的静态帮助器方法，它会采用一个特定的节点来帮助我们解决这个问题。所以现在的话，这就是一个非常清晰的递归数据结构 那么这样的话 123456789private static int size(IntNode p) &#123; if(p.next == null) return 1; return 1 + size(p.next); &#125; public int size() &#123; return size(first); &#125; Video 4: Caching假设有一个长度为1000的SLList，我们遍历一遍获得它的长度的时间是两秒，那么如果有一个长度为1,000,000的链表的时候，时间就是2,000秒，那么这个函数实际上是效率很低的，那么我们应该用什么方式来提高它的效率呢？ 我们可以选择在类的内部定义一个私有的成员变量size，然后在类似addFirst, addLast这里对size += 1，然后在定义一个链表的时候让size = 1，这样在写size函数的时候直接return size即可。 不过其实，这样和遍历一个链表的所花费的空间或者说时间还是一样的，只不过是把一个很大的任务分散化了， 也就是说，当我们每操作一次链表，size的值就会被更新一下。 那么还有没有别的办法呢 当然肯定是有的。就是利用我们最开始引入的那个中间人，也就是first节点，在这里我们可以用他来存储有关整个列表的元信息的自然位置 之前说过`SLList`有一个很好的优势，就是每当想要操作数据或者查看数据的时候，都必须经过这个中间人，这个中间人为我们提供了非常简单易懂的办法来保证安全，避免我们以各种方式搬起石头砸自己的脚。 现在`SLList`结构拥有这个中间人的另一个好处是，它可以作为存储有关整个列表元信息的自然位置。例如，我们可以在这里存储列表的大小，这在技术上是多余的，我们可以在没有这个变量的情况下计算大小，但它会加快大小的计算速度，因为我们只需要返回这个大小的值，我们也可以在这里存放其他东西，就像可以存储曾经放入其中的最大值、最小值等，这些也可以正常工作。 相比之下，使用裸递归列表就不那么容易了，指图片中的上者，原则上可以执行诸如缓存每个节点内部的大小之类的操作。但即便如此，这也意味着每当我们更改列表中的某些内容时，都必须更新一堆大大小小的变量，例如如果有一种允许这样做的语言，我们还可以以某种方式在此处绑定一个变量来跟踪整个事物的大小。但是在Java中，没有天然的工具（函数）可以做到这一点。因此，实际上，我们最终要做的就是拥有多个必须保持一致的变量，在这里，这种面向对象的编程方法意味着我们让对象来控制一切，我们告诉对象，你的工作不仅是王城所有这些任务，还要为我跟踪尺寸，这样，这就是组织代码的自然方式。 也就是说，`intList`可以做`SLList`可以做的所有的事情，但是`SLList`在几乎所有方面都是一种更自然的方法 Video 5 The Empty List那么SLList这么好用，他还可以允许我们自己代表空列表，也就是说创建列表的时候可以很自然的实例化一个空列表，那么我们来修改一下我们的代码 123456/*Create an empty SLList*/public SLList()&#123; size = 0; first = null; &#125; 源码此时是这样的 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package Lecture4; /* An SLList is a list of integers, which hides the terrible truth * of thr nakedness within. */ import Lecture3.IntList; public class SLList &#123; public IntNode first; private int size; public SLList() &#123; first = null; size = 0; &#125; /*Creates an empty SLList*/ public SLList(int x) &#123; first = new IntNode(x, null); &#125; // Adds x to the front of the list. public void addFirst(int x) &#123; first = new IntNode(x, first); size += 1; &#125; // Returns the first item in the list. public int getFirst() &#123; return first.item; &#125; //Adds x to the last of the list. public void addLast(int x) &#123; IntNode p = first; /*Move p until it reaches the end of the list. */ while(p.next != null) &#123; p = p.next; &#125; p.next = new IntNode(x, null); size += 1; &#125; /*Returns the sizes of the list from IntNode p*/ /*private static int size(IntNode p) &#123; if(p.next == null) return 1; return 1 + size(p.next); &#125; public int size() &#123; return size(first); &#125;*/ public static void main(String[] args) &#123; /*Create a list of one integer, namely 10*/ SLList L = new SLList(); L.addFirst(10); L.addFirst(5); L.addLast(20); System.out.println(L.size); &#125; &#125; 结果自然而然的就是3但是实际上这个代码会存在一个小小的bug就是，如果我们不是先从头插入的话，就会报错，例如我们第一步先用addLast的话就会报错![[..&#x2F;一些截图（笔记用）&#x2F;Pasted image 20240222155831.png]]是因为我们将一个指针指向了空指针，然而空指针的下一位是空的，就会报错。那么我们应该如何处理这个问题呢？有一个方法就是在addLast中添加一个判断语句，即 123456789public void addLast(int x)&#123; size += 1; if(first == null) &#123; first = new IntNode(x, first); return; &#125; ...&#125; 这样再看的话，我们的程序目前工作就正常了![[..&#x2F;一些截图（笔记用）&#x2F;Pasted image 20240222160836.png]] Video 6: Sentinel Nodes在我们了解到上述问题之后，其实还有一种解决的方式，这种方式未来会在我们在构筑大型项目上的时候有所优势。就是创建一个哨兵节点，然后哨兵节点来传递到第一个节点、第二个节点…这些，然后我们用一个指针来讲创建的列表指向我们的哨兵节点，这样的话无论列表是不是空的都会有一个节点在那里。不过这样的话，我们就需要对基本上所有的函数进行修改了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package Lecture4; /* An SLList is a list of integers, which hides the terrible truth * of thr nakedness within. */ import Lecture3.IntList; public class SLList &#123; private static class IntNode &#123; public int item; public IntNode next; public IntNode(int i, IntNode n) &#123; item = i; next = n; &#125; &#125; private int size; /*The first item (if it exists) is at sentinel.next*/ private IntNode sentinel; public SLList() &#123; sentinel = new IntNode(66, null); size = 0; &#125; /*Creates an empty SLList*/ public SLList(int x) &#123; sentinel = new IntNode(66, null); sentinel.next = new IntNode(x, null); size = 1; &#125; // Adds x to the front of the list. public void addFirst(int x) &#123; sentinel.next = new IntNode(x, sentinel.next); size += 1; &#125; // Returns the first item in the list. public int getFirst() &#123; return sentinel.next.item; &#125; //Adds x to the last of the list. public void addLast(int x) &#123; size += 1; IntNode p = sentinel; /*Move p until it reaches the end of the list. */ while(p.next != null) &#123; p = p.next; &#125; p.next = new IntNode(x, null); &#125; /*Returns the sizes of the list from IntNode p*/ /*private static int size(IntNode p) &#123; if(p.next == null) return 1; return 1 + size(p.next); &#125; public int size() &#123; return size(first); &#125;*/ public static void main(String[] args) &#123; /*Create a list of one integer, namely 10*/ SLList L = new SLList(); L.addFirst(10); L.addFirst(5); L.addLast(20); System.out.println(L.size); &#125; &#125; 改完之后就是大致这样的 那么哨兵节点实际上就是一个虚拟的节点，一个忠实的伙伴。鉴于第一个不再指向第一项，那么我们重命名它为哨兵代码 当然，哨兵对于我们便携的所有代码来说它永远不会为空，并且它总是指向哨兵节点，哨兵节点的值可以随机，我在这里选择了66.当我们编写带么和检查每个构造函数和方法时，我们必须确保所有内容都与我们的哨兵节点兼容。理想情况下，一开始就这样做的话这样就不会感觉那么随意。我们不会一次性做出一堆微小的改变 Video 7: Invariants我们可以使用术语不变性来概括这种保持简单的想法。因此不变量只是一个在代码运行时保证为真的条件。所以它列出了所有可以信赖的事实。因此，带有哨兵节点的SLList那么它总是具有一些不变量，例如哨兵变量——哨兵应用它总是指向一个哨兵节点，这是我们所拥有的东西，并且保证是真实的另一个是列表中的第一个节点(如果存在的话)，那么它始终位于sentinel.next，事实上，这在代码中是作为注释明确写出得一个不变量。 因此，不变量的好处是它可以让我们更容易地推理代码它可能让我们避免出错","categories":[{"name":"CS61B","slug":"CS61B","permalink":"https://primeluoqiu.github.io/categories/CS61B/"}],"tags":[],"keywords":[{"name":"CS61B","slug":"CS61B","permalink":"https://primeluoqiu.github.io/categories/CS61B/"}]},{"title":"Hello World","slug":"计算机网络/Lecture3-List 1 Refrence Recursion and Lists","date":"2024-03-20T14:21:05.836Z","updated":"2024-03-20T14:24:20.763Z","comments":true,"path":"2024/03/20/计算机网络/Lecture3-List 1 Refrence Recursion and Lists/","link":"","permalink":"https://primeluoqiu.github.io/2024/03/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Lecture3-List%201%20Refrence%20Recursion%20and%20Lists/","excerpt":"","text":"Welcome!MenuLecture 3: References and Recursion Primitive Types Reference Types Linked Data Structures List In lecture2, we saw how we can create a List in Java. Unlike Python, lists are not bulit directly into the Java language123456import java.util.List;import java.util.LinkedList;List&lt;String&gt; L = new LinkedList&lt;&gt;();L.add(&quot;a&quot;);L.add(&quot;b&quot;); Today, we’ll begin our 3 lecture journey towards building our own list implementation We’ll exploit recursion to allow our list to grow infinitely large. But first we need to slove … the mystery of the walrus Video 1:The Mystery of the Walrus.先看一段代码并回答一个问题： 123456Walrus a = new Walrus(1000, 8.3) //创建了一个海象的类，前面是体重，后面是象牙大小Walrus b;b = a;b.weight = 5;System.out.println(a);System.out.println(b); Will the change to b affect a?(y&#x2F;n) :… 12weight: 5, tusk size: 8.30weight: 5, tusk size: 8.30 我们很惊讶的发现A居然会受到B的影响，体重居然被改成了5.接下来，再看一段代码，回答一个问题 123456int x = 5;int y;y = x;x = 2;System.out.println(&quot;x is:&quot; + x);System.out.println(&quot;y is:&quot; + y); Will the change to x affect y?(y&#x2F;n)… 12x is: 2y is: 5 但是在这里我们发现x并不受y的影响，但是这到底是为什么呢？接下来，让我们在可视化工具这里运行他，发现差异的地方 12345678910111213141516171819202122232425262728293031public class PollQuestions &#123; public static void main(String[] args) &#123; Walrus a = new Walrus(1000, 8.3); Walrus b; b = a; b.weight = 5; System.out.println(a); System.out.println(b); int x = 5; int y; y = x; x = 2; System.out.println(&quot;x is: &quot; + x); System.out.println(&quot;y is: &quot; + y); &#125; public static class Walrus &#123; public int weight; public double tuskSize; public Walrus(int w, double ts) &#123; weight = w; tuskSize = ts; &#125; public String toString() &#123; return String.format(&quot;weight: %d, tusk size: %.2f&quot;, weight, tuskSize); &#125; &#125;&#125; ![[Pasted image 20240119121426.png]]在b=a这里时，我们可以看到，我们有两个箭头指向同一个Walrus，所以无论出于何种原因a和b实际上指的都是同一只海象，如果执行b.weight = 5那么就会改变着一个海象(Walrus)的值，因此打印出来为5就不那么奇怪了。 那么整数情况呢![[Pasted image 20240119123108.png]]我们发现在图中这两个整数对应的是两个小盒子，修改的话只会修改对应的小盒子的值。那么，这到底是为什么呢？ Video 2: Primitive Types这个时候就要先解释一下计算机的底层工作原理了(61C) Bits Your computer stores information in “memory” Information is stored in memory as a sequence of ones and zeros Example:72 stored as 01001000 Example:205.75 stored as …01000011 01001101 11000000 00000000 Example:The letter H stored as 01001000(same as the number 72)(计算机知道如何根据特定上下文解释这些位) Example:True stored as 00000001Each Java type has a different way to interpret the bits: 8 primitive types in Java:byte, short, int, long, float, double, boolean, char 想要存储在计算机上的东西实际上都存储在所谓的内存中，内存所存的信息都被编码为0和1的序列即使H和72有单独的表现形式，该类型也会告诉Java解释器如何解释这个变量应该是什么。因此如果有一个字符类型的变量，那么当它看到后面的序列的时候就会考虑到字符H。但是如果有一个整数变量，那么当它看到后面的序列的时候就会考虑到72 Declaring a Variable(Simplified) When you declare a variable of a certain type in Java: Your computer sets aside exactly enough bits to hold a thing of that type. Example:Declaring an int sets aside a “box” of 32 bits. Example:Declaring an double sets aside a “box” of 64 bits. Java creates an internal(内部的) table that maps(映射) each variable name to a location. Java does NOT write anything into the reserved boxes. For safety, Java will not let access a variable that is uninitialized(未初始化的).1234int x;int y; //以上只是声明，并未赋值x = -1431195969;y = 567213.112; 当运行int x的时候，我们得到了一个长度为32位的盒子，而运行double y的时候，我们得到了一个64位的盒子。虽然我们在定义变量的时候并没有往里面放入任何东西，但是实际上里面是有东西的，是因为内存是一些世界上主观存在的物理对象。所以内存将包含一些0和1的序列。但是Java并不允许实际访问现有的信息。这有点像在着急的时候从桌子上拿起来一张纸，因为需要快速写下笔记，类似电话号或者一些其他的事情，上面可能已经有一些东西了，但是我们通常不关心它。因为我们拿起来是想要写一些我们要关注的东西。那么因此，当我们在定义玩变量但是未赋初值的时候，这种操作是不被允许的。 接下来，当运行赋值语句的时候，这些数值就会被变化成一串带有0和1的序列存到int的32位的盒子中，而y存进对应的64位的盒子中。![[Pasted image 20240119153743.png]] Simplified Box Natation We’ll use simplified box notation from here on out: Instead of writing memory box contents in binary,we’ll write them in human readable symbols.正是因为当我们看见那一串0和1的序列的时候看起来很长，很令人生畏。那么这种所谓方框表示法是可以被简化的。也就是说，当我们对x和y存入值的时候，我们用我们能够更轻易理解的数字来代替那些二进制形式写出的内存盒。当x&#x3D;-1431195969的时候，我们就用这一串数来存进去，y同理。而它也就恰好和Java Visulizer所展现的是一样的原理。![[Pasted image 20240119154105.png]]接下来，就可以解开这项谜题了 The Golden Rule of Equals(GRoE) Given variables y and x: y &#x3D; x copies all the bits from x into y.![[Pasted image 20240119154447.png]][https://cscircles.cemc.uwaterloo.ca/java_visualize/#mode=display] 12345678910public class PollQuestions &#123; public static void main(String[] args) &#123; int x = 5; int y; y = x; x = 2; System.out.println(&quot;x is: &quot; + x); System.out.println(&quot;y is: &quot; + y); &#125;&#125; 那么当x被执行等于2的时候，根据GRoE法则，也就是只会把用二进制表示的二的这些位放入x所表示的那个框中。所以y没有被改变。有两个不同的盒子。这就是整数为什么不会发生变化所表现出来的答案。 Video 3: Reference TypesReference Types There are 8 primitive(原始的) types in Java： byte, short, int, long, float, double, boolean, charEverything else, including arrays,is a reference(引用) type Class Instantiations When we instantiate an Object(e.g Dog, Walrus, Planet): Java first allocates a box of bits for each instance variable of the class and fills them with a default value(e.g 0, Null). The constructor then usually fills every such box with some other value.123456789public static class Walrus &#123; public int weight; public double tuskSize; public Warlus(int w, double ts) &#123; weight = w; tuskSize = ts; &#125;&#125; 00:53 (一个例子)通过这个例子可以看出来每当我们调用new的时候，Java会做的事就是挖掘内存，并找到96位(一个double一个int加起来一共96位)，然后函数找到之后用1000填充这个顶部位，8.3填充那个底部位在此处可见02:46 new关键字可以认为是返回了一个放置这个东西的一个首位数。Can you think of new as returning the address of the newly created object. Address in Java are 64 bits. Example(rough picture): If object is created memory location 23874723423, then new returns 2384723423.接下来讨论一下引用类型变量的声明 Reference Type Variable DeclarationsWhen we declare a variable of any reference type(Warlus, Dog, Planet): Java allocates exactly a box of size 64bits, no matter what type of object. These bits can be either set to: Null(all zeros). The 64 bits “address” of a specific instance of that class(return by new)当我们声明的时候,Java会做的就是分配一个刚好64位的盒子（无论类型是什么），这些盒子的返回值可以是0，也可以设置为new返回的该类的特定实例的地址。04:21 也就意味着说，即使Warlus本身需要96位，但是我们存储的地址依旧是64位的 06:19 介绍了一种方法来简化上面的表达方式，同样也是在Java Visulizer中呈现的 The 64 bit address are meaningless to us as humans, so we’ll represent: All zero addresses with “null” Non-zero addresses as arrows.This is sometimes called “box and pointer” notation.上述是原理 Reference Types Obey the Golden Rule of Equals 06:58 对于Warlus的一步一步解释 Just as with primitive types, the equals sign copies the bits. In terms of our visual metaphor, we “copy” the arrow by making the arrow in the b box point at the same instance as a.1234Warlus a;a = new Warlus(1000, 8.3);Warlus b;b = a; equal只是复制位，这对于基本类型是正确的，对于引用类型也是一样的。 Video 4: Parameter PassingThe Golden Rule of Equals(and Parameter Passing) Given variables b and a: b &#x3D; a copies all the bits from a into b.Passing parameters obeys the same rule:Simply copy the bits（This is also called by value按值传递) to the new scope.Example:123456789public static double average(double a, double b) &#123; return (a + b) / 2;&#125;public static void main(String[] args) &#123; double x = 5.5; double y = 10.5; double avg = average(x, y);&#125; 例子解释在00:31 总结： The Golden Role: Summary There are 9 types of variables in Java: 8 primitive types(bytes, short, int, long, float, double, boolean, char). The 9th type is references to Object(an arrow). References may be null. In box-and-pointer notation, each variable is drawn as a labeled box and values are shown in the box. Addresses are represented by arrows to object instance. The golden rule: b &#x3D; a copies the bits from a into b. Passing parameters copies the bits Video 5:Test Your Understand of the GRoETest Your Understanding:Does the call to doStuff(walrus, x) have an affect on Warlus and&#x2F;or main’s x? 123456789101112public static void main(String[] args) &#123; Warlus walrus = new Warlus(3500, 10.5); int x = 9; doStuff(warlus, x); System.out.println(warlus); System.out.println(x);&#125;public static void doStuff(Warlus W, int x) &#123; W.weight = W.weight - 100; x = x - 3;&#125; A. Neither will change.B. warlus will lose 100 lbs, but main’s x will not change.√C. warlus will not change, but main’s x will decrease by 5.D. Both will decrease. 解开答案在视频的这一段01:06 简单的来说，就是因为对象类数组是通过一个指针进行访问的，不管是哪个函数，只要是引用到了warlus这个对象，那么都会通过对应的指针访问到这个变量当中，最终修改它最后的值，而数字x所存的是那个数字对应的二进制符号，那么在函数中修改的话，修改范围也就仅限那个函数![[..&#x2F;..&#x2F;Pasted image 20240124112801.png]] Video 6:Instantiating Arrays.视频讲解02:13 Declaration and Instantiation of Arrays Arrays are also Objects.As we’ve seen, object are (usually) instantiated using the new keyword. Planet p = new Planet(0, 0, 0, 0, 0, &quot;blah.png&quot;); int []x = new int[]&#123;0, 1, 2, 95, 4&#125;;1int [] a;//Declaration Declaration creates a 64 bit box intended only for storing a reference to an int array.No objects in instantiated(声明创建了一个64位的盒子，仅仅用于存储对int数组的引用，但是并没有实例化对象)1new int[]&#123;0, 1, 2, 95. 4&#125; Instantiates a new Object, in this case an int array. Object is anonymous上述两种类型创建的数组都是没有效果的，第一个只是声明了有一个a数组，然后并没有对它进行实例化。而第二个数组是anonymous(匿名的)，也就是说，并没有给它赋予名字，new这个函数返回的是一个地址，也就是存放这个数组的地址，但是显然没有一个名称赋予给这个地址的变量，那么在执行完这句话之后这个数组也就会消失。 Assignments of Arrays 1int [] a = new int[]&#123;0, 1, 2, 95, 4&#125;; Creates a 64 bit box for stroring an int array address.(declaration) Creates a new Object, in this case an int array.(instantiation) Puts the address of this new Object into the 64 bit box named a.(assignments) Note: Instantiated objects can be lost. If we were to reassign a to something else, we’d never be able to get the original Object back!也就是说，在上面的语句中，我们将声明、实例化和命名同时进行了，那么我们就会存储这么一个对象a，存了balabala这么一些东西。不过，有趣的是，即使我们存好之后，这个实例化的对象还是有可能会丢失的，假如我们重新new了一个新的对象令它&#x3D;a，那么我们之前创建的这balabala的变量就会被Java的收集器所消耗掉，也就是消失了。![[..&#x2F;..&#x2F;Pasted image 20240124114823.png]] Video 7:Introducing IntLists在了解完这一切之后，我们准备创建一个列表，因此，列表和数组之间的区别在于，列表可以任意增长，这与具有固定大小的数组不同。所以我们将完全从头开始构建它。 IntList Let’s define an IntList as an object containing two member variables: int first; IntList rest; And define two version of the same method: size() iterativeSize()列表将有两个变量，一个是名为first的整数，另一个是另一个int列表的指针或地址。为了简单起见，我们的列表仅仅只用来存储整数。 详情创建及过程视频见00:43 123456789public class IntList &#123; public int first; public IntList rest; public static void main(String args[]) &#123; &#125;&#125; 事实上在这个时候我们就已经创建好一个列表了。接下来我们添加东西 1234567891011121314151617public class IntList &#123; public int first; public IntList rest; public static void main(String args[]) &#123; IntList L = new IntList(); L.first = 5; L.rest = null; L.rest = new IntList(); L.rest.first = 10; L.rest.rest = new IntList(); L.rest.rest.first = 15; &#125;&#125; 通过Java Visualizer来理解过程![[..&#x2F;..&#x2F;Pasted image 20240124122549.png]]这样的代码看起来似乎略有尴尬，那么我们选择往前退一步来看。我们首先先创建一个构造函数 1234public IntList(int f, IntList r) &#123; first = f; rest = r; &#125; 然后我们将以相反的方式建立list 12345678910111213141516public class IntList &#123; public int first; public IntList rest; public IntList(int f, IntList r) &#123; first = f; rest = r; &#125; public static void main(String args[]) &#123; IntList L = new IntList(15, null); L = new IntList(10, L); L = new IntList(5, L); &#125;&#125; ![[..&#x2F;..&#x2F;Pasted image 20240124123309.png]]在这个时候，因为13的L还未执行完成，那么此时的L就是在12行创建出来的L不过这看起来似乎还是略有尴尬… Video 8:IntList size这个时候我们会发先如果我们想要访问这个列表的大小啊，获取第i个元素啊非常麻烦。这个时候，我们就需要对这个列表添加一个size方法和一个迭代size的方法，其行为就类似于Python中的length函数这个函数需要用递归的方法来实现，当我们每次访问它的时候，它会去问它剩下的rest里面还有多少个节点… 12345public int size() &#123; if(rest == null) return 1; return 1 + this.rest.size();&#125; 可以通过Visualizer来阅读每一步的操作![[..&#x2F;..&#x2F;Pasted image 20240124140057.png]] Video 9:IntList iterativeSize在上述方法的基础上，我们还可以考虑用迭代的方法来解决这个问题 1234567891011// Return the size of the list using no recursion! public int interativeSize() &#123; int p = this; int totalSize = 0; while(p != null) &#123; totalSize += 1; p = p.rest; &#125; return totalSize; &#125; Video 10:More IntList ExerciseChallenge Write a method int get(int i) that returns the ith item in the list. For simplicity, OK to assume the item exists. Front item is the 0th item. Ways to work: Paper(best) Laptop(see lecture) Head…先决条件12345678910111213141516171819202122public class IntList &#123; public int first; public IntList rest; public IntList(int f, IntList r) &#123; first = f; rest = r; &#125;// Return the size of this IntList public int size() &#123; if (rest == null) return 1; &#125; return 1 + this.rest.size();&#125;public static void main(String args[]) &#123; IntList L = new IntLise(15, null); L = new IntList(10, L); L = new IntList(5, L); System.out.println(L.get(0));&#125; 输出应该是5 实现函数想法如下: 12345678910public int get(int i) &#123; int a = 0; IntList p = this; while( a != i) &#123; a ++; p = p.rest; &#125; return p.first; &#125; 用迭代方式实现 12345public int get(int i) &#123; if(i == 0) return first; return rest.size(i - 1);&#125; 用递归的方式实现。","categories":[{"name":"CS61B","slug":"CS61B","permalink":"https://primeluoqiu.github.io/categories/CS61B/"}],"tags":[],"keywords":[{"name":"CS61B","slug":"CS61B","permalink":"https://primeluoqiu.github.io/categories/CS61B/"}]},{"title":"Hello World","slug":"计算机网络/Lecture2-Defining and Using Classes 类的定义和实例化","date":"2024-03-20T14:21:05.833Z","updated":"2024-03-20T14:24:19.350Z","comments":true,"path":"2024/03/20/计算机网络/Lecture2-Defining and Using Classes 类的定义和实例化/","link":"","permalink":"https://primeluoqiu.github.io/2024/03/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Lecture2-Defining%20and%20Using%20Classes%20%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E5%AE%9E%E4%BE%8B%E5%8C%96/","excerpt":"","text":"Class 2Video a:Defining and Instantiating Classes. 想要实际运行一个类，那么我们必须有main方法 假设我们目前创建了一个名为”Dog”的新类，并先暂时取消掉它的main方法。相反，我们给它一个方法，让它发出噪音。 12345public class Dog&#123; public static void makeNoise() &#123; System.out.println(&quot;Bark!&quot;); &#125;&#125; 那么，这个类就是可以编译的，那么当要运行这个程序的时候，就会报错![[Pasted image 20240106163816.png]]也就意味着这只狗不知道应该如何跑(run)对于Python来讲就是 12def makeNoise: print(&quot;Bark!&quot;) 没有任何调用makeNoise的地方于是我们放回main函数 12345678public class Dog&#123; public static void makeNoises() &#123; System.out.println(&quot;Bark!&quot;); &#125; public static void main(String args[]) &#123; makeNoises(); &#125;&#125; 于是，在我们重新编译运行之后我们看到![[Pasted image 20240106164240.png]]通常情况下，我们用Java创建的类没有main方法，就像狗这个类中一开始并没有main方法，相反，我们经常会有其他的类来使用Dog，因此我们创建一个DogLauncher.java 1234567/**The DogLauncher class will &#x27;test drive&#x27; the Dog class ,所以这只是为了展示这个‘狗’是如何工作的**/ //因此在这种情况下，DogLaunch应该有main方法 public class DogLaunch &#123; public static void main(String args[]) &#123; //在这里调用我们的狗类的制造噪音的方法 Dog.makeNoises();//这里的意思就是，告诉Java，我想让你去找狗这个类，然后找到它的对应的制造噪音的方法。 &#125; &#125; ![[Pasted image 20240106165927.png]]编译运行之后就是这个结果了 那么DogLaunch到底是做了什么呢？当它开始运行的时候，它会进入Dog类，然后采用makeNoise这个函数。那么这就是定义类的核心 DogAs we saw last time: Every method(a.k.a Function)is associated with some class. To run a class, we must define a main method. Not all classes have a main method.这里有一个main方法可以调用到其他类中的方法。一个类可以使用另一个类，这是我们能够将问题分解为更小的部分的全部基础。当然，很显然的是，在现实生活中，并不是所有的狗都是相同的。也就意味着，我们并不希望它们都发出相同的叫声，那么我们应该如何才能实现这个目标呢？ 有一个不那么好的方式是：(对于每只狗都创建一个新的类)We could create a separate class for every single dog out there, but this is going to get redundant in a hurry. 1234567891011public class MayaTheDog &#123; public static void makeNoise() &#123; System.out.println(&quot;arooooooooooooooo!&quot;); &#125;&#125;public class YapsterTheDog&#123; public static void makeNoise() &#123; System.out.println(&quot;awawwaawaw wawawawa&quot;); &#125;&#125; 虽然可以这么做，不过在品类多样之后，这显然变得很烦 Video b:Defining and Instantianing Classes那么，我们将使用的关键语言功能是，Java中的类不仅可以包含函数，当然还可以包含数据，以便更自然的表示狗或者其他的任何东西。那么我们就可以通过增强Dog类，以便让Dog拥有属性，例如大小。而这个Class将会成为其他dog的模板，然后我们可以将这个实例化为我们可以操作的特定对象 Object InstantiationClasses can contain not just functions(a.k.a methods), but also data. Classes can be instantiated as objects. We’ll create a single Dog class, and then create instances of this Dog. The classes provides a blueprint that all Dog objects will follow.重写dog class例子如下123456789101112131415public class Dog&#123; //狗不只是只有制造噪音，还有一些属性将是狗所拥有的，例如重量 public int weightInPounds; //然后更改下面的函数 public static void makeNoises() &#123; if(weightInPounds &lt; 10) &#123; System.out.println(&quot;yip!&quot;); &#125; else if (weightInPounds &lt; 30) &#123; System.out.println(&quot;bark!&quot;); &#125; else &#123; System.out.println(&quot;wooooof!&quot;); &#125; &#125; &#125; 当我们在编译这个程序的时候，会发现报这样的错误![[Pasted image 20240106192022.png]]对于我们来说，最快的解决方式就是删掉方法当中的static即可，现在再尝试编译的话就可以通过了。123456789101112131415public class Dog&#123; //狗不只是只有制造噪音，还有一些属性将是狗所拥有的，例如重量 public int weightInPounds; //然后更改下面的函数 public void makeNoises() &#123; if(weightInPounds &lt; 10) &#123; System.out.println(&quot;yip!&quot;); &#125; else if (weightInPounds &lt; 30) &#123; System.out.println(&quot;bark!&quot;); &#125; else &#123; System.out.println(&quot;wooooof!&quot;); &#125; &#125; &#125; 以上就是对Dog的一个模板，它可以根据狗的体重（磅数）有不同的行为。这个时候我们再DogLaunch编译一下，我们会发现![[Pasted image 20240106192733.png]]或许你也会想像上面的报错一样只删掉DogLaunch中的static，但是显然这是错误的，这个时候我们就要用到一个新语法。1Dog d = new Dog(); 这意味着创建一个狗，一只新狗，在这种情况下，我们称那只狗为d，那么接下来的语法将会是这样的123456789/**The DogLauncher class will &#x27;test drive&#x27; the Dog class ,所以这只是为了展示这个‘狗’是如何工作的**/ //因此在这种情况下，DogLaunch应该有main方法 public class DogLaunch &#123; public static void main(String args[]) &#123; //在这里调用我们的狗类的制造噪音的方法 Dog d = new Dog(); d.weightInPounds = 25; d.makeNoises(); &#125;&#125; 就是相当于，在这里我们来问d，让他发出声音，这个时候它去找makeNoise这个方法，然后这里只有三种声音，然后就会有这样的执行结果![[Pasted image 20240106194134.png]]如果我们将25换成51的话并重新编译的话，我们就会得到woof还有最后一点调整可能会有另外的一种想法，例如为什么不在构造这个d的时候直接在后面的()当中赋值呢？就是给定它作为Dog创建过程的参数。为了实现这个呢（当然，直接这么做是不可以的）![[Pasted image 20240106194511.png]]也就是意味着它并不知道应该如何处理这个数字。因此，为了处理这个问题，我们需要在Dog这个类中创建一个特殊的东西，它有点像方法，被称为构造函数1234// One integer constructor for dogs. public Dog(int w) &#123; &#125; 因此，当调用new Dog并给出一个整数的时候，就会调用这个构造函数，这将指定Dog是如何创建的 接下来，我们对这个构造函数里的WeightPounds设置为w 1234// One integer constructor for dogs. public Dog(int w) &#123; weightPounds = w;&#125; 接下来再编译运行的话，就可以直接得到Wooof了![[Pasted image 20240106195124.png]] Video c:Terminology在进行下一步之前，我们首先要搞清楚Java的一些相关术语 123456789101112131415public class Dog&#123; public int weightInPounds; public Dog(int startingWeight) &#123; weightPounds = startingWeight; &#125; public void makeNoise() &#123; if(weightInPounds &lt; 10) &#123; System.out.println(&quot;yipyipyip&quot;); &#125; else if (weightInPounds &lt; 30) &#123; System.out.println(&quot;bark, bark.&quot;); &#125; else &#123; System.out.println(&quot;woof&quot;)&#125; &#125;&#125; 这是一个例子，我们从中来剖析一些术语。 1public int weightInPounds; Instance variable. Can have as many of these as you want.一个实例变量，是一个跟踪当前类的特定实例的属性的变量，我们在这里定义了一个狗的体重，但是原则上我们还可以有它的身高，喜欢的食物，喜欢的颜色等等 123public Dog(int startingWeight) &#123; weightPounds = startingWeight;&#125; Constructor(similar to a method, but not a method). Determines how to instantiate the class.这里是构造函数：我们目前只有一个参数来设置单个实例变量，不过在原则上，可以在构造函数中执行任何操作，但通常最重要的事情之一是设置所有实例变量，不过也不必设置所有的实例变量，可以让他们保持默认值。构造函数告诉我们如何构造对象的实例。 123456789public void makeNoise() &#123; if(weightInPounds &lt; 10) &#123; System.out.println(&quot;yipyipyip&quot;); &#125; else if (weightInPounds &lt; 30) &#123; System.out.println(&quot;bark, bark.&quot;); &#125; else &#123; System.out.println(&quot;woof&quot;)&#125; &#125;&#125; Non-static method, a.k.a Instance Method.Idea: If the method is going to be invoked by an instance of the class(as in the next slide), then it should be non-static. Roughly speaking: If the method needs to use “my instance variables”, the method must be non-static. 非静态方法（实例方法）：也就是由特定实例调用的方法。例如我们有一个叫做Steven的狗 ，它在Steve变量中，那么当我们告诉Steve，Steve.MakeNoise的时候，它就会使用它的体重来决定它要做什么（怎么叫）。当我们阅读方法的时候，可以说，如果我们的体重小于10，那么yipyipyip，这意味着他是一个非静态的方法，事实上，如果这个方法需要使用任何实例变量，那么在定义的时候加入static关键字就会令Java感到困惑，会提示我们不能从静态上下文访问实例变量。 再来点术语 Instantiating a Class and Terminology12345678910public class DogLauncher &#123; public static void main (String[] args) &#123; Dog smallDog; new Dog(20); smallDog = new Dog(5); Dog hugeDog = new Dog(150); smallDog.makeNoise(); hugeDog.makeNoise(); &#125;&#125; 我们最开始的DogLauncher实现的功能很简单，只是让它发出了一下声音。但是我们可能会遇到更复杂的情况（如上） 1Dog smallDog; Declaration of a Dog variable.声明了一个Dog型的变量，有一个Dog变量叫做smallDog，不过我们目前还没创造出任何种类的狗，也就是没有实例化。 1new Dog(20); Instantiation of the Dog class as a Dog Object.这会创建一条尺寸为20的Dog，但是不会将它放置在任何地方，在这种情况下，因为没有人使用它，它只会被所谓的垃圾收集器给销毁掉。、意味着，如果实例化Dog，他们将被某种无情的垃圾收集器销毁 1smallDog = new Dog(5); Instantiation and Assignment.现在呢，如果想要避免失去这条狗，我们会想把它放在某个地方，所以上述代码实例化了一只狗，然后将其分配给一个已经声明的变量。那么这就是实例化和赋值。尽管通常情况下，我们要做的就是同时完成这三项工作。 1Dog hugeDog = new Dog(150); Declaration, Instantiation and Assignment.声明有一个名为HugeDog的变量，我们实例化它，然后将new Dog分配给这个变量 1hugeDog.makeNoise(); Invocation of the 150lb Dog’s makeNoise method.The dot notation means that we want to use a method or variable belonging to hugeDog,or more succinctly, a member of hugeDog.在这里有一些调用，在这里，我们想要HugeDog调用makeNoise方法。可以将这个.视为其成员的意思，所以它属于hugeDog这类。 Video d:Arrays of ObjectsTo create an array of objects: First use the new keyword to create the array. Then use new again for each object that you want to put in the array.Example:1234Dog[] dogs = new Dog[2]; //Create an array of Dogs of size 2.dogs[0] = new Dog(8);dogs[1] = new Dog(20);dogs[0].makeNoise(); //Yipping occurs After code runs![[Pasted image 20240107170741.png]]在项目0中，不仅要创建对象，还要创建对象数组。那么，如果想要创建一个对象数组而不是整数数组，那么就要以两种不同的方式使用new，首先要使用new来创建一个实际的数组。此时还没有创建任何Dog，可以把这个操作想象成建造了目前空着的狗屋，然后后面才会说，在狗屋0中放一只小狗，在狗屋1中放一只中型狗。这样在最后就可以看见两个狗屋辣。 然后我们可以问，嘿，狗屋0里的那个，发出声音，然后它就会YipYipYip Class 3Video a:Static vs Instance Methods我们现在知道什么Key differences between static and non-static (a.k.a instance) methods: Static methods are invoke using the class name, e.g. Dog.makeNoise(); Instance methods are invoked using an instance name, e.g. maya.makeNoise(); Static methods can’t access “my” instance variables, because there is no “me”.Static123public static void makeNoise() &#123; System.out.println(&quot;Bark!&quot;);&#125; This method cannot access weightlnPound.Invocation:Dog.makeNoise();目前我们知道存在静态方法（在声明中包含静态一词）和非静态方法（也被称为实例方法），他们没有静态方法。因此静态方法是使用类名调用的。所以当我们想要调用的时候，就要选择上述的方式Non-static123456789public void makeNoise() &#123; if(weightInPounds &lt; 10) &#123; System.out.println(&quot;yipyipyip&quot;); &#125; else if (weightInPounds &lt; 30) &#123; System.out.println(&quot;bark, bark.&quot;); &#125; else &#123; System.out.println(&quot;woof&quot;); &#125;&#125; Invocation:maya = newDog(100); maya.makeNoise();而这种即时方法，是使用实例名称调用的。所以创建了一个特定的Dog并说发出声音 他们之间的重要区别是 静态方法不能访问实例变量，就是对于静态而言，不能用System.out.println(&quot;makeNoise()&quot;);这样，传入不了实际的变量。而对于非静态方法的话，就是创建出来了一个新的狗并赋予了实际变量，然后就可以通过调用函数输出特定的声音。 虽然非静态方法非常的强势，但是静态方法也有它的用武之地，例如某些类从来没有被实例化，例如数学类，我们通常会这么做： 1x = Math.round(5.6); 这明显要比 12Math m = new Math();x = m.round(); 看来要好很多也就是说，静态方法自然有他们用起来更自然的地方。 现在，有时类实际上也可以混合使用，可以拥有一个即是静态方法又是非静态方法的类看实例假设我们现在要对Dog实现一个方法能够比较两只狗。所以这个时候需要制作另一只狗，需要在DogLauncher中 1Dog d2 = new Dog(100); 然后例如我们要实现比大小，例如比较 1Dog bigger = Dog.maxDog(d, d2); 这个时候我们想要用一个比较公平的裁判来解决这个问题。那么，我们在Dog中解决这个方法 12345public static Dog maxDog(Dog d1, Dog d2)&#123; //不要忘记加返回类型和静态哦（因为是用类名调用该方法 if(d1.weightInPounds &gt; d2.weightInPounds) return d1; return d2; &#125; 试验一下![[Pasted image 20240110091345.png]]显然这并没有输出，那么需要加上一句让大狗发出声音的语句 1bigger.makeNoise(); ![[Pasted image 20240110091642.png]] 那么可以用非静态方法解决这个问题吗？当然是可以的 123456789public class DogLaunch &#123; public static void main(String args[]) &#123; Dog d = new Dog(15); Dog d2 = new Dog(100); Dog bigger = d.maxDog(d2); bigger.makeNoise(); &#125;&#125; 12345678910111213141516171819202122232425262728public class Dog&#123; public int weightInPounds; public Dog(int w) &#123; weightInPounds = w; &#125; public void makeNoise() &#123; if(weightInPounds &lt; 10) &#123; System.out.println(&quot;yip!&quot;); &#125; else if (weightInPounds &lt; 30) &#123; System.out.println(&quot;bark!&quot;); &#125; else &#123; System.out.println(&quot;wooooof!&quot;); &#125; &#125; public static Dog maxDog(Dog d1, Dog d2)&#123; if(d1.weightInPounds &gt; d2.weightInPounds) return d1; return d2; &#125; public Dog maxDog(Dog d2) &#123; if(weightInPounds &gt; d2.weightInPounds) return this; return d2; &#125;&#125; ![[Pasted image 20240110092342.png]]编译之后依旧得到woooof！在这种情况下，这只狗会自己进行判断自己的体重和另一只狗的体重哪个重。上述是两种方法，一种是加入评委，一种是自己判断大小 作为一个快速说明，我们也可以定义静态变量。他们是适用于所有狗的属性，所有狗共享这个属性，例如我们给这些狗添加一个种类 1public static String binomen = &quot;Canis familiar&quot;; 12System.out.println(d.binomen);System.out.println(d2.binomen); ![[Pasted image 20240110093004.png]]但是对于上述的d1和d2并不是一种很有效的方式。例如我并不会问嘿那条狗，你的学名是什么，而应该是问，这些狗的学名是什么。上述方式相对来说会令人比较困惑。所以，如果我们有一个静态变量的话，那么就使用类名作为一种好一些方式来确保我们知道我们正在处理什么。 1System.out.println(Dog.binomen); Some knowledgepoint Static vs. Non-staticA class may have a mix of static and non-static members. A variable or method defined in a class is also called a member of that class. Static members are accessed using class name, e.g. Dog.binomen. Non-static members cannot be invoked using class name:Dog.makeNoise() Static method must access instance variables via a specfic instance e.g. d1. Video b:ExerciseQuestion:Will this program compile? If so, what will it print? 123456789101112131415161718public class DogLoop &#123; public static void main(String args[]) &#123; Dog smallDog = new Dog(5); Dog mediumDog = new Dog(25); Dog hugeDog = new Dog(150); Dog[] manyDogs = new Dog[4]; manyDogs[0] = smallDog; manyDogs[1] = hugeDog; manyDogs[2] = new Dog(130); int i = 0; while(i &lt; manyDogs.length) &#123; Dog.maxDog(manyDogs[i], mediumDog).makeNoise(); i = i + 1; &#125; &#125;&#125; Video c:Exercise Solution在这个网站当中可以将每一步可视化，建议点入之后操作[http://goo.gl/HLzN6s]，认真查看问题所在和结果， 答案是 12345bark!woof!woof!Error:... Class 4Video a:Managing Complexity, LargerThanFourNeighborsManaging Complexity with Classes and Static MethodsSome obvious questions arise: Why does Java force us to use classes? Why have static methods at all? The Reason: Fewer choices means fewer ways to do things. Example：Declaring a method static means you can’t use any instance variables in that method. Fewer ways to do things often means less complexity 更少的选择意味着做事的方法更少，如果将一个方法设置为静态，就会对可能得情况施加限制。例如不能使用实例变量。从根本来说，就是降低代码的复杂性 Goal: largerThanFourNeighbors Suppose we want to write a method: 1public static Dog[] largerThanFourNeighbors(Dog[] dogs) This method will return a new array that contains every Dog that is larger than its 4 closest neighbors, i.e. the two on the left and the two in the right.If there are not enough neighbors, i.e. you ‘re at the end of the array, then consider just the neighbrs that exist.For example: input:Dog with size [ 10, 20, 30, 25, 20, 40, 10 ] Returns: Dog with size[ 30, 40]. 30 is the larger than 10,20,25 and 20. 40 is greater than 25, 20, and 10 If input Dog sizes are[10, 15, 20, 15, 10, 5, 10, 15, 22, 20],what will be the size of the Dogs returned？ It Will be [20, 22] Video b:LargerThanFourNeighbors With No Helper Methods在不考虑策略的情况下暂时完成code:打开Intellij 123456789101112131415161718192021222324252627public class DogProblem &#123; public staitc Dog[] largerThanFourNeighbors(Dog[] dogs) &#123; return dogs; &#125; public static void main(String args[]) &#123; Dog[] dogs = new Dog[] &#123; new Dog(10), new Dog(15), new Dog(20), new Dog(15), new Dog(10), new Dog(5), new Dog(10), new Dog(15), new Dog(22), new Dog(15), new Dog(20) &#125;; Dog[] bigDogs1 = largerThanFourNeighbors(dogs); for(int k = 0; k &lt; bigDogs1.length; k ++)&#123; System.out.print(bigDogs1[k].weightInPounds + &quot; &quot;); &#125; System.out.println();; &#125;&#125; 先键入这些基础的输入输出语句，我们的函数目前只能返回dogs。所以首先我们看向我们的larger函数，那么我们首先要做的只能是迭代所有的狗，这看起来很自然，不过棘手的问题是如何迭代邻居们。一个想法是：如果我们从-2到2，那么这应该是迭代狗的邻居。 12345for(int i = 0; i &lt; dogs.length; i ++)&#123; for(int j = -2; j &lt;= 2;j ++)&#123; Dog neighborDog = dogs[i + j] &#125;;&#125; 接下来就要处理边界的一些问题，例如我们如果从0开始的话，那么i + j最开始是-2，很明显是数组越界的行为，还有如果j到了数组的最右边，同样也会存在数组越界的问题。 1234567891011121314public staitc Dog[] largerThanFourNeighbors(Dog[] dogs) &#123; for(int i = 0; i &lt; dogs.length; i ++)&#123; for(int j = -2; j &lt;= 2;j ++)&#123; if(i + j &lt; 0) &#123; continue; &#125; if(i + j &gt;= dogs.length) &#123; break; &#125; Dog neighborDog = dogs[i + j]; &#125;; &#125;&#125; 那么有了这只邻居狗之后，我们应该如何做呢？定义一个布尔值，默认是正确的，来定义默认情况下我们本身就是最大的狗，但如果邻居狗的体重大于或者等于当前狗的体重，那么最大就是假的，那么有一个重要的事实是，在边界问题上，如果j&#x3D;0，那么就会将自己和自己进行比较，那么显然是没必要的，那么代码如下 123456789101112131415161718192021public staitc Dog[] largerThanFourNeighbors(Dog[] dogs) &#123; for(int i = 0; i &lt; dogs.length; i ++)&#123; boolean largest = true; for(int j = -2; j &lt;= 2;j ++)&#123; if(i + j &lt; 0) &#123; continue; &#125; if(i + j &gt;= dogs.length) &#123; break; &#125; if(j == 0) &#123; continue; &#125; Dog neighborDog = dogs[i + j]; if(neighborDog.weightInPounds &gt;= dogs[i].weightInPounds) &#123; largest = false; &#125; &#125;; &#125;&#125; 这只是考虑，但是发现有一些复杂 Video c:LargeThanFourNeighbors With Helper MethodsOpen Intellij接下来我们使用一些辅助方法来编写代码，辅助方法的好处是让我们在编辑他们之前先使用他们。那么最初的框架就是 1234567891011public static Dog[] largerThanFourNeighbors(Dog[] dogs) &#123; for(int i = 0; i &lt; dogs.length; i ++)&#123; if(isBiggestOfFour(dogs, i)) &#123; &#125; &#125;&#125;//先拆出来一个问题：是不是邻居四个当中的一个/* Return true if dogs[i] is larger than its four neighbors */public static boolean isBiggestFour(Dog[] dogs, int i) &#123;&#125; 拆出问题之后，我们来继续完成主函数因为主函数最后返回的值是一个Dog类型的数组，那么，我们就要定义一个返回数组和要返回的数组的大小 12345public static Dog[] largerThanFourNeighbors(Dog[] dogs) &#123; Dog[] returnDogs = new Dog[dogs.length]; int cnt = 0; ...//内容同上&#125; 然后我们对如果这个狗是它的四个邻居当中最大的，那么我们将答案传递给我们最后要返回的那个Dog组，然后完成主函数return returnDogs; 1234567891011public static Dog[] largerThanFourNeighbors(Dog[] dogs) &#123; Dog[] returnDogs = new Dog[dogs.length]; int cnt = 0; for(int i = 0; i &lt; dogs.length; i ++)&#123; if(isBiggestOfFour(dogs, i)) &#123; returnDogs[cnt] = dogs[i]; cnt ++; //这样有利于我们进行统计 &#125; &#125; return returnDogs;&#125; 这段代码正确的叙述了读取它，得到返回值。我们通过i小于等于数组的长度来遍历这一整个大的数组。如果是四个当中最大的，那么我们将它添加到这个新的数组当中并返回它。我们现在回到第二个函数，因为对于主函数我们已经不用考虑它了，接下来我们只需要考虑给出是或否的答案就可以了。 123456boolean isBiggest = true; for(int j = -2; j &lt;= 2;j ++) &#123; &#125; &#125; 我们依旧默认最大值为真。在前面的实例中，我们使用了一堆if语句，当然，在这里，我们还是可以选择用辅助方法来解决这个问题 1234567public static boolean validIndex(Dog[] dogs, int i) &#123; if(i &lt; 0) return false; if(i &gt;= dogs.length) return false; return true; &#125; 在我们实现完这个函数之后，我们回头看调用它的那个方法，对于方法来讲，我们只需要完成比较的那一部分即可 1234567891011121314public static boolean isBiggestOfFour(Dog[] dogs,int i) &#123; boolean isBiggest = true; for(int j = -2; j &lt;= 2;j ++) &#123; int comparedIndex = i + j; if(validIndex(dogs, comparedIndex)) &#123; if(dogs[comparedIndex].weightInPounds &gt;= dogs[i].weightInPounds) &#123; isBiggest = false; &#125; &#125; &#125; return isBiggest; &#125; 但是在完成这项之后，我们发现我们似乎遗漏掉了对自己和自己进行比较的情况 1234567891011121314151617public static boolean isBiggestOfFour(Dog[] dogs,int i) &#123; boolean isBiggest = true; for(int j = -2; j &lt;= 2;j ++) &#123; int comparedIndex = i + j; //只是命名来方便叙述 if(validIndex(dogs, comparedIndex)) &#123; // avoid comparing ourself to ourself. if(j == 0) &#123; continue; &#125; if(dogs[comparedIndex].weightInPounds &gt;= dogs[i].weightInPounds) &#123; isBiggest = false; &#125; &#125; &#125; return isBiggest; &#125; 这样即可尝试找出如何让程序更加漂亮。整个程序如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package Lecture2; public class DogProblem &#123; public static Dog[] largerThanFourNeighbors(Dog[] dogs) &#123; Dog[] returnDogs = new Dog[dogs.length]; int cnt = 0; for(int i = 0;i &lt; dogs.length;i ++) &#123; if(isBiggestOfFour(dogs, i)) &#123; returnDogs[cnt] = dogs[i]; cnt ++; &#125; &#125; return returnDogs; &#125; /* Return true if dogs[i] is larger than its four neighbors */ public static boolean isBiggestOfFour(Dog[] dogs,int i) &#123; boolean isBiggest = true; for(int j = -2; j &lt;= 2;j ++) &#123; int comparedIndex = i + j; //只是命名来方便叙述 if(validIndex(dogs, comparedIndex)) &#123; // avoid comparing ourself to ourself. if(j == 0) &#123; continue; &#125; if(dogs[comparedIndex].weightInPounds &gt;= dogs[i].weightInPounds) &#123; isBiggest = false; &#125; &#125; &#125; return isBiggest; &#125; public static boolean validIndex(Dog[] dogs, int i) &#123; if(i &lt; 0) return false; if(i &gt;= dogs.length) return false; return true; &#125; public static void main(String args[]) &#123; Dog[] dogs = new Dog[] &#123; new Dog(10), new Dog(15), new Dog(20), new Dog(15), new Dog(10), new Dog(5), new Dog(10), new Dog(15), new Dog(22), new Dog(15), new Dog(20) &#125;; Dog[] bigDogs1 = largerThanFourNeighbors(dogs); for(int k = 0; k &lt; bigDogs1.length; k ++)&#123; System.out.print(bigDogs1[k].weightInPounds + &quot; &quot;); &#125; System.out.println(); &#125; &#125; ![[Pasted image 20240113142014.png]]我们得到了20和22，这是正确的结果，但是为什么后面还有一串错误信息呢，是因为在答案数组的最后有很多空值，其实这个并没有什么问题，只是会输出这样的信息。我们可以选择用一个方法来消除这个错误 12345678//cnt is the number of non-null items public static Dog[] arrayWithNoNulls(Dog[] dogs, int cnt) &#123; Dog[] noNullDogs = new Dog[cnt]; for(int i = 0; i &lt; cnt; i ++) &#123; noNullDogs[i] = dogs[i]; &#125; return noNullDogs; &#125; 最终代码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package Lecture2; public class DogProblem &#123; public static Dog[] largerThanFourNeighbors(Dog[] dogs) &#123; Dog[] returnDogs = new Dog[dogs.length]; int cnt = 0; for(int i = 0;i &lt; dogs.length;i ++) &#123; if(isBiggestOfFour(dogs, i)) &#123; returnDogs[cnt] = dogs[i]; cnt ++; &#125; &#125; returnDogs = arrayWithNoNulls(dogs, cnt); return returnDogs; &#125; //cnt is the number of non-null items public static Dog[] arrayWithNoNulls(Dog[] dogs, int cnt) &#123; Dog[] noNullDogs = new Dog[cnt]; for(int i = 0; i &lt; cnt; i ++) &#123; noNullDogs[i] = dogs[i]; &#125; return noNullDogs; &#125; /* Return true if dogs[i] is larger than its four neighbors */ public static boolean isBiggestOfFour(Dog[] dogs,int i) &#123; boolean isBiggest = true; for(int j = -2; j &lt;= 2;j ++) &#123; int comparedIndex = i + j; //只是命名来方便叙述 if(validIndex(dogs, comparedIndex)) &#123; // avoid comparing ourself to ourself. if(j == 0) &#123; continue; &#125; if(dogs[comparedIndex].weightInPounds &gt;= dogs[i].weightInPounds) &#123; isBiggest = false; &#125; &#125; &#125; return isBiggest; &#125; public static boolean validIndex(Dog[] dogs, int i) &#123; if(i &lt; 0) return false; if(i &gt;= dogs.length) return false; return true; &#125; public static void main(String args[]) &#123; Dog[] dogs = new Dog[] &#123; new Dog(10), new Dog(15), new Dog(20), new Dog(15), new Dog(10), new Dog(5), new Dog(10), new Dog(15), new Dog(22), new Dog(15), new Dog(20) &#125;; Dog[] bigDogs1 = largerThanFourNeighbors(dogs); for(int k = 0; k &lt; bigDogs1.length; k ++)&#123; System.out.print(bigDogs1[k].weightInPounds + &quot; &quot;); &#125; System.out.println(); &#125; &#125; ![[Pasted image 20240113143928.png]]这段代码包含很多东西首先叙述性更好其次编写时更容易正确执行再次如果遇到到麻烦，则更容易调试 用好辅助方法，会事半功倍","categories":[{"name":"CS61B","slug":"CS61B","permalink":"https://primeluoqiu.github.io/categories/CS61B/"}],"tags":[],"keywords":[{"name":"CS61B","slug":"CS61B","permalink":"https://primeluoqiu.github.io/categories/CS61B/"}]},{"title":"Hello World","slug":"计算机网络/Lecture1-Introduction","date":"2024-03-20T14:21:05.826Z","updated":"2024-03-20T14:24:17.895Z","comments":true,"path":"2024/03/20/计算机网络/Lecture1-Introduction/","link":"","permalink":"https://primeluoqiu.github.io/2024/03/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Lecture1-Introduction/","excerpt":"","text":"多做事来获得能力是很重要的 Class 1:Hello World 课程链接：[[https://www.youtube.com/watch?v=E3noTK6T8AE&amp;list=PLnp31xXvnfRq5wRDN8wZFy7GrrJXUtr1q&amp;index=4]] Java 和Python的对比Java 是一种认为类非常重要的语言，事实上呢，所有的代码都必须在类中。它是一种迫使我们面向对象的语言，那么因此定义这个类的话。我们首先要做的是定义一个公共类Hello World.可以认为public class就像另一种语言中的类定义一样 123public class HelloWorld&#123;&#125; 这个时候，我们会发现报错是在类HelloWorld中找不到main方法，即报错信息中会显示the main method as: public static void main(String[] args)，然后我们复制这段代码之后 12345public class HelloWorld&#123; public static void main(String[] args) &#123; &#125;&#125; 我们会发现这段代码可以工作了那么从中我们可以总结出来有关Java这个语言什么样子的特性呢？ In java, all code must be part a class Classes are defined with “public class CLASSNAME” We use { } to delineate the begining and ending of things. We must end lines with a semicolon. The code we want to run must be inside public static void main(String[] args). Class 2:Static Typing 课程链接：[[https://www.youtube.com/watch?v=xX04gYy9en0&amp;list=PLnp31xXvnfRq5wRDN8wZFy7GrrJXUtr1q&amp;index=5]] 一个例题：在Python中和Java中输出从0-9这十个数。Python只是为了用来对比 1234x = 0while x &lt; 10 print(x) x ++ Java： 123456789public class HelloNumbers&#123; public static void main(String[] args) &#123; x = 0; while(x &lt; 10)&#123; System.out.println(x);//ln指line x = x + 1; &#125;; &#125;&#125; 在看了Python的语言之后，你似乎也想在Java中如是这么写，但是很显然，这个在Java的编译中是错误的。(Error:cannot find symbol x),实际上，编译器只是想要提醒我们需要声明变量，也就意味着，在使用这个变量之前，要先声明它存在。所以，正确的应该是 123456789public class HelloNumbers&#123; public static void main(String[] args) &#123; int x = 0; while(x &lt; 10)&#123; System.out.println(x);//ln指line x = x + 1; &#125;; &#125;&#125; 对于Java和Python在变量的方面存在一些很大的差异，使用Python这种非所谓静态类型语言的语言，可以随机创建变量。而在Java中，变量有特定的类型，这些类型永远不会改变。Java会在运行这个程序之前先检验一遍变量的类型是不是正确。接下来是一段总结 Before Java variables can be used, they must be declared. Java variables must have a specific type. Java variables types can never change. 对于现在来讲，类型的错误不仅仅只会存在于Java中，在Python中，如果我们进行这样的语句的时候 1print(&quot;horse&quot; + 5) 我们就会看到出现错误，而且是建立在之前程序都进行输出了的情况下，指在本节最开始的地方添加了这么一句话，那么久就会发现程序是先输出了0123456789之后才输出了报错信息。但是对于Java来说，当我们尝试运行存在类型错误的代码时，我们在此之前并不会得到任何输出，而是给予了我们一大堆的错误信息，由此我们可以得到Java的第四条特性4. Types are varified before the code even runs !!!在这里，这段代码基本上在运行之前就获得了类型正确的证书，这意味着(静态类型的三个优点) 最终用户遇到的错误会更少 使我们更容易调试 当我们使用代码的时候，我们应该知道一切应该是什么，例如x应该始终是整数 Class 3: Declaring Functions接下来是有关定义函数的内容 还是先以一个Python程序来作为示例 12345def large(x, y): if(x &gt; y): return x return yprint(large(-5, 10)) 我们最终可以得到10，那么Java版本长什么样子呢？(我们给这个Java文件命名为LargeDemo) 12345678//如果我们想要定义一个函数，我们不能把它放到这里public class LargeDemo&#123;//所以实际上应该在这里进行函数定义 public static void main(String[] args) &#123; &#125;&#125; 我们要记住，在Java中，所有代码都必须是类的一部分，而在Java中使用特殊短语public static而不是def。那么这个函数目前看起来应该这么写 12345678910public class LargeDemo&#123; public static large(x, y)&#123; if(x &gt; y) return x; return y; &#125; public static void main(String[] args) &#123; &#125;&#125; 现在，如果尝试对其进行编译，它会给我们提醒说需要告诉他x是什么，y是什么，而且还要说返回的值是一个什么类型的值。接下来的函数应该是长这个样子的。最后，我们想要在主函数当中调用这个函数的话，就应该用 12345678910public class LargeDemo&#123;public static int large(x, y) &#123; if(x &gt; y) return x; return y;&#125; public static void main(String[] args) &#123; System.out.println(large(-5, 10)); &#125;&#125; 在这里有一些注意事项 Functions must be declared as a part of a class in Java.A function that is part of a class is called method.So, in Java, all functions are methods To define a function in Java, we use “public static”.We will see alternate ways of defining functions Later. All parameters of a function must have a declared type, and the return value of the function must have a declared type.那么因此，我们在定义函数的时候就不可以定义有两种返回值的函数，类似int String ...有一个重点是，我们完全可以不对函数的名字或者类的名字起名起的如此繁琐，我们完全可以用一个符号来代替一堆繁琐的字符，类似f(x, y)这样，但是我们最后选择以相对来说比较繁琐的方式来命名这个函数的原因是 使我们的代码看起来更加可读 还有一个建议是在编写函数的时候，我们可以选择在它的头顶添加一些字符让他看起来更加的可读，例如 12/*Returns the large of x and y.*/public static int large(x, y) &#123; 最后其实会发现，可读性方便的还是自己。 Class4.Reflection1.Java and Object OrientationJava is an object oriented language with strict declarations: Every Java file must contain a class declaration.* All code lives inside a class*, even helper functions,global constants, etc. To run a Java program, you typically define a main method using public static void main(String[] args) * This is not completely true, e.g. we can also declare “interface” in Java files that may contain code.We’ll cover these later. 2.Java and Static TypingJava is statically typed! All variables, parameters, and methods must have a declared type. That type can never change. Expressions also have a type. The compiler checks that all the types in your program are compatible before the program ever runs! This is unlike a language like Python, where type checks are performed DURING execution. 3.Reflections on Static TypingThe Good: Catches certain types of errors, making it easior on the programmer to debug their code. Type errors can(almost) never occur on the end user’s computer(Even their Android). Makes it easier to read about code. Code can run more effciently, e.g. no need to do expensive runtime type checks. The Bad: Code is more verbose. Code is less general. There is a way around this in Java.例如，还是之前的比较大小的函数，对于Python而言，我们可以对除了字符串之外的所有类型进行比大小的操作，而在Java中就必须要重新写类似于float类型的函数这样才可以进行大小的比较。","categories":[{"name":"CS61B","slug":"CS61B","permalink":"https://primeluoqiu.github.io/categories/CS61B/"}],"tags":[],"keywords":[{"name":"CS61B","slug":"CS61B","permalink":"https://primeluoqiu.github.io/categories/CS61B/"}]},{"title":"第三周计划表","slug":"每周学习计划/第三周学习安排","date":"2024-03-18T02:51:18.471Z","updated":"2024-03-24T13:34:08.487Z","comments":true,"path":"2024/03/18/每周学习计划/第三周学习安排/","link":"","permalink":"https://primeluoqiu.github.io/2024/03/18/%E6%AF%8F%E5%91%A8%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/%E7%AC%AC%E4%B8%89%E5%91%A8%E5%AD%A6%E4%B9%A0%E5%AE%89%E6%8E%92/","excerpt":"","text":"本周学习内容预计 郑铨《计算机网络》:看完1.7 CS61B: 7 - 10 CS61A: 看前两章 深入理解计算机系统 :第一章看完 CS61C：前两周内容 !!! 切记随时更新进度和笔记","categories":[{"name":"大二下","slug":"大二下","permalink":"https://primeluoqiu.github.io/categories/%E5%A4%A7%E4%BA%8C%E4%B8%8B/"}],"tags":[],"keywords":[{"name":"大二下","slug":"大二下","permalink":"https://primeluoqiu.github.io/categories/%E5%A4%A7%E4%BA%8C%E4%B8%8B/"}]}]}