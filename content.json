{"meta":{"title":"秋过冬漫长","subtitle":"没有比脚更长的路,走过去就好了","description":"","author":"LuoQiu","url":"https://PrimeLuoQiu.github.io"},"pages":[{"title":"abot","date":"2024-03-23T09:13:50.000Z","updated":"2024-03-23T09:13:50.763Z","comments":true,"path":"about/index.html","permalink":"https://primeluoqiu.github.io/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2024-03-23T11:22:46.000Z","updated":"2024-03-23T14:14:46.208Z","comments":true,"path":"categories/index.html","permalink":"https://primeluoqiu.github.io/categories/index.html","excerpt":"","text":"title: 大二下date: 2024-03-18 12:24:49 title: CS61Adate: 2024-03-18 12:24:50 title: CS61Bdate: 2024-03-18 12:24:58title: acwingdate: 2024-03-18 12:24:58 title: 计算机网络date: 2024-03-18 12:24:00 title: 学校作业date: 2024-03-23 20:30:00 title: Algorithmdate: 2024-03-23 20:30:00"}],"posts":[{"title":"","slug":"SchoolHomework/计网/Experiment2","date":"2024-03-25T05:46:43.090Z","updated":"2024-03-25T05:46:43.419Z","comments":true,"path":"2024/03/25/SchoolHomework/计网/Experiment2/","link":"","permalink":"https://primeluoqiu.github.io/2024/03/25/SchoolHomework/%E8%AE%A1%E7%BD%91/Experiment2/","excerpt":"","text":"五、实验步骤 1.数据规划（课程目标1） 表1-交换机VLAN划分及端口 设备名 VLAN编号 VLAN名称 端口范围 连接计算机 LSW1 vlan 10 技术部 E 0&#x2F;0&#x2F;1 - E 0&#x2F;0&#x2F;2 PC1, PC3 LSW2 vlan 20 财务部 E 0&#x2F;0&#x2F;1 - E 0&#x2F;0&#x2F;2 PC2, PC4 表2-PC计算机IP地址及端口信息 设备名 端口 IP地址信息 网关 PC1 E 0&#x2F;0&#x2F;1 10.10.1.1 255.255.255.0 PC2 E 0&#x2F;0&#x2F;2 10.10.1.2 255.255.255.0 PC3 E 0&#x2F;0&#x2F;3 10.10.1.3 255.255.255.0 PC4 E 0&#x2F;0&#x2F;4 10.10.1.4 255.255.255.0 2.启动有eNSP模拟器，按实验要求和规划，搭建网络拓扑。（课程目标3） 上图IP地址应为10.10.1.3，当时打错了，后面有纠正 3.设备配置。（课程目标3）本次配置比起实验一来说，就是多了对于两个交换机的控制，其余的配置都是一样的，当我们配置完每台PC的IP之后，我们就可以进入交换机进行配置了。首先我们进入LSW(交换机1)，然后我们首先关闭之后可能会出现的提示信息 1undo info-center enable 接下来，我们首先配置第一个交换机所连接的两台PC和对应连接的一台交换机的端口。操作还是和之前一样的操作 12sysvlan batch 10 20 首先进入sys然后创建两个vlan 10和20 123interface G 0/0/1 //G是一种端口的名称，指千兆以太网端口，而上个实验的E指的是普通以太网端口port link-type accessport default vlan 10 这是第一台PC的配置 123interface G 0/0/2port link-type accessport default vlan 20 这是第二台PC的配置接下来是本实验的核心内容，就是配置24端口的两台交换机，使得他们可以通过vlan10 和 vlan20这两个线路。这样的话就可以连接起来这两台交换机了。 123interface G 0/0/24port link-type trunkport trunk allow-pass vlan 10 20 这样的话，这个交换机和交换机之间的线缆就可以通过10和20的接口了。剩下的就是配置第二台交换机的配置，方法和上述方法一样，重复一下即可。 123456789101112undo info-center enablesysvlan batch 10 20interface G 0/0/1 //G是一种端口的名称，指千兆以太网端口，而上个实验的E指的是普通以太网端口port link-type accessport default vlan 10interface G 0/0/2port link-type accessport default vlan 20interface G 0/0/24port link-type trunkport trunk allow-pass vlan 10 20 我们不难看出vlan10和20这两个线路均有24接口通过。那么实验就完成了，接下来验证实验就可以了。 4.验证。（课程目标3）PC2验证PC1配置由图可知，pc1可以连3，2可以连4，这样的话我们的实验目的也就完成了 拓扑图如上。六、实验心得或存在的问题（课程目标1)本次实验学到了有关不同楼层的两台交换机之间应该如何配置，以至于达到楼层之间的互联而不与同楼层之间的互联。本次实验还学习到了有关link-type trunk以及trunk接口是用于交换机之间连接的端口，trunk口可以1加入多个vlan，以及接收和发送多个Vlan的Tagged帧。还了解到了G口是千兆以太网口，E口是以太网口的知识点。","categories":[],"tags":[],"keywords":[]},{"title":"Week4 and Daily Schedule","slug":"每周学习计划/Week4","date":"2024-03-24T13:23:47.317Z","updated":"2024-03-24T13:40:46.850Z","comments":true,"path":"2024/03/24/每周学习计划/Week4/","link":"","permalink":"https://primeluoqiu.github.io/2024/03/24/%E6%AF%8F%E5%91%A8%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/Week4/","excerpt":"","text":"Daily ScheduleTotal Schedule 《计算机网络》-郑铨老师的 1.7-2.2 CS61B Week 7- 10 CS61A 看完第二章 CSAPP 看完第二章 CS61C 前两周内容 每天任务的话，先看周一吧，周一相对来说课不算多，下午有一节毛概，毛概课的话得补半节课的数电笔记和作业 Monday《计算机网络》 1.7 CS61A CS61B CSAPP 还得看点算法，要不都快要蓝桥杯考试了，顶不住了 目前先准备这些，看明天的收效，希望明天早上可以起得来然后走两圈锻炼锻炼。","categories":[{"name":"大二下","slug":"大二下","permalink":"https://primeluoqiu.github.io/categories/%E5%A4%A7%E4%BA%8C%E4%B8%8B/"}],"tags":[],"keywords":[{"name":"大二下","slug":"大二下","permalink":"https://primeluoqiu.github.io/categories/%E5%A4%A7%E4%BA%8C%E4%B8%8B/"}]},{"title":"第三周总结","slug":"每周学习计划/第三周总结","date":"2024-03-24T13:07:37.059Z","updated":"2024-03-24T13:34:07.396Z","comments":true,"path":"2024/03/24/每周学习计划/第三周总结/","link":"","permalink":"https://primeluoqiu.github.io/2024/03/24/%E6%AF%8F%E5%91%A8%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/%E7%AC%AC%E4%B8%89%E5%91%A8%E6%80%BB%E7%BB%93/","excerpt":"","text":"本周学习任务完成情况： 郑铨《计算机网络》:已看完1.6，还差一节视频 CS61B 目标未完成，达成率 0 CS61A 仅仅看了1.4之前的，还差一章 CSAPP：差一节的知识点和两节的对于知识点的总结 CS61C：甚至还没看课 总结：怎么说呢，本周的事情相对来说比较多，很多时候为了处理一些事情不得不去花费一晌的时间。究其根本的话还是因为考虑的事情太多太繁杂，像极了酷安的那张经典图片，某物在拥有前，拥有时，以及拥有后的心情状态。 其实有的时候也是，覆水难收是肯定的事情，硬要做一些可能看起来不是那么的合常理的事情的时候，往往就会产生很多负面的因素，谁能想到收到的手机会是一个被拿去抵债的手机呢。不过其实经此一事的话，二手的市场还真的水深，得亏是那个老哥很好说话，再加上我的态度也是非常的到位，以至于目前来说似乎并没有产生什么不和平的因素。就感觉也还好。本周这种事情占得时间还是蛮多的。课程的任务量其实也还好，就是笔记和每周的作业。感觉也还OK，起码目前基本上emm也算是个应付的态势吧 有的时候还是心不静，心乱的话效率也不会很高。每次学习的时候也不妨像他们一样手机扣一下，然后就在一边放着。电脑端挂个微信就行，不过似乎我好像也不会被别人找的样子hhh 这两周的锻炼还算是有所成效，减重了一些，但不多，想要减重还是得每天坚持锻炼，然后规律作息、规律作息、规律作息，重要的事情说三遍hhh，早上倒也还是能起得来，就是太困了，归根结底还是晚上睡的太晚，十二点半左右能睡的话第二天的精神状态想必就会好很多了。早上起来之后的感觉也不会太困。 啧，其实有的时候也在想，如果我要不是天天学习，或者说如果我真的把这大学四年荒废过去会怎么样，虽然我妈对我的要求确实不高，也就是混口饭吃的程度。不过再怎么说都是要勤奋的，无论是在后面的学习上，还是之后的找工作上。去哪里，找什么样的工作，这些虽然都是后话，但是也是在茫然之中会考虑到的一些事情。 时间…时间… 还有多久呢…","categories":[{"name":"大二下","slug":"大二下","permalink":"https://primeluoqiu.github.io/categories/%E5%A4%A7%E4%BA%8C%E4%B8%8B/"}],"tags":[],"keywords":[{"name":"大二下","slug":"大二下","permalink":"https://primeluoqiu.github.io/categories/%E5%A4%A7%E4%BA%8C%E4%B8%8B/"}]},{"title":"","slug":"CSAPP/第一章/1.8 系统之间利用网络通信","date":"2024-03-24T02:51:49.636Z","updated":"2024-03-23T15:40:20.220Z","comments":true,"path":"2024/03/24/CSAPP/第一章/1.8 系统之间利用网络通信/","link":"","permalink":"https://primeluoqiu.github.io/2024/03/24/CSAPP/%E7%AC%AC%E4%B8%80%E7%AB%A0/1.8%20%E7%B3%BB%E7%BB%9F%E4%B9%8B%E9%97%B4%E5%88%A9%E7%94%A8%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/","excerpt":"","text":"实际上，现代系统经常通过网络和其他系统连接到一起，从一个单独的系统来看，网络可视为一个I&#x2F;O设备。当系统从主存复制一串字节到网络适配器时，数据流经网络到达另一台机器。相似地，系统可以读取其他机器发来的数据，并把数据复制到自己的主存。![[Pasted image 20240323233843.png]]随着Internet全球网络的出现，从一台主机复制信息到另一台主机已经成为计算机系统最重要的用途之一","categories":[],"tags":[],"keywords":[]},{"title":"CSAPP Chapter1.7 硬件被谁管理啊","slug":"CSAPP/第一章/1.7操作系统管理硬件","date":"2024-03-24T02:51:49.635Z","updated":"2024-03-24T02:43:36.991Z","comments":true,"path":"2024/03/24/CSAPP/第一章/1.7操作系统管理硬件/","link":"","permalink":"https://primeluoqiu.github.io/2024/03/24/CSAPP/%E7%AC%AC%E4%B8%80%E7%AB%A0/1.7%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E7%A1%AC%E4%BB%B6/","excerpt":"","text":"从hello的例子可以可以看出来，当shell加载运行包括最后输出的时候，shell和hello都没有直接对硬件进行访问(包括键盘，显示器，主存或者磁盘)。取而代之的是，他们依靠操作系统提供的服务。我们可以把操作系统看成是应用程序和硬件之间插入的一层软件。所有应用程序对硬件的操作尝试都必须通过操作系统操作系统有两个基本功能， 防止硬件被失控的应用程序滥用 向应用程序提供简单一致的机制来控制复杂而又通常大不相同的低级硬件设备。 操作系统通过几个基本的抽象概念(进程、虚拟内存和文件)来实现这两个功能，如下图所示，文件是对I&#x2F;O设备的抽象表示，虚拟内存是对主存和磁盘I&#x2F;O设备的抽象表示，进程则是对处理器、主存和I&#x2F;O设备的抽象表示 1.7.1 进程像hello这样的程序在现代系统上运行时，操作系统会提供一种假象，就像系统上只有这个程序在运行。程序看上去是独占地只用处理器、主存和I&#x2F;O设备。处理器看上去就像在不间断的一条接一条地执行程序中的指令，即该程序的代码和数据是系统内存中唯一的对象。这些假象是通过进程的概念来实现的，进程是计算机科学中最重要和最成功的概念之一。 进程是操作系统对一个正在运行的程序的一种抽象。在一个系统上可以同时运行多个进程，而每个进程都好像在独占的使用硬件。而并发运行，则是说一个进程的指令和另一个进程的指令是交错执行的。在大多数系统中，需要运行的进程数是多于可以运行它们的CPU个数的。传统系统在一个时刻只能执行一个程序，而先进的多核处理器同时能够执行多个程序。无论是在单核还是多核系统中，一个CPU看上去都像是在并发地执行多个进程，这是通过处理器在进程间切换来实现的。操作系统实现这种操作执行的机制称为上下文交换。为了简化讨论，我们只考虑包含一个CPU的单处理器系统的情况。后面还会讨论 操作系统保持跟踪进程运行所需的所有状态信息。这种状态，也就是上下文，包括许多信息，比如PC和寄存器文件的当前值，以及主存的内容。在任何一个时刻，单处理器系统都只能执行一个进程的代码。当操作系统决定要把控制权从当前进程转移到某个新进程时，就会进行上下文切换，即保存当前进程的上下文、恢复新进程的上下文，然后将控制权传递到新进程。新进程就会从它上次停止的地方开始。那么hello程序运行场景的基本理念看下面。![[https://hansimov.gitbook.io/~gitbook/image?url=https:%2F%2F4154149387-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-legacy-files%2Fo%2Fassets%252F-MHt_spaxGgCbp2POnfq%252F-MHzietxOnE2XCBTZHJ7%252F-MHziqrI26zhGJA9_NLL%252F01-12%2520%25E8%25BF%259B%25E7%25A8%258B%25E7%259A%2584%25E4%25B8%258A%25E4%25B8%258B%25E6%2596%2587%25E5%2588%2587%25E6%258D%25A2.png%3Falt=media%26token=5df4420b-e3c7-46ca-8192-ba207aa49f15&amp;width=400&amp;dpr=3&amp;quality=100&amp;sign=7323c7a530eb087f04ecfa52db5f03b77529e0c73a5744a490b2389fecb6b30ehttps://hansimov.gitbook.io/~gitbook/image?url=https:%2F%2F4154149387-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-legacy-files%2Fo%2Fassets%252F-MHt_spaxGgCbp2POnfq%252F-MHzietxOnE2XCBTZHJ7%252F-MHziqrI26zhGJA9_NLL%252F01-12%2520%25E8%25BF%259B%25E7%25A8%258B%25E7%259A%2584%25E4%25B8%258A%25E4%25B8%258B%25E6%2596%2587%25E5%2588%2587%25E6%258D%25A2.png%3Falt=media%26token=5df4420b-e3c7-46ca-8192-ba207aa49f15&amp;width=400&amp;dpr=3&amp;quality=100&amp;sign=7323c7a530eb087f04ecfa52db5f03b77529e0c73a5744a490b2389fecb6b30e]] 实例当中有两个并发的进程：shell和hello。最开始，只有shell进程在运行，也就是等待命令行上的输入。当我们让他运行hello程序时，shell通过一个专门的函数，也就是系统调用，来执行我们的请求，系统调用会将控制权传递给操作系统。操作系统保存shell进程的上下文，创建一个新的hello进程及其上下文，并将控制权传回给它，shell进程会继续等待下一个命令行输入。 如图所示，从一个进程到另一个进程的转换是由操作系统内核(kernel) 管理的。内核是操作系统代码常驻主存的部分。当应用程序需要操作系统的某些操作时，比如读写文件，它就执行一条特殊的系统调用(system call) 指令，将控制权传递给内核。然后内核执行被请求的操作并返回应用程序。注意，内核不是一个独立的进程。相反，它是系统管理全部进程所用代码和数据结构的集合。 实现进程这个抽象概念需要低级硬件和操作系统软件之间的紧密合作。 1.7.2 线程尽管通常我们认为一个进程只有单一的控制流，但是在现在系统中，一个进程实际上可以由多个称为线程的执行单元组成，每个线程都运行在进程的上下文中，并共享的代码和全局数据。由于网络服务器中对并行处理的需求，线程称为越来越重要的编程模型，因为多线程之间比多进程之间更容易共享数据，也因为线程一般来说都比进程更高效。当有多处理器可用的时候，多线程也是一种使得程序可以运行得更快的方法，我们将在后面讨论 1.7.3 虚拟内存虚拟内存是一个抽象概念，它为每一个进程提供了一个假象，即每个进程都在独占地使用主存。每个进程看到的内存都是一致的，称为虚拟地址空间。下图所示的Linux进程的虚拟地址空间(其他Unix系统的设计也与此类似)。在Linux中，地址空间最上面的区域是保留给操作系统中的代码和数据的，这对所有进程来说都一样。地址空间的底部区域存放用户进程定义的代码和数据。图中的地址是从下往上增大的。每个进程看到的虚拟地址空间由大量准确定义的区构成，每个区都有专门的功能。先做简单的了解，逐步向上介绍 程序代码和数据：对所有的进程来说，代码是从同一固定地址开始，紧接着的是C全局变量相对应的数据位置。代码和数据区是直接按照可执行目标文件的内容初始化的，在示例中就是可执行文件hello。 堆：代码和数据区后紧随的是运行时堆。代码和数据区在进程一开始运行时就被指定了大小，与此不同，当调用像malloc和free这样的C标准库函数的时候，堆可以在运行时动态地扩展和收缩。 共享库：大约在地址空间的中间部分是一块用来存放像C标准库和数学库这样的共享库的代码和数据的区域。共享库的概念非常强大，也相当难懂。 栈：位于用户虚拟地址空间顶部的是用户栈，编译器用它来实现函数调用。和堆一样，用户栈在程序执行期间可以动态地扩展和收缩。特别的，每次我们调用一个函数时，栈就会增长；从一个函数返回时，栈就会收缩。 内核虚拟内存：地址空间顶部的区域是为内核保留的。不允许应用程序读写这个区域的内容或者直接调用内核代码定义的函数。相反，它们必须调用内核来执行这些操作。 虚拟内存的运作需要硬件和操作系统软件之间精密复杂的交互，包括对处理器生成的每个地址的硬件翻译。基本思想是把一个进程虚拟内存存储在磁盘上，然后用主存作为磁盘的高速缓存。 1.7.4 文件文件就是字节序列，仅此而已。每个I&#x2F;O设备，包括磁盘、键盘、显示器甚至网络，都可以看成是文件。系统中的所有输入输出都是通过使用一小组称为Unix I&#x2F;O的系统调用读写文件来实现的。 文件这个简单而精致的概念是十分强大的，因为它向应用程序提供了一个统一的视图，来看待系统中可能含有的所有各式各样的I&#x2F;O设备。例如，处理磁盘文件内容的应用程序员可以非常幸福，因为他们无需了解具体的磁盘技术。进一步说，同一个程序可以在使用不同磁盘技术的不同系统上运行。","categories":[{"name":"CSAPP","slug":"CSAPP","permalink":"https://primeluoqiu.github.io/categories/CSAPP/"}],"tags":[],"keywords":[{"name":"CSAPP","slug":"CSAPP","permalink":"https://primeluoqiu.github.io/categories/CSAPP/"}]},{"title":"CSAPP Chapter1.6 存储设备形成也是有结构的","slug":"CSAPP/第一章/1.6存储设备形成层次结构","date":"2024-03-24T02:51:49.634Z","updated":"2024-03-24T02:40:48.774Z","comments":true,"path":"2024/03/24/CSAPP/第一章/1.6存储设备形成层次结构/","link":"","permalink":"https://primeluoqiu.github.io/2024/03/24/CSAPP/%E7%AC%AC%E4%B8%80%E7%AB%A0/1.6%E5%AD%98%E5%82%A8%E8%AE%BE%E5%A4%87%E5%BD%A2%E6%88%90%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/","excerpt":"","text":"也就是说，在处理器中和一个较大较慢的设备(例如主存)之间插入要给更小更快的存储设备(例如高缓)的想法已经成为一个普遍的观念。实际上，每个计算机中的存储设备都被组织成了一个存储器层次结构，如图所示![[https://hansimov.gitbook.io/~gitbook/image?url=https:%2F%2F4154149387-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-legacy-files%2Fo%2Fassets%252F-MHt_spaxGgCbp2POnfq%252F-MHzhX2vrq6mFP3tN9EU%252F-MHzi1Edm9hUsnQdAkkL%252F01-09%2520%25E4%25B8%2580%25E4%25B8%25AA%25E5%25AD%2598%25E5%2582%25A8%25E5%2599%25A8%25E5%25B1%2582%25E6%25AC%25A1%25E7%25BB%2593%25E6%259E%2584%25E7%259A%2584%25E7%25A4%25BA%25E4%25BE%258B.png%3Falt=media%26token=afb8208e-17dc-475f-9f61-acf0bd0ca891&amp;width=400&amp;dpr=3&amp;quality=100&amp;sign=17fc4e7af9f4033010d24045648add7168e149dc6885e9e1a1730033b06fd7f2]] 在这个层次结构中，从上到下，设备之间的访问速度越来越慢，容量越来越大，并且每字节的造价也越来越低。寄存器文件在层次结构中位于最顶层，也就是第0级或者L0，主存在第4存… 存储器层次结构的主要思想是上一层的存储器作为低一层存储器的高速缓存。因此寄存器文件就是L1的高速缓存，L1是L2的高速缓存..在某些具有分布式文件系统的网络系统中，本地磁盘就是存储在其他系统中磁盘上的数据的高速缓存。正如可以运用不同的高速缓存的知识来提高程序性能一样，程序员同样可以利用对整个存储器层次结构的理解来提高程序性能。","categories":[{"name":"CSAPP","slug":"CSAPP","permalink":"https://primeluoqiu.github.io/categories/CSAPP/"}],"tags":[],"keywords":[{"name":"CSAPP","slug":"CSAPP","permalink":"https://primeluoqiu.github.io/categories/CSAPP/"}]},{"title":"CSAPP Chapter1.5 多来点高速缓存嘛","slug":"CSAPP/第一章/1.5高速缓存至关重要","date":"2024-03-24T02:51:49.633Z","updated":"2024-03-24T02:40:19.983Z","comments":true,"path":"2024/03/24/CSAPP/第一章/1.5高速缓存至关重要/","link":"","permalink":"https://primeluoqiu.github.io/2024/03/24/CSAPP/%E7%AC%AC%E4%B8%80%E7%AB%A0/1.5%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E8%87%B3%E5%85%B3%E9%87%8D%E8%A6%81/","excerpt":"","text":"上述简单的运行过程中，我们不难发现系统花费了大量的时间把信息从一个地方挪到另一个地方。例如hello最初放在磁盘上，当程序加载的时候，被复制到主存，最后从主存上复制到显示设备。复制总是需要随时间的。这些复制就是开销，所以系统设计者的一个主要目标就是使这些复制操作尽可能快的完成。 根据机械原理，较大的存储设备要比比较小的存储设备运行的慢，而快速设备的造价远高于同类的低速设备，比如说，一个典型系统上的磁盘驱动器可能比主存大1000倍，但是对处理器而言，从磁盘驱动器上读取一个字的时间开销要比从主存中的开销大1000万倍。 类似得，一个典型的寄存器文件只存储几百byte的信息，而主存里面可以存放几十亿字节。然而，处理器从寄存器文件中读数据比从主存中读取几乎要快100倍，而且随着半导体技术的进步，处理器和主存之间的差距还在增大。加快处理器的运行速度比加快主存的运行速度要容易和便宜得多。针对这种处理器和主存之间的差异，系统设计者就采用了更小更快的存储设备，称为高速缓存存储器(cache memory, 简称cache或高速缓存)，作为暂时的集结区域，存放处理器近期可能需要的信息。这是一个典型系统中的高速缓存存储器，位于CPU上的L1高速缓存的荣富良可以达到数万字节。访问速度几乎和访问寄存器文件一样快。一个容量为数十万到百万字节的更大的L2告诉换曾黁通过一条特殊的总线连接到CPU。 进程访问L2高速缓存的时间要比访问L1告诉换从的时间长5倍，但是这仍然比访问主存的时间快5-10倍。L1和L2告诉换从使用一种叫做静态随机访问存储器的硬件技术实现的。比较新的，处理能力更强大的系统甚至有三级高速缓存：L1、L2、L3.系统可以获得一个很大的存储器，同时访问速度也很快，原因是利用了高速缓存的局部性原理，即程序具有访问局部区域里的数据和代码的趋势。通过让高速缓存里存放可能经常访问的数据，大部分的内存操作都能在快速的高速缓存中完成。![[Pasted image 20240318151738.png]] 本书得出的重要结论之一就是，意识到高速缓存存储器存在的应用程序员能够利用高速缓存将程序的的性能提升一个数量级。","categories":[{"name":"CSAPP","slug":"CSAPP","permalink":"https://primeluoqiu.github.io/categories/CSAPP/"}],"tags":[],"keywords":[{"name":"CSAPP","slug":"CSAPP","permalink":"https://primeluoqiu.github.io/categories/CSAPP/"}]},{"title":"CSAPP Chapter1.3 处理器是干嘛的","slug":"CSAPP/第一章/1.4处理器读并解释储存在内存中的指令","date":"2024-03-24T02:51:49.632Z","updated":"2024-03-24T02:39:50.330Z","comments":true,"path":"2024/03/24/CSAPP/第一章/1.4处理器读并解释储存在内存中的指令/","link":"","permalink":"https://primeluoqiu.github.io/2024/03/24/CSAPP/%E7%AC%AC%E4%B8%80%E7%AB%A0/1.4%E5%A4%84%E7%90%86%E5%99%A8%E8%AF%BB%E5%B9%B6%E8%A7%A3%E9%87%8A%E5%82%A8%E5%AD%98%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E6%8C%87%E4%BB%A4/","excerpt":"","text":"在我们创建完hello的可执行文件之后，用shell运行如下 123linux &gt; ./hellohello, worldlinux &gt; shell是一个命令行解释器，它输出一个提示符，然后等待一个命令行，执行这个命令。如果命令行第一个单词不是一个内置的指令，那么它就会假设这是一个可执行文件的名字，它将加载并运行这个文件。此例中，加载运行了hello，然后等待程序终止，输出消息，然后终止。然后输出一个提示符，等待下一个输入。 1.4.1 系统的硬件组成1.总线也就贯穿整个系统的一组电子管道。携带信息字节并在各个部件间传递。通常总线被设计成传送定长的字节块，也就是字。字中的字节数（即字长）是一个基本的系统参数，各个系统中都不尽相同。现在的的大多数机器字长是4或8字节32&#x2F;64位。 2.I&#x2F;O设备这是系统和外部世界的联系通道。示例系统包括四个I&#x2F;O设备：作为用户输入的键盘和鼠标，作为用户输出的显示器，以及用于长期存储数据和程序的磁盘驱动器。最开始的hello就存放在磁盘上。 每个I&#x2F;O都通过以一个控制器或适配器与I&#x2F;O总线相连。控制器和适配器之间的的区别而在于他们的封装方式。控制器是I&#x2F;O设备本身或者系统的主印制电路板(主板)上的芯片组。而适配器是一块插在主板插槽上的卡。这些设备的功能都是在I&#x2F;O总线和I&#x2F;O设备之间传递信息· 1ALU:算数/逻辑单元 PC：程序计数器 USB：通用串行总线 3.主存主存是一个临时存储设备，在处理器执行程序时，用来存放程序和程序处理的数据。从物理上来说，主存是由一组动态随机存储器(DRAM) 芯片组成的。从逻辑上来说，存储器是一个线性的字节数组，每个字节都有其唯一的地址(数组索引)，这些地址是从零开始的。一般来说，组成程序的每条机器指令都由不同数量的字节构成。一般来说，组成程序的每条机器指令都有不同数量的字节构成。与C程序变量相对应的数据项大小是根据类型变化的。 4.处理器中央处理单元(CPU),简称处理器，是解释(或执行)存储在主存中指令的引擎。处理器的核心是一个大小为一个字的存储设备(或寄存器) ，称为程序计数器&#x2F;指令计数器(PC)。在任何时刻，PC都指向主存中某条机器语言指令(即含有该条指令的地址) 从系统通电开始到断电，处理器一直在不断地执行程序计数器指向的指令，再更新程序计数器，使其指向下一条指令。处理器看上去是按照一个非常简单的指令执行模型来操作的，这个模型是由指令集架构(Arm, x86,)决定的。在这个模型中，指令按照严格的顺序执行，而执行一条指令包含执行一系列的步骤。处理器从程序计数器指向的内存处读取指令，解释指令中的位，执行该指令指示的简单操作，然后更新PC，使其指向下一条指令，而这条指令并不一定和在内存中刚刚执行的指令相邻。 这样的简单操作并不多，它们围绕着主存、寄存器文件和算数&#x2F;逻辑单元进行。寄存器文件是个小的存储设备，由一些单个字长的寄存器组成，每个寄存器都有唯一的名字。ALU计算新的数据和地址值。下面是一些简单操作的例子，CPU在指令的要求下可能会执行这些操作 加载：从主存复制一个字节或者一个字到寄存器，以覆盖寄存器原来的内容。 存储：从寄存器复制一个字节或者一个字到主存的某个位置，以覆盖这个位置上原有的内容 操作：把两个寄存器的内容复制到ALU，ALU对这两个字做算术运算，并将结果存放到一个寄存器中，以覆盖该寄存器中原来的内容 跳转：从指令本身中抽取一个字，并将这个字复制到PC中，以覆盖PC中原来的值 处理器看上去是它的指令集架构的简单实现，但是实际上现代处理器使用了非常复杂的机制来加速程序的执行。因此，我们将处理器的指令集架构和处理器的微体系结构区分开来：指令集架构描述的是每条机器代码指令的效果；而微体系结构描述的是处理器实际上是如何实现的。 1.4.2运行Hello程序目前先暂时省略一些细节。 起初，shell程序执行它的指令，等待我们输入一个命令。当我们在键盘上输入字符串”.&#x2F;hello”后，shell程序将字符逐一读入寄存器，再把它存放到内存中。如下图所示 当我们在键盘上敲回车键之后，shell程序就知道我们已经结束了命令的输入，然后shell执行一系列指令来加载可执行的hello文件，这些指令将hello目标文件中的代码和数据从磁盘复制到主存。数据包括最后会被输出的字符串”hello, world\\n” 利用直接存储器存取(DMA)技术，数据可以不通过处理器而直接从磁盘到达主存。这个步骤如下图所示![[https://hansimov.gitbook.io/~gitbook/image?url=https:%2F%2F4154149387-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-legacy-files%2Fo%2Fassets%252F-MHt_spaxGgCbp2POnfq%252F-MHzfLHp5XFUFTsUJAKx%252F-MHzfN_gwQJSG2YnC5Gk%252F01-06%2520%25E4%25BB%258E%25E7%25A3%2581%25E7%259B%2598%25E5%258A%25A0%25E8%25BD%25BD%25E5%258F%25AF%25E6%2589%25A7%25E8%25A1%258C%25E6%2596%2587%25E4%25BB%25B6%25E5%2588%25B0%25E4%25B8%25BB%25E5%25AD%2598.png%3Falt=media%26token=9a49507e-f20d-4af8-b277-bebf57cc597f&amp;width=400&amp;dpr=3&amp;quality=100&amp;sign=74b6cf3ac9a458f0c5b3b6cbc5920a9cd3dcc59d6250e0badd63c26859b486f3]] 一旦目标文件hello中的代码和数据被加载到主存，处理器就开始执行hello程序的main程序中的机器语言指令。这些指令将”Hello,world\\n”字符串中的字节从主存复制到寄存器文件，再从寄存器文件中复制到显示设备，最终显示在屏幕上。步骤如下所示![[https://hansimov.gitbook.io/~gitbook/image?url=https:%2F%2F4154149387-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-legacy-files%2Fo%2Fassets%252F-MHt_spaxGgCbp2POnfq%252F-MHzfVZwd5iIwJfDkOPj%252F-MHzffvOB90toXVTON5G%252F01-07%2520%25E5%25B0%2586%25E8%25BE%2593%25E5%2587%25BA%25E5%25AD%2597%25E7%25AC%25A6%25E4%25B8%25B2%25E4%25BB%258E%25E5%25AD%2598%25E5%2582%25A8%25E5%2599%25A8%25E5%2586%2599%25E5%2588%25B0%25E6%2598%25BE%25E7%25A4%25BA%25E5%2599%25A8.png%3Falt=media%26token=d0480c36-9640-4159-bc71-8f5db262a6ba&amp;width=400&amp;dpr=3&amp;quality=100&amp;sign=a45f19ed618ab752f842b7f269e3b6411ec8fa6f81166c73190f0156510d0c4a]]","categories":[{"name":"CSAPP","slug":"CSAPP","permalink":"https://primeluoqiu.github.io/categories/CSAPP/"}],"tags":[],"keywords":[{"name":"CSAPP","slug":"CSAPP","permalink":"https://primeluoqiu.github.io/categories/CSAPP/"}]},{"title":"CSAPP Chapter1.3 了解编译系统如何工作是大有益处的","slug":"CSAPP/第一章/1.3了解编译系统如何工作是大有益处的","date":"2024-03-24T02:51:49.631Z","updated":"2024-03-24T02:25:47.980Z","comments":true,"path":"2024/03/24/CSAPP/第一章/1.3了解编译系统如何工作是大有益处的/","link":"","permalink":"https://primeluoqiu.github.io/2024/03/24/CSAPP/%E7%AC%AC%E4%B8%80%E7%AB%A0/1.3%E4%BA%86%E8%A7%A3%E7%BC%96%E8%AF%91%E7%B3%BB%E7%BB%9F%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E6%98%AF%E5%A4%A7%E6%9C%89%E7%9B%8A%E5%A4%84%E7%9A%84/","excerpt":"","text":"益处大致有三点 优化程序性能。尽管已经无需为了写出高效代码而了解编译器的内部工作。不过为了在C中做出更好对的编码选择，我们确实需要了解一些机器代码以及编译器将不同的C转化成机器代码的方式。例如在C语言程序中有if-else和switch两种语句。那么这两种哪个更高效呢，while和for之间哪个更有效呢？这些都是可以得到了解的 理解链接时出现的错误。根据经验来讲，一些令人困扰的程序错误往往都与链接器操作有关，尤其是试图构建大型的软件系统时。例如链接器报告说无法解析一个引用，这是什么意思？静态变量和全局变量的区别是什么等一系列问题 避免安全漏洞。多年来，缓冲区溢出错误时造成大多数网络和Internet服务器上安全漏洞的主要原因。存在这些错误是因为很少有程序员能够理解需要限制从不受信任的源接受数据的数量和格式。 学习安全编程的第一步就是理解数据和控制信息存储在程序栈上的方式会引起的后果。等","categories":[{"name":"CSAPP","slug":"CSAPP","permalink":"https://primeluoqiu.github.io/categories/CSAPP/"}],"tags":[],"keywords":[{"name":"CSAPP","slug":"CSAPP","permalink":"https://primeluoqiu.github.io/categories/CSAPP/"}]},{"title":"CSAPP Chapter1.2 程序被其他程序翻译成不同的格式","slug":"CSAPP/第一章/1.2程序被其他程序翻译成不同的格式","date":"2024-03-24T02:51:49.630Z","updated":"2024-03-24T02:36:29.315Z","comments":true,"path":"2024/03/24/CSAPP/第一章/1.2程序被其他程序翻译成不同的格式/","link":"","permalink":"https://primeluoqiu.github.io/2024/03/24/CSAPP/%E7%AC%AC%E4%B8%80%E7%AB%A0/1.2%E7%A8%8B%E5%BA%8F%E8%A2%AB%E5%85%B6%E4%BB%96%E7%A8%8B%E5%BA%8F%E7%BF%BB%E8%AF%91%E6%88%90%E4%B8%8D%E5%90%8C%E7%9A%84%E6%A0%BC%E5%BC%8F/","excerpt":"","text":"为了在系统上运行Hello.c程序，每条C语句必须被其他程序转化成一系列的低级机器语言指令。然后这些指令按照一种称为可执行程序的格式打好包，并以二进制磁盘文件的形式存放起来。目标程序也成为可执行目标文件 高级语言 -&gt; 低级指令 -&gt; 指令打包并以二进制文件存放。 ![[https://hansimov.gitbook.io/~gitbook/image?url=https:%2F%2F4154149387-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-legacy-files%2Fo%2Fassets%252F-MHt_spaxGgCbp2POnfq%252F-MHzZfEIY91yIzOD0Rce%252F-MHzZpZI-gs8CNcwHIyv%252F01-03%2520compilation%2520systems.png%3Falt=media%26token=91ca688e-1cfc-4ec6-8b99-d52e672bbac7&amp;width=400&amp;dpr=3&amp;quality=100&amp;sign=ad2978e04a286ea0e07b7bbfb5d2a96b78a69a9b23614f1df17e662f4615f344]] 预处理阶段，通过以字符#开头的命令，修改原始程序。如#include&lt;iostream&gt;命令就是告诉预处理器读取系统头文件stdio.h的内容，然后直接插入程序文本中。然后得到了另一个C程序，通常以.i作为文件扩展名。 编译阶段：通过编译器将文本文件翻译成hello.s，也就是汇编语言程序，该程序包含main的定义1234567main: subq $8, %rsp movl $.LC0, %edi call puts movl $0, %eax addq $8, %rsp ret 2-7行每条都以一种文本格式描述了一条低级语言指令。(汇编语言为所有不同高级语言的不同编译器提供了通用的输出语言) 汇编阶段；通过汇编器将hello.s翻译成机器语言指令。把这些指令打包成可重定位目标程序。并保存到hello.o中(这是一个二进制文件)，里面包含的是main的指令代码。 链接阶段：hello程序调用了printf函数，是标准C库中的一个函数。函数存在于一个名为printf.o的单独的预编译好了的目标文件中，而这个文件必须以某种方式合并到hello.c的程序中，链接器负责合并，结果得到hello文件，是一个可执行文件。可以被加载到内存中，由系统执行。也就是说，一个C程序都是先从预处理阶段开始的，先读取头文件然后插入程序中，然后通过编译器翻译成汇编语言，再通过汇编器翻译成机器语言指令生成hello.o，接下来引入在hello中调用的printf函数，而该函数存在于一个单独编译好的目标文件printf.o中，然后连接器负责合并这两个.o的目标文件，然后最后得出一个可执行文件。","categories":[{"name":"CSAPP","slug":"CSAPP","permalink":"https://primeluoqiu.github.io/categories/CSAPP/"}],"tags":[],"keywords":[{"name":"CSAPP","slug":"CSAPP","permalink":"https://primeluoqiu.github.io/categories/CSAPP/"}]},{"title":"CSAPP Chapter1.1 信息就是位+上下文","slug":"CSAPP/第一章/1.1信息就是位+上下文","date":"2024-03-24T02:51:49.625Z","updated":"2024-03-24T02:25:25.510Z","comments":true,"path":"2024/03/24/CSAPP/第一章/1.1信息就是位+上下文/","link":"","permalink":"https://primeluoqiu.github.io/2024/03/24/CSAPP/%E7%AC%AC%E4%B8%80%E7%AB%A0/1.1%E4%BF%A1%E6%81%AF%E5%B0%B1%E6%98%AF%E4%BD%8D+%E4%B8%8A%E4%B8%8B%E6%96%87/","excerpt":"","text":"第一节：信息就是位＋上下文我们在创建第一个hello.c的时候，这些文件都是由ASCII码组成的，也就是用一个唯一的单字节大小的值来表示每个字符。而只由ASCII字符构成的文件成为文本文件，其他的文件被称为二进制文件。 这件事说明了一个基本思想：系统中所有的信息都是由一串bit表示的。区分不同数据对象的唯一方法是我们读到这些数据对象时的上下文。例如在不同的上下文中，一个同样的字节序列可能表示一个整数、浮点数、字符串、机器指令。","categories":[{"name":"CSAPP","slug":"CSAPP","permalink":"https://primeluoqiu.github.io/categories/CSAPP/"}],"tags":[],"keywords":[{"name":"CSAPP","slug":"CSAPP","permalink":"https://primeluoqiu.github.io/categories/CSAPP/"}]},{"title":"模拟堆","slug":"Algorithm/duiyouhua","date":"2024-03-23T14:13:09.233Z","updated":"2024-03-23T14:14:47.893Z","comments":true,"path":"2024/03/23/Algorithm/duiyouhua/","link":"","permalink":"https://primeluoqiu.github.io/2024/03/23/Algorithm/duiyouhua/","excerpt":"","text":"模拟堆接下来看模拟堆，模拟堆比起之前就是多了两个数组，这两个数组属于互为反函数的类型。例如 hp[k] = j那么ph[j] = k，一个是对应着在堆里的下标，另一个对应的是下标对应的值。 那么对应的，在进行交换的时候，就不能只考虑值之间的交换了，就还得考虑数组之间的交换。这个时候，就需要一个全新的函数了 因为题目中要考虑第k个数，那么就需要两个数组来存储第k个数是什么ph[k]存的是第k个插入的数在堆里的下标是什么,还需要一个hp[k],用来存的是堆的某个点是第几个插入的点。 123456void swap_head(int a, int b) &#123; swap(ph[hp[a]], ph[hp[b]]); swap(hp[a], hp[b]); swap(a, b); &#125; 然后就是把所有的swap函数进行更换为堆里面特有的swap。这个方法不常用，但是djikstra堆优化是常用的，所以要了解一下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string.h&gt;using namespace std;const int N = 100010;int n, m, a, b;int h[N], cnt, ph[N], hp[N];void heap_swap(int a, int b)&#123; swap(ph[hp[a]], ph[hp[b]]); swap(hp[a], hp[b]); swap(h[a], h[b]);&#125;void down(int u)&#123; int t = u; if(u * 2 &lt;= cnt &amp;&amp; h[u * 2] &lt; h[t]) t = u * 2; if(u * 2 + 1 &lt;= cnt &amp;&amp; h[u * 2 + 1] &lt; h[t]) t = u * 2 + 1; if(u != t) &#123; heap_swap(u, t); down(t); &#125;&#125;void up(int u)&#123; while(u / 2 &amp;&amp; h[u / 2] &gt; h[u]) &#123; heap_swap(u, u / 2); u &gt;&gt;= 1; &#125;&#125;int main()&#123; int n, m = 0; cin &gt;&gt; n; while(n --) &#123; char op[10]; int k, x; scanf(&quot;%s&quot;, op); if(!strcmp(op, &quot;I&quot;)) &#123; scanf(&quot;%d&quot;, &amp;x); cnt ++; m ++; ph[m] = cnt, hp[cnt] = m; h[cnt] = x; up(cnt); &#125; else if(!strcmp(op, &quot;PM&quot;)) printf(&quot;%d\\n&quot;, h[1]); else if(!strcmp(op, &quot;DM&quot;)) &#123; heap_swap(1, cnt); cnt --; down(1); &#125; else if(!strcmp(op, &quot;D&quot;)) &#123; scanf(&quot;%d&quot;, &amp;k); k = ph[k]; heap_swap(k, cnt); cnt --; down(k), up(k); &#125; else &#123; scanf(&quot;%d%d&quot;, &amp;k, &amp;x); k = ph[k], h[k] = x; down(k), up(k); &#125; &#125; return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://primeluoqiu.github.io/categories/Algorithm/"}],"tags":[],"keywords":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://primeluoqiu.github.io/categories/Algorithm/"}]},{"title":"1.6分组延时、丢失和吞吐量","slug":"计算机网络/1.6","date":"2024-03-23T06:21:33.296Z","updated":"2024-03-23T12:46:00.036Z","comments":true,"path":"2024/03/23/计算机网络/1.6/","link":"","permalink":"https://primeluoqiu.github.io/2024/03/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.6/","excerpt":"","text":"","categories":[{"name":"计网","slug":"计网","permalink":"https://primeluoqiu.github.io/categories/%E8%AE%A1%E7%BD%91/"}],"tags":[],"keywords":[{"name":"计网","slug":"计网","permalink":"https://primeluoqiu.github.io/categories/%E8%AE%A1%E7%BD%91/"}]},{"title":"1.5Internet结构和ISP","slug":"计算机网络/1.5","date":"2024-03-23T06:21:32.774Z","updated":"2024-03-23T06:28:30.826Z","comments":true,"path":"2024/03/23/计算机网络/1.5/","link":"","permalink":"https://primeluoqiu.github.io/2024/03/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.5/","excerpt":"","text":"","categories":[{"name":"计网","slug":"计网","permalink":"https://primeluoqiu.github.io/categories/%E8%AE%A1%E7%BD%91/"}],"tags":[],"keywords":[{"name":"计网","slug":"计网","permalink":"https://primeluoqiu.github.io/categories/%E8%AE%A1%E7%BD%91/"}]},{"title":"1.4接入网和网络媒体","slug":"计算机网络/1.4","date":"2024-03-23T06:21:32.245Z","updated":"2024-03-23T06:28:32.286Z","comments":true,"path":"2024/03/23/计算机网络/1.4/","link":"","permalink":"https://primeluoqiu.github.io/2024/03/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.4/","excerpt":"","text":"","categories":[{"name":"计网","slug":"计网","permalink":"https://primeluoqiu.github.io/categories/%E8%AE%A1%E7%BD%91/"}],"tags":[],"keywords":[{"name":"计网","slug":"计网","permalink":"https://primeluoqiu.github.io/categories/%E8%AE%A1%E7%BD%91/"}]},{"title":"1.3网络核心","slug":"计算机网络/1.3","date":"2024-03-23T06:21:31.662Z","updated":"2024-03-23T06:28:32.926Z","comments":true,"path":"2024/03/23/计算机网络/1.3/","link":"","permalink":"https://primeluoqiu.github.io/2024/03/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.3/","excerpt":"","text":"","categories":[{"name":"计网","slug":"计网","permalink":"https://primeluoqiu.github.io/categories/%E8%AE%A1%E7%BD%91/"}],"tags":[],"keywords":[{"name":"计网","slug":"计网","permalink":"https://primeluoqiu.github.io/categories/%E8%AE%A1%E7%BD%91/"}]},{"title":"1.2网络边缘","slug":"计算机网络/1.2","date":"2024-03-23T06:21:30.368Z","updated":"2024-03-23T06:28:33.782Z","comments":true,"path":"2024/03/23/计算机网络/1.2/","link":"","permalink":"https://primeluoqiu.github.io/2024/03/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.2/","excerpt":"","text":"","categories":[{"name":"计网","slug":"计网","permalink":"https://primeluoqiu.github.io/categories/%E8%AE%A1%E7%BD%91/"}],"tags":[],"keywords":[{"name":"计网","slug":"计网","permalink":"https://primeluoqiu.github.io/categories/%E8%AE%A1%E7%BD%91/"}]},{"title":"1.1什么是Internet","slug":"计算机网络/1.1什么是Internet","date":"2024-03-23T06:15:09.395Z","updated":"2024-03-23T06:28:38.121Z","comments":true,"path":"2024/03/23/计算机网络/1.1什么是Internet/","link":"","permalink":"https://primeluoqiu.github.io/2024/03/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.1%E4%BB%80%E4%B9%88%E6%98%AFInternet/","excerpt":"","text":"","categories":[{"name":"计网","slug":"计网","permalink":"https://primeluoqiu.github.io/categories/%E8%AE%A1%E7%BD%91/"}],"tags":[],"keywords":[{"name":"计网","slug":"计网","permalink":"https://primeluoqiu.github.io/categories/%E8%AE%A1%E7%BD%91/"}]},{"title":"CS61A.Chapter1","slug":"ClassesFormUCBerkely/CS61A/第一章：使用函数构造抽象","date":"2024-03-22T16:54:16.698Z","updated":"2024-03-23T12:51:07.757Z","comments":true,"path":"2024/03/23/ClassesFormUCBerkely/CS61A/第一章：使用函数构造抽象/","link":"","permalink":"https://primeluoqiu.github.io/2024/03/23/ClassesFormUCBerkely/CS61A/%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0%E6%9E%84%E9%80%A0%E6%8A%BD%E8%B1%A1/","excerpt":"","text":"之所以计算机科学的巨大生产力能够成为可能，都是因为其建立在一套优雅而强大的基本思想之上。所有计算都始于三点：信息的表示、处理的逻辑、设计抽象来管理逻辑的复杂性，掌握这些基础知识需要我们去精确理解计算机程序的构造和解释。 1.1.4 第一个例子Python内置了一些常见编程功能，例如处理文本，显示图形以及通过互联网进行通信。下面这行Python代码 1&gt;&gt;&gt; from urlib.request import urlopen 是一个import语句，它会导入一个用于”访问互联网数据”的功能，该功能特别提供了一个名为urlopen的函数，可以访问URL上的内容 语句和表达式Python代码由表达式和语句组成，从广义上讲，计算机程序由一下指令组成 计算一些值 执行一些操作语句通常描述操作，Python解释器每执行一条语句，计算机就会执行相应的操作。另外，表达式通常用于描述计算，当Python计算一个表达式时，它会计算出该式的值。 下面的赋值语句 1shakespeare = urlopen(&#x27;https://www.composingprograms.com/shakespeare.txt&#x27;) 将名称shakespeare与=后面的表达式的值相连，这个表达式将urlopen函数应用在了一个URL身上。 函数: 函数封装了操作数据的逻辑。urlopen就是一个函数，而网址是一个数据，莎士比亚的戏剧是另一个数据。从前者到后者的准换过程可能会很复杂，但我们可以将这种复杂性隐藏在一个函数中，从而能够使用一个简单的表达式来跳过该过程。函数是本章的主题 另一个赋值语句 1&gt;&gt;&gt; words = set(shakespare.read().decode().split()) 将words与莎士比亚戏剧中出现的共33721个单词的集合相连。其命令链调用了read、decode、split，每个函数都会操作一个中间的计算实体：从URL中read(读取)数据，然后将数据decode(解码)为文本，最后将文本split(拆分)为单词放在一个set中。 对象:set就是一种对象，支持如计算交际和集合关系(membership)等计算。对象无缝整合了数据以及用于操作该数据的逻辑，并隐藏了二者的复杂性对象是第二章的主题 最后，这个表达式 12&gt;&gt;&gt; &#123;w for w in words if len(W) == 6 and w[::1] in words&#125; &#123;&#x27;redder&#x27;, &#x27;drawer&#x27;, &#x27;reward&#x27;, &#x27;diaper&#x27;, &#x27;repaid&#x27;&#125; 是一个符合表达式，它的计算结果是反向拼写同时也为单词的莎士比亚单词集合。神秘符号w[::-1]表示枚举单词中的每个字母，其中-1代表反向枚举，当在交互式对话中输入表达式时，Python会在下一行打印值。 解释器：符合表达式的求解需要以一个可预测的方式来精确解释代码的过程。实现在这样的过程，用于计算复合表达式的程序就称为解释器。解释器的设计和实现是第三章的主题 与其他计算机程序相比，编程语言的解释器具有独特的通用性。Python在设计时并不会考虑莎士比亚，但它的高度灵活性使我们能够只用少量的语句和表达式来处理大量的文本。 最后，这些核心概念都是紧密相关的：函数是对象，对象是函数，解释器是二者的实例。但是，清楚的理解每一个概念及其在组织代码中的作用对于掌握编程艺术至关重要。 1.1.5 ERROR Python正在等待命令。即使可能还不了解完整的机会和结构，所以总会有一些失误的情况。因为计算机在极其灵活的同时也十分古板，计算机的特性在斯坦福的入门课程中被描述为 当尝试使用Python解释器时，计算机的古板会立即显现出来：即使是最小的拼写和格式更改也会导致预料之外的输出和错误。 学着解释错误和找到错误的原因被称为调试，关于调试的一些指导原则是： 增量测试：每个编写良好的程序都可以单独测试的小型模块化组件组成。尽快测试已经编写的所有内容，以尽早发现问题并获得对组件的信心。 隔离错误：语句输出中错误常可归因于特定的模块化组件。所以在诊断问题时，先追踪错误到最小的代码片段，然后再试着修复问题 检查假设：解释器会一字不漏地执行指令——不多也不少。当某些代码的行为与程序员假设的行为不匹配时，它们的输出就是不合预期的。明确假设，然后将调试的工作集中在验证假设上。 咨询别人：你不是一个人！如果你不理解错误信息，请询问朋友、老师或者搜索引擎，如果已经找出了一个错误，但却不知道如何更正，可以请其他人查看。 增量测试、模块化设计、明确的假设和团队合作时贯穿本书的主题，希望它们也贯穿你的计算机科学职业生涯。","categories":[{"name":"CS61A","slug":"CS61A","permalink":"https://primeluoqiu.github.io/categories/CS61A/"}],"tags":[],"keywords":[{"name":"CS61A","slug":"CS61A","permalink":"https://primeluoqiu.github.io/categories/CS61A/"}]},{"title":"CS61A.Chapter2","slug":"ClassesFormUCBerkely/CS61A/1.2 编程要素","date":"2024-03-22T16:54:16.694Z","updated":"2024-03-22T16:56:21.324Z","comments":true,"path":"2024/03/23/ClassesFormUCBerkely/CS61A/1.2 编程要素/","link":"","permalink":"https://primeluoqiu.github.io/2024/03/23/ClassesFormUCBerkely/CS61A/1.2%20%E7%BC%96%E7%A8%8B%E8%A6%81%E7%B4%A0/","excerpt":"","text":"编程语言不仅是一种指挥计算机执行任务的手段，它还应该成为一种框架，使我们能够在其中组织自己有关计算过程的思想。程序也会在社区之间互相分享，那么程序必须是人类可读，且恰巧能够被机器执行。 这样，当我们描述一种语言的时候，就需要特别注意该语言所提供的能够将简单思想组合成复杂思想的工具。那么每一种强大的语言都有这样三种机制 原始表达式和语句：语言所关心的最简单的个体。 组合方法：由简单元素组合构建复合元素 抽象方法：命名复合元素，并将其作为单元进行操作。在编程中，我们只会处理两种元素：函数和数据(之后会发现他们之间的区分实际上没那么明显)。不那么正式的说法是：数据是我们想要操作的东西。而函数是操作这些数据的规则的描述。 因此，任何强大的编程语言都必须能表达基本的数据和函数，并且提供对函数和数据进行组合和抽象的方法。 1.2.1 表达式下面就一点一点了解Python语言。先从一种基本表达式开始，也就是键入的数字，十进制的表达式 12&gt;&gt;&gt; 4242 表达式表达的数字可以与数学运算符组成一个复合表达式，解释器将对其进行求值： 1234&gt;&gt;&gt; -1 - -10&gt;&gt;&gt;1/2 + 1/4 + 1/8 + 1/16 + 1/32 + 1/64 + 1/1280.9921875 这些数学表达式使用的是中缀表示法，指的是运算符出现在操作数之间。Python包含多种形成复合表达式的方法，后面会慢慢介绍 1.2.2 调用表达式最重要的一种复合表达式就是调用表达式，它将函数运用于一些参数上。回想一下高中学过的函数概念：函数就是从一些输入参数到输出值的映射。例如, max函数会输出一个最大的输入值，也就是将多个输入映射到了单个输出上。Python中函数应用的方式与传统数学相同 12&gt;&gt;&gt; max(7.5, 9.5)9.5 这个调用表达式包含子表达式(subexpression):在括号之前是运算符表达式，而括号里面是一个以逗号分隔的操作数表达式的列表![[..&#x2F;..&#x2F;Pasted image 20240322110143.png]]运算符指定了一个函数，在对这个调用表达式进行求值时，我们会说，使用参数7.5和9.5来调用函数max，最后返回9.5 调用表达式中参数的顺序是很重要的。例如，pow函数的第二个参数是第一个参数的幂","categories":[{"name":"CS61A","slug":"CS61A","permalink":"https://primeluoqiu.github.io/categories/CS61A/"}],"tags":[],"keywords":[{"name":"CS61A","slug":"CS61A","permalink":"https://primeluoqiu.github.io/categories/CS61A/"}]},{"title":"acwing -堆排序","slug":"Algorithm/sort","date":"2024-03-21T13:54:55.018Z","updated":"2024-03-21T13:56:15.931Z","comments":true,"path":"2024/03/21/Algorithm/sort/","link":"","permalink":"https://primeluoqiu.github.io/2024/03/21/Algorithm/sort/","excerpt":"","text":"如何手写一个堆维护一个数据集合支持的基本操作： 插入一个数 求集合当中的最小值 删除最小值 还有操作可以支持 删除任意一个元素 修改任意一个元素 堆是一个二叉树，完全二叉树，树除了最后一层节点之外，上面的所有节点都是满的。最后一层节点从左到右排列。小根堆有个性质：每个点都小于左右儿子，一个递归定义，根节点就是整个数据结构的最小值。堆的存储：(全新的存储方式):用一个一维数组来存。堆状数据结构几乎都可以用一位数组来存储。 存储的话，数组的第一个节点是根节点，然后从x开始，x的左儿子是2x, x的右儿子是2x+1有两种操作，分别是up 和 down，五个操作都可以用这两个函数来解决。 down操作实际上就是在这三个数字里面找到最小的数字，然后把最大的数字和最小的数字进行交换，然后把相对来说小的数推上去 插入一个数：heap [++size] &#x3D; x; up(size); 求集合当中的最小值:heap[1]; 删除最小值 用堆的最后一个元素来覆盖掉堆顶的元素，然后再把堆顶down一下即可。删除头节点比较困难，尾节点比较简单。 heap[1] &#x3D; heap[size]; size –;down(1); 删除任意一个元素: heap[k] &#x3D; heap[size]; heap –; down(k); up(k); 分情况讨论，变大就down一遍，变小就up一下，或者直接不管，up，down一边就行。 修改任意一个元素:heap[k] &#x3D; x; down(k); up(k);下标从1开始 然后我们来看一道题： 1输入一个长度为n的整数数列，从小到大输出前m小的数。 通过读题我们可以看出来，在这里我们只需要down这个操作，我们来看一下down这个操作是怎么实现的 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1e6 + 10;int n, m;int h[N], cnt; //存的heap和存了多少元素//我们只需要把数组建成堆，然后每一次输出堆顶，第一次输出就是第一小的数，然后是第二小的数，然后balabala//需要第二个操作和第三个操作，然后我们发现只需要实现down就可以了。void down(int u)&#123; int t = u; if(u * 2 &lt;= cnt &amp;&amp; h[u * 2] &lt; h[t]) t = u * 2; if(u * 2 + 1 &lt;= cnt &amp;&amp; h[u * 2 + 1] &lt; h[t]) t = u * 2 + 1; if(u != t) &#123; swap(h[u], h[t]); down(t); &#125;&#125;int main()&#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for(int i = 1; i &lt;= n; i ++) scanf(&quot;%d&quot;, &amp;h[i]); cnt = n; //正常输入，然后建堆，如果是一个一个往里面插入的话，时间复杂度是(nlogn)的，有一种时间复杂度是O(n)的方法是从1/2开始往下down for(int i = n / 2; i; i --) down(i); while(m --) &#123; printf(&quot;%d &quot;, h[1]); h[1] = h[cnt]; cnt --; down(1); &#125; return 0;&#125; 至于为什么是O(n)的呢？ down操作很简单，用t来表示三个点里面的最小值，首先判断一下有没有左儿子。 1234567891011void down(int u)&#123; int t = u; if(u * 2 &lt;= size &amp;&amp; h[u * 2] &lt; h[t]) t = u * 2; if(u * 2 + 1 &lt;= size &amp;&amp; h[u * 2 + 1] &lt; h[t]) t = u * 2 + 1; if(u != t) &#123; swap(h[u], h[t]); down(t); &#125;&#125;","categories":[{"name":"acwing","slug":"acwing","permalink":"https://primeluoqiu.github.io/categories/acwing/"}],"tags":[],"keywords":[{"name":"acwing","slug":"acwing","permalink":"https://primeluoqiu.github.io/categories/acwing/"}]},{"title":"Lecture 5 - List3","slug":"计算机网络/Lecture5 - List3 DLList And Arrays","date":"2024-03-20T14:21:05.839Z","updated":"2024-03-21T13:56:27.690Z","comments":true,"path":"2024/03/20/计算机网络/Lecture5 - List3 DLList And Arrays/","link":"","permalink":"https://primeluoqiu.github.io/2024/03/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Lecture5%20-%20List3%20DLList%20And%20Arrays/","excerpt":"","text":"之前说到的SLList还是很不错的，不过目前来看的话它存在了一个新的问题，就是对于addLast函数而言，还是相对来说比较缓慢地，效率也是比较低的。 就像是最一开始的size函数，那么我们有什么办法可以提高它的效率呢，我们可以在中间人那里再定义一个last函数用来保存最后一个节点的地址，不过这样的话，就会有新的操作效率较慢了 那便是remove操作，那么如果我们想要删除一个节点的话，那么我们只能首先遍历到节点那里，然后删除这个节点的指针，然后再将last的那个指针指向删除的节点的前一个节点。这听起来实在是太麻烦了，所以这种方法似乎也是不可取的。那么还有什么别的方法吗 那么，我们就想到能不能就是给每一个节点添加一个当前节点的前置节点的指针呢？答案是可以的 这种每个节点都有两个链接的列表叫做双向链表 完成这种方法之后，我们的添加在头部和尾部，删除头部和尾部的方法就会变得十分的快，不过在中间的节点操作相对来说就会比较慢。 不过这样的链表还是会存在一个 限制有这样一种情况：最后一个节点的next指针有的时候指向最开始的哨兵节点，有的时候指向我们称之的最开始的节点(real node)。那么就有可能需要我们在后面再去写相关的判断语句来判断它是否真的是哨兵节点。 为了避免这种麻烦的情况，我们尝试让他变得更纯粹一些。 所以为了完善我们的方法的最自然的方法就是添加第二个哨兵，然后让着第二个哨兵来指向最后一个节点，我们不再是一个指向最后一项的一个指针，而是在开始和末尾两端都添加一个哨兵（因为此时我们已经有了prev和next指针），这样的话，前面就有一个哨兵，后面也有一个哨兵了，那么这样再添加节点或者项目的时候，就只需要将节点滑入这两个哨兵之间就可以了 那么其实还有一种办法，这里依旧还是只有一个哨兵，它既是前面的哨兵也是后面的哨兵 ![[../一些截图（笔记用）/Pasted image 20240226134251.png]] 就像这里的，先指向哨兵节点，然后指向3，指向9，最终再回到sentinal.所以这实际上更像一个循环。 不过即便是这样，还是会有一个限制，就是说在现实世界中不太好使，就是说，如果我们要添加的东西是数字时，它会非常的好用，但是如果我们添加的是字符串或者字符呢？我们又该怎么办，例如 123456public class SLListLauncher &#123; public static void main(String[] args) &#123; SLList s1 = new SLList(&quot;Bone&quot;); s1.addFirst(&quot;thugs&quot;); &#125;&#125; 也就是说，我们不能将字符串转化成整数这样的报错。 我们可以选择重新创建一个全新的SLList类，不过这意味着我们还需要重新写一遍我们的类。这听起来可太麻烦了。 不过，还有一种方法就是使SLList参数化，我们可以参数化SLList将采用的类型，这应该如何操作呢 就是我们要在SLList后面添加新的尖括号&lt;&gt;，然后在尖括号里面添加任意的字符串，例如LochNess，这是充当创建SLList时尚未决定的类型的占位符，因此这个时候我们将使用LochNess来代替int项，然后这个时候我们也会将我们创建一个节点的名字改成 123private class StuffNode(LochNess i, StuffNode n) &#123; ...&#125; 定义是这样的 123456public class SLList&lt;LochNess&gt; &#123; private class StuffNode &#123; public LochNess item; public StuffNode next; &#125;&#125; 这个时候我们只需要将main函数修改一下即可 现在想要创建一个SLList的话，需要指定一个类型 1SLList&lt;String&gt; s1 = new SLList&lt;String&gt;(&quot;bone&quot;); //定义并实例化 然后就正常工作了。 在我们使用的时候，我们往&lt;&gt;里传什么，对应的函数里的&lt;&gt;也会传什么，所以它基本上是一个类型变量或类型参数 在更现代的java中，不再需要在实例化方面指定类型，也是行得通的。 在指定类型的时候，只需要指定一次计科，可以在其他地方多次使用它。使用的时候尖括号内的首字母需要大写!!!","categories":[{"name":"CS61B","slug":"CS61B","permalink":"https://primeluoqiu.github.io/categories/CS61B/"}],"tags":[],"keywords":[{"name":"CS61B","slug":"CS61B","permalink":"https://primeluoqiu.github.io/categories/CS61B/"}]},{"title":"Hello World","slug":"计算机网络/Lecture4-List 2 SLLists","date":"2024-03-20T14:21:05.838Z","updated":"2024-03-20T14:24:22.475Z","comments":true,"path":"2024/03/20/计算机网络/Lecture4-List 2 SLLists/","link":"","permalink":"https://primeluoqiu.github.io/2024/03/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Lecture4-List%202%20SLLists/","excerpt":"","text":"Video 1:Class A:Introducing the SLListLast Time in 61B: Recursive Implementation of a List 12345678910public class IntList &#123; public int first; public IntList rest; public IntList(int f, IntList r) &#123; first = f; rest = r; &#125;&#125;... While functional, “naked”linked lists like the one above are hard to use. Users of this class are probably going to need to know references very well, and be able to think recursively.Let’s make our users’ lives easier.这些代码对于我们来讲是比较容易看懂的，但是对于用户来讲可能就比较费解，那么我们需要一些其他的方式来重新叙写我们的IntList。对它进行更新换代，以至于让我们的用户理解起来也很方便 Improvement #1: Rebaranding and Culling123456789public class IntNode &#123; public int item; public IntNode next; public IntNode(int i, IntNode n) &#123; item = i; next = n; &#125;&#125; IntNode is now dumb, has no methods.We will reintroduce functionality in the coming slides. Not much of an improvement obviously, but this next weird trick will be more impressive. Class B:Introducing the SLList Bureaucracy这个也提供了一些小方面的改善。下一步，我们创建另一个类，命名为SLList，这个类表示是一个整数列表，隐藏了内部是单纯的数字的真相。这个列表的工作原理是我们已经有一个IntList类 123456789101112131415package Lecture4; /* An SLList is a list of integers, which hides the terrible truth * of thr nakedness within. */ public class SLList &#123; public IntNode first; public SLList(int x) &#123; first = new IntNode(x, null); &#125; public static void main(String[] args) &#123; /*Create a list of one integer, namely 10*/ SLList L = new SLList(10); &#125; &#125; 那么我们为什么要做这种看起来似乎没什么意义的事情呢？这是一个线索，如果考虑一下某个程序员如何创建列表，那么他实际上不必指定null，只需要添加一个数字即可。在之前，当我们想要创建一个列表，我们需要 1IntNode X = new IntNode(10, null); 而现在我们只需要 1SLList Y = new SLList(10); SLList is easier to instantiate(no need to specify null), but wait, there’s more. 123456public class SLList &#123; public IntNode first; public SLList(int x) &#123; front = new IntNode(x, null); &#125;&#125; Next: Let’s add addFirst and getFirst method to SLList. Class C: Introducing the SLList Methods在我们拿走了IntNode能做的所有事情之后，我们将会在SLList中还原他，接下来是我们准备还原的一部分addFirst getFirst当我们想要完成第一个函数的addFirst的时候，我们可以从之前的IntList当中寻找灵感，在这里我们创建一个新的点的时候![[..&#x2F;..&#x2F;Pasted image 20240126093348.png]]用到的是L = new IntList，那么我们在这里也是 1234// Add x to the front of the list.public void addFirst(int x) &#123; first = new IntNode(x, null); &#125; 至于getFirst的话，相对来说我们只需要返回第一个的item，相对来说会简单很多 1234// Returns the first item in the listpublic int getFirst() &#123; return first.item;&#125; SLLists vs. IntLists对比一下之前写的和最近写的 123456789SLList L = new SLList(15);L.addFirst(10);L.addFirst(5);int x = L.getFirst();IntList L = new IntList(15, null);L = new IntList(L, 10);L = new IntList(L, 5);int x = L.first; While functional, “naked”linked lists like the IntList class are hard to use. Users of IntList are need to know Java references well, and be able to think recursively. SLList is much simpler to use. Simply use the provided methods. Why not just add an addFirst method to the IntList class? Turn out there is no efficent way to do this. See exercise in LectureCode repository. Video 2: Access Control and Nested Classes我们不难发现，SLList是很好用的，想要添加，删除，或者获取内容的话，最好使用该类提供的方法，不过，根据java的工作效益，可以尝试做一些奇怪的事情。 123456789101112public class SLList &#123; public IntNode first; public SLList(int x) &#123; first = new IntNode(x, null); &#125; public void addFirst(int x) &#123; first = new IntNode(x, first); &#125; ...&#125; Users of our classes might be tempted to try to manipulate our secret IntNode directly in uncouth ways! 123SLList L = new SLList(15);L.addFirst(10);L.first.next.next = L.first.next; 显然，这是不被允许的。可以猜一下会发生什么![[..&#x2F;..&#x2F;Pasted image 20240127092904.png]]![[..&#x2F;..&#x2F;Pasted image 20240127092922.png]]它最终会指向自身，我们最终毁掉了这个列表。很显然，我们并不想被类似这样的调用其他方法来毁掉我们的列表，因此我们可以在我们的程序之前添加注释，类似 1/*Don&#x27;t mess up my programmer*/ 但是这很显然没有下述方式来的更加畅快 Access Control 123456789101112public class SLList &#123; public IntNode first; public SLList(int x) &#123; first = new IntNode(x, null); &#125; public void addFirst(int x) &#123; first = new IntNode(x, first); &#125; ...&#125; We can prevent programmers from making such mistakes with the private keyword.我们可以给类的成员声明为private而不是声明为public例如 1private IntNode first; 现在，好处是，这不仅是自行记录的，而且还有编译器强制执行，那么在别的类中访问这个变量就会报错因此private关键字的作用是防止其他类中的代码使用该类的成员(包括变量，方法…)不过，java中有一个有趣的功能称为反射。允许绕过这些修饰符，不过很少使用。 Why Restrict Access?Hide implementation details from users of your class. Less for user of class to understand. Safe for you to change private methods.(implementation).E.g:Car analogy: Public: Pedals, Steering Wheel Private:Fuel line, Rotary valve. Despite the term ‘access control’: Nothing to do with protection against hackers, spies, and other evil entities.至于为什么要限制通过呢，也就是说为什么要用private，一个方面是为了对使用你的类的人隐藏实施细节，他们不需要了解这个原理是什么，他们有对应的输入和输出即可。其次，对你来讲去修改这种私有方法是很安全的。例如在一个车的系统当中，公共的部分有例如踏板，轮胎这些，而私有的例如燃油管线（现在有纯电车）。不过，当有人获取到你的源码之后，这些所谓的安全也就不存在了。 总结一下，私有就是你可以随便处置但是用户不可以，公共就是都可以访问你的方法等一系列东西。 Improvement 4: Nested ClassesCan combine two classes into one file pretty simply. 123456789101112131415public class SLList &#123; public class IntNode &#123; //Nested class definition public int item; public IntNode next; public IntNode(int i, IntNode n) &#123; item = i; next = n; &#125; &#125; // Could have made IntNode a private nested class if we wanted.private IntNode first; //Instance variables, constructors, and methods of SLList typical go below nested class definition.public SLList(int x) &#123; first = new IntNode(x, null); &#125;...&#125; 一个嵌套的类定义，那么，嵌套的类有什么好处呢？ Why Nested Classes?Nested Classes are useful when a class doesn’t stand on its own and is obvious subordinate(从属，下属) to another class. Make the nested(嵌套的) class private if other classes should never use the nested class. In my opinion, probably makes sense to make IntNode a nested private class. Hard to imagine other classes having a need to manipulate IntNodes Static Nested Classes If the nested class never uses any instance variables or methods of the outer class, declare it static Static classes cannot access outer class’s instance variables or methods. Results in a minor savings of memory. See book for more details.123456789101112public class SLList &#123; private static class IntNode &#123; //we can declare IntNode static, since it never use any of SLList&#x27;s instance variables or methods. public int item; public int IntNode next; public IntNode(int i, IntNode n) &#123; item = i; next = n; &#125; &#125; ...&#125; Unimportant note:For private nested classes, access modifiers are irrelevant.如果嵌套类从不需要查找，那么可以添加staitc关键字。 Video3: addLast and sizeAdding more SLList Functionality To motivate our remaining improvements, and to give more functionality to our SLList class, let’s add: .addLast(int x) .size()Recommendation: Try writing them yourself before watching how I do it.添加了两个其他的方法。 12345678910public void addLast(int x) &#123; IntNode p = first; /*Move p until it reaches the end of the list. */ while(p.next != null) &#123; p = p.next; &#125; p.next = new IntNode(x, null); &#125; 当想要尝试.size()的时候，我们发现试图搞清楚基本情况是比较困难的。如果使用递归的话情况也是很奇怪，如果想要用递归来做的话，那么就无从下手。原因是SLList这个数据结构本身就不是递归的，它没有SLList指针。因此只能采用相对来说通用性更强一些的策略了、 通常会创建一个私有的静态帮助器方法，它会采用一个特定的节点来帮助我们解决这个问题。所以现在的话，这就是一个非常清晰的递归数据结构 那么这样的话 123456789private static int size(IntNode p) &#123; if(p.next == null) return 1; return 1 + size(p.next); &#125; public int size() &#123; return size(first); &#125; Video 4: Caching假设有一个长度为1000的SLList，我们遍历一遍获得它的长度的时间是两秒，那么如果有一个长度为1,000,000的链表的时候，时间就是2,000秒，那么这个函数实际上是效率很低的，那么我们应该用什么方式来提高它的效率呢？ 我们可以选择在类的内部定义一个私有的成员变量size，然后在类似addFirst, addLast这里对size += 1，然后在定义一个链表的时候让size = 1，这样在写size函数的时候直接return size即可。 不过其实，这样和遍历一个链表的所花费的空间或者说时间还是一样的，只不过是把一个很大的任务分散化了， 也就是说，当我们每操作一次链表，size的值就会被更新一下。 那么还有没有别的办法呢 当然肯定是有的。就是利用我们最开始引入的那个中间人，也就是first节点，在这里我们可以用他来存储有关整个列表的元信息的自然位置 之前说过`SLList`有一个很好的优势，就是每当想要操作数据或者查看数据的时候，都必须经过这个中间人，这个中间人为我们提供了非常简单易懂的办法来保证安全，避免我们以各种方式搬起石头砸自己的脚。 现在`SLList`结构拥有这个中间人的另一个好处是，它可以作为存储有关整个列表元信息的自然位置。例如，我们可以在这里存储列表的大小，这在技术上是多余的，我们可以在没有这个变量的情况下计算大小，但它会加快大小的计算速度，因为我们只需要返回这个大小的值，我们也可以在这里存放其他东西，就像可以存储曾经放入其中的最大值、最小值等，这些也可以正常工作。 相比之下，使用裸递归列表就不那么容易了，指图片中的上者，原则上可以执行诸如缓存每个节点内部的大小之类的操作。但即便如此，这也意味着每当我们更改列表中的某些内容时，都必须更新一堆大大小小的变量，例如如果有一种允许这样做的语言，我们还可以以某种方式在此处绑定一个变量来跟踪整个事物的大小。但是在Java中，没有天然的工具（函数）可以做到这一点。因此，实际上，我们最终要做的就是拥有多个必须保持一致的变量，在这里，这种面向对象的编程方法意味着我们让对象来控制一切，我们告诉对象，你的工作不仅是王城所有这些任务，还要为我跟踪尺寸，这样，这就是组织代码的自然方式。 也就是说，`intList`可以做`SLList`可以做的所有的事情，但是`SLList`在几乎所有方面都是一种更自然的方法 Video 5 The Empty List那么SLList这么好用，他还可以允许我们自己代表空列表，也就是说创建列表的时候可以很自然的实例化一个空列表，那么我们来修改一下我们的代码 123456/*Create an empty SLList*/public SLList()&#123; size = 0; first = null; &#125; 源码此时是这样的 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package Lecture4; /* An SLList is a list of integers, which hides the terrible truth * of thr nakedness within. */ import Lecture3.IntList; public class SLList &#123; public IntNode first; private int size; public SLList() &#123; first = null; size = 0; &#125; /*Creates an empty SLList*/ public SLList(int x) &#123; first = new IntNode(x, null); &#125; // Adds x to the front of the list. public void addFirst(int x) &#123; first = new IntNode(x, first); size += 1; &#125; // Returns the first item in the list. public int getFirst() &#123; return first.item; &#125; //Adds x to the last of the list. public void addLast(int x) &#123; IntNode p = first; /*Move p until it reaches the end of the list. */ while(p.next != null) &#123; p = p.next; &#125; p.next = new IntNode(x, null); size += 1; &#125; /*Returns the sizes of the list from IntNode p*/ /*private static int size(IntNode p) &#123; if(p.next == null) return 1; return 1 + size(p.next); &#125; public int size() &#123; return size(first); &#125;*/ public static void main(String[] args) &#123; /*Create a list of one integer, namely 10*/ SLList L = new SLList(); L.addFirst(10); L.addFirst(5); L.addLast(20); System.out.println(L.size); &#125; &#125; 结果自然而然的就是3但是实际上这个代码会存在一个小小的bug就是，如果我们不是先从头插入的话，就会报错，例如我们第一步先用addLast的话就会报错![[..&#x2F;一些截图（笔记用）&#x2F;Pasted image 20240222155831.png]]是因为我们将一个指针指向了空指针，然而空指针的下一位是空的，就会报错。那么我们应该如何处理这个问题呢？有一个方法就是在addLast中添加一个判断语句，即 123456789public void addLast(int x)&#123; size += 1; if(first == null) &#123; first = new IntNode(x, first); return; &#125; ...&#125; 这样再看的话，我们的程序目前工作就正常了![[..&#x2F;一些截图（笔记用）&#x2F;Pasted image 20240222160836.png]] Video 6: Sentinel Nodes在我们了解到上述问题之后，其实还有一种解决的方式，这种方式未来会在我们在构筑大型项目上的时候有所优势。就是创建一个哨兵节点，然后哨兵节点来传递到第一个节点、第二个节点…这些，然后我们用一个指针来讲创建的列表指向我们的哨兵节点，这样的话无论列表是不是空的都会有一个节点在那里。不过这样的话，我们就需要对基本上所有的函数进行修改了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package Lecture4; /* An SLList is a list of integers, which hides the terrible truth * of thr nakedness within. */ import Lecture3.IntList; public class SLList &#123; private static class IntNode &#123; public int item; public IntNode next; public IntNode(int i, IntNode n) &#123; item = i; next = n; &#125; &#125; private int size; /*The first item (if it exists) is at sentinel.next*/ private IntNode sentinel; public SLList() &#123; sentinel = new IntNode(66, null); size = 0; &#125; /*Creates an empty SLList*/ public SLList(int x) &#123; sentinel = new IntNode(66, null); sentinel.next = new IntNode(x, null); size = 1; &#125; // Adds x to the front of the list. public void addFirst(int x) &#123; sentinel.next = new IntNode(x, sentinel.next); size += 1; &#125; // Returns the first item in the list. public int getFirst() &#123; return sentinel.next.item; &#125; //Adds x to the last of the list. public void addLast(int x) &#123; size += 1; IntNode p = sentinel; /*Move p until it reaches the end of the list. */ while(p.next != null) &#123; p = p.next; &#125; p.next = new IntNode(x, null); &#125; /*Returns the sizes of the list from IntNode p*/ /*private static int size(IntNode p) &#123; if(p.next == null) return 1; return 1 + size(p.next); &#125; public int size() &#123; return size(first); &#125;*/ public static void main(String[] args) &#123; /*Create a list of one integer, namely 10*/ SLList L = new SLList(); L.addFirst(10); L.addFirst(5); L.addLast(20); System.out.println(L.size); &#125; &#125; 改完之后就是大致这样的 那么哨兵节点实际上就是一个虚拟的节点，一个忠实的伙伴。鉴于第一个不再指向第一项，那么我们重命名它为哨兵代码 当然，哨兵对于我们便携的所有代码来说它永远不会为空，并且它总是指向哨兵节点，哨兵节点的值可以随机，我在这里选择了66.当我们编写带么和检查每个构造函数和方法时，我们必须确保所有内容都与我们的哨兵节点兼容。理想情况下，一开始就这样做的话这样就不会感觉那么随意。我们不会一次性做出一堆微小的改变 Video 7: Invariants我们可以使用术语不变性来概括这种保持简单的想法。因此不变量只是一个在代码运行时保证为真的条件。所以它列出了所有可以信赖的事实。因此，带有哨兵节点的SLList那么它总是具有一些不变量，例如哨兵变量——哨兵应用它总是指向一个哨兵节点，这是我们所拥有的东西，并且保证是真实的另一个是列表中的第一个节点(如果存在的话)，那么它始终位于sentinel.next，事实上，这在代码中是作为注释明确写出得一个不变量。 因此，不变量的好处是它可以让我们更容易地推理代码它可能让我们避免出错","categories":[{"name":"CS61B","slug":"CS61B","permalink":"https://primeluoqiu.github.io/categories/CS61B/"}],"tags":[],"keywords":[{"name":"CS61B","slug":"CS61B","permalink":"https://primeluoqiu.github.io/categories/CS61B/"}]},{"title":"Hello World","slug":"计算机网络/Lecture3-List 1 Refrence Recursion and Lists","date":"2024-03-20T14:21:05.836Z","updated":"2024-03-20T14:24:20.763Z","comments":true,"path":"2024/03/20/计算机网络/Lecture3-List 1 Refrence Recursion and Lists/","link":"","permalink":"https://primeluoqiu.github.io/2024/03/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Lecture3-List%201%20Refrence%20Recursion%20and%20Lists/","excerpt":"","text":"Welcome!MenuLecture 3: References and Recursion Primitive Types Reference Types Linked Data Structures List In lecture2, we saw how we can create a List in Java. Unlike Python, lists are not bulit directly into the Java language123456import java.util.List;import java.util.LinkedList;List&lt;String&gt; L = new LinkedList&lt;&gt;();L.add(&quot;a&quot;);L.add(&quot;b&quot;); Today, we’ll begin our 3 lecture journey towards building our own list implementation We’ll exploit recursion to allow our list to grow infinitely large. But first we need to slove … the mystery of the walrus Video 1:The Mystery of the Walrus.先看一段代码并回答一个问题： 123456Walrus a = new Walrus(1000, 8.3) //创建了一个海象的类，前面是体重，后面是象牙大小Walrus b;b = a;b.weight = 5;System.out.println(a);System.out.println(b); Will the change to b affect a?(y&#x2F;n) :… 12weight: 5, tusk size: 8.30weight: 5, tusk size: 8.30 我们很惊讶的发现A居然会受到B的影响，体重居然被改成了5.接下来，再看一段代码，回答一个问题 123456int x = 5;int y;y = x;x = 2;System.out.println(&quot;x is:&quot; + x);System.out.println(&quot;y is:&quot; + y); Will the change to x affect y?(y&#x2F;n)… 12x is: 2y is: 5 但是在这里我们发现x并不受y的影响，但是这到底是为什么呢？接下来，让我们在可视化工具这里运行他，发现差异的地方 12345678910111213141516171819202122232425262728293031public class PollQuestions &#123; public static void main(String[] args) &#123; Walrus a = new Walrus(1000, 8.3); Walrus b; b = a; b.weight = 5; System.out.println(a); System.out.println(b); int x = 5; int y; y = x; x = 2; System.out.println(&quot;x is: &quot; + x); System.out.println(&quot;y is: &quot; + y); &#125; public static class Walrus &#123; public int weight; public double tuskSize; public Walrus(int w, double ts) &#123; weight = w; tuskSize = ts; &#125; public String toString() &#123; return String.format(&quot;weight: %d, tusk size: %.2f&quot;, weight, tuskSize); &#125; &#125;&#125; ![[Pasted image 20240119121426.png]]在b=a这里时，我们可以看到，我们有两个箭头指向同一个Walrus，所以无论出于何种原因a和b实际上指的都是同一只海象，如果执行b.weight = 5那么就会改变着一个海象(Walrus)的值，因此打印出来为5就不那么奇怪了。 那么整数情况呢![[Pasted image 20240119123108.png]]我们发现在图中这两个整数对应的是两个小盒子，修改的话只会修改对应的小盒子的值。那么，这到底是为什么呢？ Video 2: Primitive Types这个时候就要先解释一下计算机的底层工作原理了(61C) Bits Your computer stores information in “memory” Information is stored in memory as a sequence of ones and zeros Example:72 stored as 01001000 Example:205.75 stored as …01000011 01001101 11000000 00000000 Example:The letter H stored as 01001000(same as the number 72)(计算机知道如何根据特定上下文解释这些位) Example:True stored as 00000001Each Java type has a different way to interpret the bits: 8 primitive types in Java:byte, short, int, long, float, double, boolean, char 想要存储在计算机上的东西实际上都存储在所谓的内存中，内存所存的信息都被编码为0和1的序列即使H和72有单独的表现形式，该类型也会告诉Java解释器如何解释这个变量应该是什么。因此如果有一个字符类型的变量，那么当它看到后面的序列的时候就会考虑到字符H。但是如果有一个整数变量，那么当它看到后面的序列的时候就会考虑到72 Declaring a Variable(Simplified) When you declare a variable of a certain type in Java: Your computer sets aside exactly enough bits to hold a thing of that type. Example:Declaring an int sets aside a “box” of 32 bits. Example:Declaring an double sets aside a “box” of 64 bits. Java creates an internal(内部的) table that maps(映射) each variable name to a location. Java does NOT write anything into the reserved boxes. For safety, Java will not let access a variable that is uninitialized(未初始化的).1234int x;int y; //以上只是声明，并未赋值x = -1431195969;y = 567213.112; 当运行int x的时候，我们得到了一个长度为32位的盒子，而运行double y的时候，我们得到了一个64位的盒子。虽然我们在定义变量的时候并没有往里面放入任何东西，但是实际上里面是有东西的，是因为内存是一些世界上主观存在的物理对象。所以内存将包含一些0和1的序列。但是Java并不允许实际访问现有的信息。这有点像在着急的时候从桌子上拿起来一张纸，因为需要快速写下笔记，类似电话号或者一些其他的事情，上面可能已经有一些东西了，但是我们通常不关心它。因为我们拿起来是想要写一些我们要关注的东西。那么因此，当我们在定义玩变量但是未赋初值的时候，这种操作是不被允许的。 接下来，当运行赋值语句的时候，这些数值就会被变化成一串带有0和1的序列存到int的32位的盒子中，而y存进对应的64位的盒子中。![[Pasted image 20240119153743.png]] Simplified Box Natation We’ll use simplified box notation from here on out: Instead of writing memory box contents in binary,we’ll write them in human readable symbols.正是因为当我们看见那一串0和1的序列的时候看起来很长，很令人生畏。那么这种所谓方框表示法是可以被简化的。也就是说，当我们对x和y存入值的时候，我们用我们能够更轻易理解的数字来代替那些二进制形式写出的内存盒。当x&#x3D;-1431195969的时候，我们就用这一串数来存进去，y同理。而它也就恰好和Java Visulizer所展现的是一样的原理。![[Pasted image 20240119154105.png]]接下来，就可以解开这项谜题了 The Golden Rule of Equals(GRoE) Given variables y and x: y &#x3D; x copies all the bits from x into y.![[Pasted image 20240119154447.png]][https://cscircles.cemc.uwaterloo.ca/java_visualize/#mode=display] 12345678910public class PollQuestions &#123; public static void main(String[] args) &#123; int x = 5; int y; y = x; x = 2; System.out.println(&quot;x is: &quot; + x); System.out.println(&quot;y is: &quot; + y); &#125;&#125; 那么当x被执行等于2的时候，根据GRoE法则，也就是只会把用二进制表示的二的这些位放入x所表示的那个框中。所以y没有被改变。有两个不同的盒子。这就是整数为什么不会发生变化所表现出来的答案。 Video 3: Reference TypesReference Types There are 8 primitive(原始的) types in Java： byte, short, int, long, float, double, boolean, charEverything else, including arrays,is a reference(引用) type Class Instantiations When we instantiate an Object(e.g Dog, Walrus, Planet): Java first allocates a box of bits for each instance variable of the class and fills them with a default value(e.g 0, Null). The constructor then usually fills every such box with some other value.123456789public static class Walrus &#123; public int weight; public double tuskSize; public Warlus(int w, double ts) &#123; weight = w; tuskSize = ts; &#125;&#125; 00:53 (一个例子)通过这个例子可以看出来每当我们调用new的时候，Java会做的事就是挖掘内存，并找到96位(一个double一个int加起来一共96位)，然后函数找到之后用1000填充这个顶部位，8.3填充那个底部位在此处可见02:46 new关键字可以认为是返回了一个放置这个东西的一个首位数。Can you think of new as returning the address of the newly created object. Address in Java are 64 bits. Example(rough picture): If object is created memory location 23874723423, then new returns 2384723423.接下来讨论一下引用类型变量的声明 Reference Type Variable DeclarationsWhen we declare a variable of any reference type(Warlus, Dog, Planet): Java allocates exactly a box of size 64bits, no matter what type of object. These bits can be either set to: Null(all zeros). The 64 bits “address” of a specific instance of that class(return by new)当我们声明的时候,Java会做的就是分配一个刚好64位的盒子（无论类型是什么），这些盒子的返回值可以是0，也可以设置为new返回的该类的特定实例的地址。04:21 也就意味着说，即使Warlus本身需要96位，但是我们存储的地址依旧是64位的 06:19 介绍了一种方法来简化上面的表达方式，同样也是在Java Visulizer中呈现的 The 64 bit address are meaningless to us as humans, so we’ll represent: All zero addresses with “null” Non-zero addresses as arrows.This is sometimes called “box and pointer” notation.上述是原理 Reference Types Obey the Golden Rule of Equals 06:58 对于Warlus的一步一步解释 Just as with primitive types, the equals sign copies the bits. In terms of our visual metaphor, we “copy” the arrow by making the arrow in the b box point at the same instance as a.1234Warlus a;a = new Warlus(1000, 8.3);Warlus b;b = a; equal只是复制位，这对于基本类型是正确的，对于引用类型也是一样的。 Video 4: Parameter PassingThe Golden Rule of Equals(and Parameter Passing) Given variables b and a: b &#x3D; a copies all the bits from a into b.Passing parameters obeys the same rule:Simply copy the bits（This is also called by value按值传递) to the new scope.Example:123456789public static double average(double a, double b) &#123; return (a + b) / 2;&#125;public static void main(String[] args) &#123; double x = 5.5; double y = 10.5; double avg = average(x, y);&#125; 例子解释在00:31 总结： The Golden Role: Summary There are 9 types of variables in Java: 8 primitive types(bytes, short, int, long, float, double, boolean, char). The 9th type is references to Object(an arrow). References may be null. In box-and-pointer notation, each variable is drawn as a labeled box and values are shown in the box. Addresses are represented by arrows to object instance. The golden rule: b &#x3D; a copies the bits from a into b. Passing parameters copies the bits Video 5:Test Your Understand of the GRoETest Your Understanding:Does the call to doStuff(walrus, x) have an affect on Warlus and&#x2F;or main’s x? 123456789101112public static void main(String[] args) &#123; Warlus walrus = new Warlus(3500, 10.5); int x = 9; doStuff(warlus, x); System.out.println(warlus); System.out.println(x);&#125;public static void doStuff(Warlus W, int x) &#123; W.weight = W.weight - 100; x = x - 3;&#125; A. Neither will change.B. warlus will lose 100 lbs, but main’s x will not change.√C. warlus will not change, but main’s x will decrease by 5.D. Both will decrease. 解开答案在视频的这一段01:06 简单的来说，就是因为对象类数组是通过一个指针进行访问的，不管是哪个函数，只要是引用到了warlus这个对象，那么都会通过对应的指针访问到这个变量当中，最终修改它最后的值，而数字x所存的是那个数字对应的二进制符号，那么在函数中修改的话，修改范围也就仅限那个函数![[..&#x2F;..&#x2F;Pasted image 20240124112801.png]] Video 6:Instantiating Arrays.视频讲解02:13 Declaration and Instantiation of Arrays Arrays are also Objects.As we’ve seen, object are (usually) instantiated using the new keyword. Planet p = new Planet(0, 0, 0, 0, 0, &quot;blah.png&quot;); int []x = new int[]&#123;0, 1, 2, 95, 4&#125;;1int [] a;//Declaration Declaration creates a 64 bit box intended only for storing a reference to an int array.No objects in instantiated(声明创建了一个64位的盒子，仅仅用于存储对int数组的引用，但是并没有实例化对象)1new int[]&#123;0, 1, 2, 95. 4&#125; Instantiates a new Object, in this case an int array. Object is anonymous上述两种类型创建的数组都是没有效果的，第一个只是声明了有一个a数组，然后并没有对它进行实例化。而第二个数组是anonymous(匿名的)，也就是说，并没有给它赋予名字，new这个函数返回的是一个地址，也就是存放这个数组的地址，但是显然没有一个名称赋予给这个地址的变量，那么在执行完这句话之后这个数组也就会消失。 Assignments of Arrays 1int [] a = new int[]&#123;0, 1, 2, 95, 4&#125;; Creates a 64 bit box for stroring an int array address.(declaration) Creates a new Object, in this case an int array.(instantiation) Puts the address of this new Object into the 64 bit box named a.(assignments) Note: Instantiated objects can be lost. If we were to reassign a to something else, we’d never be able to get the original Object back!也就是说，在上面的语句中，我们将声明、实例化和命名同时进行了，那么我们就会存储这么一个对象a，存了balabala这么一些东西。不过，有趣的是，即使我们存好之后，这个实例化的对象还是有可能会丢失的，假如我们重新new了一个新的对象令它&#x3D;a，那么我们之前创建的这balabala的变量就会被Java的收集器所消耗掉，也就是消失了。![[..&#x2F;..&#x2F;Pasted image 20240124114823.png]] Video 7:Introducing IntLists在了解完这一切之后，我们准备创建一个列表，因此，列表和数组之间的区别在于，列表可以任意增长，这与具有固定大小的数组不同。所以我们将完全从头开始构建它。 IntList Let’s define an IntList as an object containing two member variables: int first; IntList rest; And define two version of the same method: size() iterativeSize()列表将有两个变量，一个是名为first的整数，另一个是另一个int列表的指针或地址。为了简单起见，我们的列表仅仅只用来存储整数。 详情创建及过程视频见00:43 123456789public class IntList &#123; public int first; public IntList rest; public static void main(String args[]) &#123; &#125;&#125; 事实上在这个时候我们就已经创建好一个列表了。接下来我们添加东西 1234567891011121314151617public class IntList &#123; public int first; public IntList rest; public static void main(String args[]) &#123; IntList L = new IntList(); L.first = 5; L.rest = null; L.rest = new IntList(); L.rest.first = 10; L.rest.rest = new IntList(); L.rest.rest.first = 15; &#125;&#125; 通过Java Visualizer来理解过程![[..&#x2F;..&#x2F;Pasted image 20240124122549.png]]这样的代码看起来似乎略有尴尬，那么我们选择往前退一步来看。我们首先先创建一个构造函数 1234public IntList(int f, IntList r) &#123; first = f; rest = r; &#125; 然后我们将以相反的方式建立list 12345678910111213141516public class IntList &#123; public int first; public IntList rest; public IntList(int f, IntList r) &#123; first = f; rest = r; &#125; public static void main(String args[]) &#123; IntList L = new IntList(15, null); L = new IntList(10, L); L = new IntList(5, L); &#125;&#125; ![[..&#x2F;..&#x2F;Pasted image 20240124123309.png]]在这个时候，因为13的L还未执行完成，那么此时的L就是在12行创建出来的L不过这看起来似乎还是略有尴尬… Video 8:IntList size这个时候我们会发先如果我们想要访问这个列表的大小啊，获取第i个元素啊非常麻烦。这个时候，我们就需要对这个列表添加一个size方法和一个迭代size的方法，其行为就类似于Python中的length函数这个函数需要用递归的方法来实现，当我们每次访问它的时候，它会去问它剩下的rest里面还有多少个节点… 12345public int size() &#123; if(rest == null) return 1; return 1 + this.rest.size();&#125; 可以通过Visualizer来阅读每一步的操作![[..&#x2F;..&#x2F;Pasted image 20240124140057.png]] Video 9:IntList iterativeSize在上述方法的基础上，我们还可以考虑用迭代的方法来解决这个问题 1234567891011// Return the size of the list using no recursion! public int interativeSize() &#123; int p = this; int totalSize = 0; while(p != null) &#123; totalSize += 1; p = p.rest; &#125; return totalSize; &#125; Video 10:More IntList ExerciseChallenge Write a method int get(int i) that returns the ith item in the list. For simplicity, OK to assume the item exists. Front item is the 0th item. Ways to work: Paper(best) Laptop(see lecture) Head…先决条件12345678910111213141516171819202122public class IntList &#123; public int first; public IntList rest; public IntList(int f, IntList r) &#123; first = f; rest = r; &#125;// Return the size of this IntList public int size() &#123; if (rest == null) return 1; &#125; return 1 + this.rest.size();&#125;public static void main(String args[]) &#123; IntList L = new IntLise(15, null); L = new IntList(10, L); L = new IntList(5, L); System.out.println(L.get(0));&#125; 输出应该是5 实现函数想法如下: 12345678910public int get(int i) &#123; int a = 0; IntList p = this; while( a != i) &#123; a ++; p = p.rest; &#125; return p.first; &#125; 用迭代方式实现 12345public int get(int i) &#123; if(i == 0) return first; return rest.size(i - 1);&#125; 用递归的方式实现。","categories":[{"name":"CS61B","slug":"CS61B","permalink":"https://primeluoqiu.github.io/categories/CS61B/"}],"tags":[],"keywords":[{"name":"CS61B","slug":"CS61B","permalink":"https://primeluoqiu.github.io/categories/CS61B/"}]},{"title":"Hello World","slug":"计算机网络/Lecture2-Defining and Using Classes 类的定义和实例化","date":"2024-03-20T14:21:05.833Z","updated":"2024-03-20T14:24:19.350Z","comments":true,"path":"2024/03/20/计算机网络/Lecture2-Defining and Using Classes 类的定义和实例化/","link":"","permalink":"https://primeluoqiu.github.io/2024/03/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Lecture2-Defining%20and%20Using%20Classes%20%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E5%AE%9E%E4%BE%8B%E5%8C%96/","excerpt":"","text":"Class 2Video a:Defining and Instantiating Classes. 想要实际运行一个类，那么我们必须有main方法 假设我们目前创建了一个名为”Dog”的新类，并先暂时取消掉它的main方法。相反，我们给它一个方法，让它发出噪音。 12345public class Dog&#123; public static void makeNoise() &#123; System.out.println(&quot;Bark!&quot;); &#125;&#125; 那么，这个类就是可以编译的，那么当要运行这个程序的时候，就会报错![[Pasted image 20240106163816.png]]也就意味着这只狗不知道应该如何跑(run)对于Python来讲就是 12def makeNoise: print(&quot;Bark!&quot;) 没有任何调用makeNoise的地方于是我们放回main函数 12345678public class Dog&#123; public static void makeNoises() &#123; System.out.println(&quot;Bark!&quot;); &#125; public static void main(String args[]) &#123; makeNoises(); &#125;&#125; 于是，在我们重新编译运行之后我们看到![[Pasted image 20240106164240.png]]通常情况下，我们用Java创建的类没有main方法，就像狗这个类中一开始并没有main方法，相反，我们经常会有其他的类来使用Dog，因此我们创建一个DogLauncher.java 1234567/**The DogLauncher class will &#x27;test drive&#x27; the Dog class ,所以这只是为了展示这个‘狗’是如何工作的**/ //因此在这种情况下，DogLaunch应该有main方法 public class DogLaunch &#123; public static void main(String args[]) &#123; //在这里调用我们的狗类的制造噪音的方法 Dog.makeNoises();//这里的意思就是，告诉Java，我想让你去找狗这个类，然后找到它的对应的制造噪音的方法。 &#125; &#125; ![[Pasted image 20240106165927.png]]编译运行之后就是这个结果了 那么DogLaunch到底是做了什么呢？当它开始运行的时候，它会进入Dog类，然后采用makeNoise这个函数。那么这就是定义类的核心 DogAs we saw last time: Every method(a.k.a Function)is associated with some class. To run a class, we must define a main method. Not all classes have a main method.这里有一个main方法可以调用到其他类中的方法。一个类可以使用另一个类，这是我们能够将问题分解为更小的部分的全部基础。当然，很显然的是，在现实生活中，并不是所有的狗都是相同的。也就意味着，我们并不希望它们都发出相同的叫声，那么我们应该如何才能实现这个目标呢？ 有一个不那么好的方式是：(对于每只狗都创建一个新的类)We could create a separate class for every single dog out there, but this is going to get redundant in a hurry. 1234567891011public class MayaTheDog &#123; public static void makeNoise() &#123; System.out.println(&quot;arooooooooooooooo!&quot;); &#125;&#125;public class YapsterTheDog&#123; public static void makeNoise() &#123; System.out.println(&quot;awawwaawaw wawawawa&quot;); &#125;&#125; 虽然可以这么做，不过在品类多样之后，这显然变得很烦 Video b:Defining and Instantianing Classes那么，我们将使用的关键语言功能是，Java中的类不仅可以包含函数，当然还可以包含数据，以便更自然的表示狗或者其他的任何东西。那么我们就可以通过增强Dog类，以便让Dog拥有属性，例如大小。而这个Class将会成为其他dog的模板，然后我们可以将这个实例化为我们可以操作的特定对象 Object InstantiationClasses can contain not just functions(a.k.a methods), but also data. Classes can be instantiated as objects. We’ll create a single Dog class, and then create instances of this Dog. The classes provides a blueprint that all Dog objects will follow.重写dog class例子如下123456789101112131415public class Dog&#123; //狗不只是只有制造噪音，还有一些属性将是狗所拥有的，例如重量 public int weightInPounds; //然后更改下面的函数 public static void makeNoises() &#123; if(weightInPounds &lt; 10) &#123; System.out.println(&quot;yip!&quot;); &#125; else if (weightInPounds &lt; 30) &#123; System.out.println(&quot;bark!&quot;); &#125; else &#123; System.out.println(&quot;wooooof!&quot;); &#125; &#125; &#125; 当我们在编译这个程序的时候，会发现报这样的错误![[Pasted image 20240106192022.png]]对于我们来说，最快的解决方式就是删掉方法当中的static即可，现在再尝试编译的话就可以通过了。123456789101112131415public class Dog&#123; //狗不只是只有制造噪音，还有一些属性将是狗所拥有的，例如重量 public int weightInPounds; //然后更改下面的函数 public void makeNoises() &#123; if(weightInPounds &lt; 10) &#123; System.out.println(&quot;yip!&quot;); &#125; else if (weightInPounds &lt; 30) &#123; System.out.println(&quot;bark!&quot;); &#125; else &#123; System.out.println(&quot;wooooof!&quot;); &#125; &#125; &#125; 以上就是对Dog的一个模板，它可以根据狗的体重（磅数）有不同的行为。这个时候我们再DogLaunch编译一下，我们会发现![[Pasted image 20240106192733.png]]或许你也会想像上面的报错一样只删掉DogLaunch中的static，但是显然这是错误的，这个时候我们就要用到一个新语法。1Dog d = new Dog(); 这意味着创建一个狗，一只新狗，在这种情况下，我们称那只狗为d，那么接下来的语法将会是这样的123456789/**The DogLauncher class will &#x27;test drive&#x27; the Dog class ,所以这只是为了展示这个‘狗’是如何工作的**/ //因此在这种情况下，DogLaunch应该有main方法 public class DogLaunch &#123; public static void main(String args[]) &#123; //在这里调用我们的狗类的制造噪音的方法 Dog d = new Dog(); d.weightInPounds = 25; d.makeNoises(); &#125;&#125; 就是相当于，在这里我们来问d，让他发出声音，这个时候它去找makeNoise这个方法，然后这里只有三种声音，然后就会有这样的执行结果![[Pasted image 20240106194134.png]]如果我们将25换成51的话并重新编译的话，我们就会得到woof还有最后一点调整可能会有另外的一种想法，例如为什么不在构造这个d的时候直接在后面的()当中赋值呢？就是给定它作为Dog创建过程的参数。为了实现这个呢（当然，直接这么做是不可以的）![[Pasted image 20240106194511.png]]也就是意味着它并不知道应该如何处理这个数字。因此，为了处理这个问题，我们需要在Dog这个类中创建一个特殊的东西，它有点像方法，被称为构造函数1234// One integer constructor for dogs. public Dog(int w) &#123; &#125; 因此，当调用new Dog并给出一个整数的时候，就会调用这个构造函数，这将指定Dog是如何创建的 接下来，我们对这个构造函数里的WeightPounds设置为w 1234// One integer constructor for dogs. public Dog(int w) &#123; weightPounds = w;&#125; 接下来再编译运行的话，就可以直接得到Wooof了![[Pasted image 20240106195124.png]] Video c:Terminology在进行下一步之前，我们首先要搞清楚Java的一些相关术语 123456789101112131415public class Dog&#123; public int weightInPounds; public Dog(int startingWeight) &#123; weightPounds = startingWeight; &#125; public void makeNoise() &#123; if(weightInPounds &lt; 10) &#123; System.out.println(&quot;yipyipyip&quot;); &#125; else if (weightInPounds &lt; 30) &#123; System.out.println(&quot;bark, bark.&quot;); &#125; else &#123; System.out.println(&quot;woof&quot;)&#125; &#125;&#125; 这是一个例子，我们从中来剖析一些术语。 1public int weightInPounds; Instance variable. Can have as many of these as you want.一个实例变量，是一个跟踪当前类的特定实例的属性的变量，我们在这里定义了一个狗的体重，但是原则上我们还可以有它的身高，喜欢的食物，喜欢的颜色等等 123public Dog(int startingWeight) &#123; weightPounds = startingWeight;&#125; Constructor(similar to a method, but not a method). Determines how to instantiate the class.这里是构造函数：我们目前只有一个参数来设置单个实例变量，不过在原则上，可以在构造函数中执行任何操作，但通常最重要的事情之一是设置所有实例变量，不过也不必设置所有的实例变量，可以让他们保持默认值。构造函数告诉我们如何构造对象的实例。 123456789public void makeNoise() &#123; if(weightInPounds &lt; 10) &#123; System.out.println(&quot;yipyipyip&quot;); &#125; else if (weightInPounds &lt; 30) &#123; System.out.println(&quot;bark, bark.&quot;); &#125; else &#123; System.out.println(&quot;woof&quot;)&#125; &#125;&#125; Non-static method, a.k.a Instance Method.Idea: If the method is going to be invoked by an instance of the class(as in the next slide), then it should be non-static. Roughly speaking: If the method needs to use “my instance variables”, the method must be non-static. 非静态方法（实例方法）：也就是由特定实例调用的方法。例如我们有一个叫做Steven的狗 ，它在Steve变量中，那么当我们告诉Steve，Steve.MakeNoise的时候，它就会使用它的体重来决定它要做什么（怎么叫）。当我们阅读方法的时候，可以说，如果我们的体重小于10，那么yipyipyip，这意味着他是一个非静态的方法，事实上，如果这个方法需要使用任何实例变量，那么在定义的时候加入static关键字就会令Java感到困惑，会提示我们不能从静态上下文访问实例变量。 再来点术语 Instantiating a Class and Terminology12345678910public class DogLauncher &#123; public static void main (String[] args) &#123; Dog smallDog; new Dog(20); smallDog = new Dog(5); Dog hugeDog = new Dog(150); smallDog.makeNoise(); hugeDog.makeNoise(); &#125;&#125; 我们最开始的DogLauncher实现的功能很简单，只是让它发出了一下声音。但是我们可能会遇到更复杂的情况（如上） 1Dog smallDog; Declaration of a Dog variable.声明了一个Dog型的变量，有一个Dog变量叫做smallDog，不过我们目前还没创造出任何种类的狗，也就是没有实例化。 1new Dog(20); Instantiation of the Dog class as a Dog Object.这会创建一条尺寸为20的Dog，但是不会将它放置在任何地方，在这种情况下，因为没有人使用它，它只会被所谓的垃圾收集器给销毁掉。、意味着，如果实例化Dog，他们将被某种无情的垃圾收集器销毁 1smallDog = new Dog(5); Instantiation and Assignment.现在呢，如果想要避免失去这条狗，我们会想把它放在某个地方，所以上述代码实例化了一只狗，然后将其分配给一个已经声明的变量。那么这就是实例化和赋值。尽管通常情况下，我们要做的就是同时完成这三项工作。 1Dog hugeDog = new Dog(150); Declaration, Instantiation and Assignment.声明有一个名为HugeDog的变量，我们实例化它，然后将new Dog分配给这个变量 1hugeDog.makeNoise(); Invocation of the 150lb Dog’s makeNoise method.The dot notation means that we want to use a method or variable belonging to hugeDog,or more succinctly, a member of hugeDog.在这里有一些调用，在这里，我们想要HugeDog调用makeNoise方法。可以将这个.视为其成员的意思，所以它属于hugeDog这类。 Video d:Arrays of ObjectsTo create an array of objects: First use the new keyword to create the array. Then use new again for each object that you want to put in the array.Example:1234Dog[] dogs = new Dog[2]; //Create an array of Dogs of size 2.dogs[0] = new Dog(8);dogs[1] = new Dog(20);dogs[0].makeNoise(); //Yipping occurs After code runs![[Pasted image 20240107170741.png]]在项目0中，不仅要创建对象，还要创建对象数组。那么，如果想要创建一个对象数组而不是整数数组，那么就要以两种不同的方式使用new，首先要使用new来创建一个实际的数组。此时还没有创建任何Dog，可以把这个操作想象成建造了目前空着的狗屋，然后后面才会说，在狗屋0中放一只小狗，在狗屋1中放一只中型狗。这样在最后就可以看见两个狗屋辣。 然后我们可以问，嘿，狗屋0里的那个，发出声音，然后它就会YipYipYip Class 3Video a:Static vs Instance Methods我们现在知道什么Key differences between static and non-static (a.k.a instance) methods: Static methods are invoke using the class name, e.g. Dog.makeNoise(); Instance methods are invoked using an instance name, e.g. maya.makeNoise(); Static methods can’t access “my” instance variables, because there is no “me”.Static123public static void makeNoise() &#123; System.out.println(&quot;Bark!&quot;);&#125; This method cannot access weightlnPound.Invocation:Dog.makeNoise();目前我们知道存在静态方法（在声明中包含静态一词）和非静态方法（也被称为实例方法），他们没有静态方法。因此静态方法是使用类名调用的。所以当我们想要调用的时候，就要选择上述的方式Non-static123456789public void makeNoise() &#123; if(weightInPounds &lt; 10) &#123; System.out.println(&quot;yipyipyip&quot;); &#125; else if (weightInPounds &lt; 30) &#123; System.out.println(&quot;bark, bark.&quot;); &#125; else &#123; System.out.println(&quot;woof&quot;); &#125;&#125; Invocation:maya = newDog(100); maya.makeNoise();而这种即时方法，是使用实例名称调用的。所以创建了一个特定的Dog并说发出声音 他们之间的重要区别是 静态方法不能访问实例变量，就是对于静态而言，不能用System.out.println(&quot;makeNoise()&quot;);这样，传入不了实际的变量。而对于非静态方法的话，就是创建出来了一个新的狗并赋予了实际变量，然后就可以通过调用函数输出特定的声音。 虽然非静态方法非常的强势，但是静态方法也有它的用武之地，例如某些类从来没有被实例化，例如数学类，我们通常会这么做： 1x = Math.round(5.6); 这明显要比 12Math m = new Math();x = m.round(); 看来要好很多也就是说，静态方法自然有他们用起来更自然的地方。 现在，有时类实际上也可以混合使用，可以拥有一个即是静态方法又是非静态方法的类看实例假设我们现在要对Dog实现一个方法能够比较两只狗。所以这个时候需要制作另一只狗，需要在DogLauncher中 1Dog d2 = new Dog(100); 然后例如我们要实现比大小，例如比较 1Dog bigger = Dog.maxDog(d, d2); 这个时候我们想要用一个比较公平的裁判来解决这个问题。那么，我们在Dog中解决这个方法 12345public static Dog maxDog(Dog d1, Dog d2)&#123; //不要忘记加返回类型和静态哦（因为是用类名调用该方法 if(d1.weightInPounds &gt; d2.weightInPounds) return d1; return d2; &#125; 试验一下![[Pasted image 20240110091345.png]]显然这并没有输出，那么需要加上一句让大狗发出声音的语句 1bigger.makeNoise(); ![[Pasted image 20240110091642.png]] 那么可以用非静态方法解决这个问题吗？当然是可以的 123456789public class DogLaunch &#123; public static void main(String args[]) &#123; Dog d = new Dog(15); Dog d2 = new Dog(100); Dog bigger = d.maxDog(d2); bigger.makeNoise(); &#125;&#125; 12345678910111213141516171819202122232425262728public class Dog&#123; public int weightInPounds; public Dog(int w) &#123; weightInPounds = w; &#125; public void makeNoise() &#123; if(weightInPounds &lt; 10) &#123; System.out.println(&quot;yip!&quot;); &#125; else if (weightInPounds &lt; 30) &#123; System.out.println(&quot;bark!&quot;); &#125; else &#123; System.out.println(&quot;wooooof!&quot;); &#125; &#125; public static Dog maxDog(Dog d1, Dog d2)&#123; if(d1.weightInPounds &gt; d2.weightInPounds) return d1; return d2; &#125; public Dog maxDog(Dog d2) &#123; if(weightInPounds &gt; d2.weightInPounds) return this; return d2; &#125;&#125; ![[Pasted image 20240110092342.png]]编译之后依旧得到woooof！在这种情况下，这只狗会自己进行判断自己的体重和另一只狗的体重哪个重。上述是两种方法，一种是加入评委，一种是自己判断大小 作为一个快速说明，我们也可以定义静态变量。他们是适用于所有狗的属性，所有狗共享这个属性，例如我们给这些狗添加一个种类 1public static String binomen = &quot;Canis familiar&quot;; 12System.out.println(d.binomen);System.out.println(d2.binomen); ![[Pasted image 20240110093004.png]]但是对于上述的d1和d2并不是一种很有效的方式。例如我并不会问嘿那条狗，你的学名是什么，而应该是问，这些狗的学名是什么。上述方式相对来说会令人比较困惑。所以，如果我们有一个静态变量的话，那么就使用类名作为一种好一些方式来确保我们知道我们正在处理什么。 1System.out.println(Dog.binomen); Some knowledgepoint Static vs. Non-staticA class may have a mix of static and non-static members. A variable or method defined in a class is also called a member of that class. Static members are accessed using class name, e.g. Dog.binomen. Non-static members cannot be invoked using class name:Dog.makeNoise() Static method must access instance variables via a specfic instance e.g. d1. Video b:ExerciseQuestion:Will this program compile? If so, what will it print? 123456789101112131415161718public class DogLoop &#123; public static void main(String args[]) &#123; Dog smallDog = new Dog(5); Dog mediumDog = new Dog(25); Dog hugeDog = new Dog(150); Dog[] manyDogs = new Dog[4]; manyDogs[0] = smallDog; manyDogs[1] = hugeDog; manyDogs[2] = new Dog(130); int i = 0; while(i &lt; manyDogs.length) &#123; Dog.maxDog(manyDogs[i], mediumDog).makeNoise(); i = i + 1; &#125; &#125;&#125; Video c:Exercise Solution在这个网站当中可以将每一步可视化，建议点入之后操作[http://goo.gl/HLzN6s]，认真查看问题所在和结果， 答案是 12345bark!woof!woof!Error:... Class 4Video a:Managing Complexity, LargerThanFourNeighborsManaging Complexity with Classes and Static MethodsSome obvious questions arise: Why does Java force us to use classes? Why have static methods at all? The Reason: Fewer choices means fewer ways to do things. Example：Declaring a method static means you can’t use any instance variables in that method. Fewer ways to do things often means less complexity 更少的选择意味着做事的方法更少，如果将一个方法设置为静态，就会对可能得情况施加限制。例如不能使用实例变量。从根本来说，就是降低代码的复杂性 Goal: largerThanFourNeighbors Suppose we want to write a method: 1public static Dog[] largerThanFourNeighbors(Dog[] dogs) This method will return a new array that contains every Dog that is larger than its 4 closest neighbors, i.e. the two on the left and the two in the right.If there are not enough neighbors, i.e. you ‘re at the end of the array, then consider just the neighbrs that exist.For example: input:Dog with size [ 10, 20, 30, 25, 20, 40, 10 ] Returns: Dog with size[ 30, 40]. 30 is the larger than 10,20,25 and 20. 40 is greater than 25, 20, and 10 If input Dog sizes are[10, 15, 20, 15, 10, 5, 10, 15, 22, 20],what will be the size of the Dogs returned？ It Will be [20, 22] Video b:LargerThanFourNeighbors With No Helper Methods在不考虑策略的情况下暂时完成code:打开Intellij 123456789101112131415161718192021222324252627public class DogProblem &#123; public staitc Dog[] largerThanFourNeighbors(Dog[] dogs) &#123; return dogs; &#125; public static void main(String args[]) &#123; Dog[] dogs = new Dog[] &#123; new Dog(10), new Dog(15), new Dog(20), new Dog(15), new Dog(10), new Dog(5), new Dog(10), new Dog(15), new Dog(22), new Dog(15), new Dog(20) &#125;; Dog[] bigDogs1 = largerThanFourNeighbors(dogs); for(int k = 0; k &lt; bigDogs1.length; k ++)&#123; System.out.print(bigDogs1[k].weightInPounds + &quot; &quot;); &#125; System.out.println();; &#125;&#125; 先键入这些基础的输入输出语句，我们的函数目前只能返回dogs。所以首先我们看向我们的larger函数，那么我们首先要做的只能是迭代所有的狗，这看起来很自然，不过棘手的问题是如何迭代邻居们。一个想法是：如果我们从-2到2，那么这应该是迭代狗的邻居。 12345for(int i = 0; i &lt; dogs.length; i ++)&#123; for(int j = -2; j &lt;= 2;j ++)&#123; Dog neighborDog = dogs[i + j] &#125;;&#125; 接下来就要处理边界的一些问题，例如我们如果从0开始的话，那么i + j最开始是-2，很明显是数组越界的行为，还有如果j到了数组的最右边，同样也会存在数组越界的问题。 1234567891011121314public staitc Dog[] largerThanFourNeighbors(Dog[] dogs) &#123; for(int i = 0; i &lt; dogs.length; i ++)&#123; for(int j = -2; j &lt;= 2;j ++)&#123; if(i + j &lt; 0) &#123; continue; &#125; if(i + j &gt;= dogs.length) &#123; break; &#125; Dog neighborDog = dogs[i + j]; &#125;; &#125;&#125; 那么有了这只邻居狗之后，我们应该如何做呢？定义一个布尔值，默认是正确的，来定义默认情况下我们本身就是最大的狗，但如果邻居狗的体重大于或者等于当前狗的体重，那么最大就是假的，那么有一个重要的事实是，在边界问题上，如果j&#x3D;0，那么就会将自己和自己进行比较，那么显然是没必要的，那么代码如下 123456789101112131415161718192021public staitc Dog[] largerThanFourNeighbors(Dog[] dogs) &#123; for(int i = 0; i &lt; dogs.length; i ++)&#123; boolean largest = true; for(int j = -2; j &lt;= 2;j ++)&#123; if(i + j &lt; 0) &#123; continue; &#125; if(i + j &gt;= dogs.length) &#123; break; &#125; if(j == 0) &#123; continue; &#125; Dog neighborDog = dogs[i + j]; if(neighborDog.weightInPounds &gt;= dogs[i].weightInPounds) &#123; largest = false; &#125; &#125;; &#125;&#125; 这只是考虑，但是发现有一些复杂 Video c:LargeThanFourNeighbors With Helper MethodsOpen Intellij接下来我们使用一些辅助方法来编写代码，辅助方法的好处是让我们在编辑他们之前先使用他们。那么最初的框架就是 1234567891011public static Dog[] largerThanFourNeighbors(Dog[] dogs) &#123; for(int i = 0; i &lt; dogs.length; i ++)&#123; if(isBiggestOfFour(dogs, i)) &#123; &#125; &#125;&#125;//先拆出来一个问题：是不是邻居四个当中的一个/* Return true if dogs[i] is larger than its four neighbors */public static boolean isBiggestFour(Dog[] dogs, int i) &#123;&#125; 拆出问题之后，我们来继续完成主函数因为主函数最后返回的值是一个Dog类型的数组，那么，我们就要定义一个返回数组和要返回的数组的大小 12345public static Dog[] largerThanFourNeighbors(Dog[] dogs) &#123; Dog[] returnDogs = new Dog[dogs.length]; int cnt = 0; ...//内容同上&#125; 然后我们对如果这个狗是它的四个邻居当中最大的，那么我们将答案传递给我们最后要返回的那个Dog组，然后完成主函数return returnDogs; 1234567891011public static Dog[] largerThanFourNeighbors(Dog[] dogs) &#123; Dog[] returnDogs = new Dog[dogs.length]; int cnt = 0; for(int i = 0; i &lt; dogs.length; i ++)&#123; if(isBiggestOfFour(dogs, i)) &#123; returnDogs[cnt] = dogs[i]; cnt ++; //这样有利于我们进行统计 &#125; &#125; return returnDogs;&#125; 这段代码正确的叙述了读取它，得到返回值。我们通过i小于等于数组的长度来遍历这一整个大的数组。如果是四个当中最大的，那么我们将它添加到这个新的数组当中并返回它。我们现在回到第二个函数，因为对于主函数我们已经不用考虑它了，接下来我们只需要考虑给出是或否的答案就可以了。 123456boolean isBiggest = true; for(int j = -2; j &lt;= 2;j ++) &#123; &#125; &#125; 我们依旧默认最大值为真。在前面的实例中，我们使用了一堆if语句，当然，在这里，我们还是可以选择用辅助方法来解决这个问题 1234567public static boolean validIndex(Dog[] dogs, int i) &#123; if(i &lt; 0) return false; if(i &gt;= dogs.length) return false; return true; &#125; 在我们实现完这个函数之后，我们回头看调用它的那个方法，对于方法来讲，我们只需要完成比较的那一部分即可 1234567891011121314public static boolean isBiggestOfFour(Dog[] dogs,int i) &#123; boolean isBiggest = true; for(int j = -2; j &lt;= 2;j ++) &#123; int comparedIndex = i + j; if(validIndex(dogs, comparedIndex)) &#123; if(dogs[comparedIndex].weightInPounds &gt;= dogs[i].weightInPounds) &#123; isBiggest = false; &#125; &#125; &#125; return isBiggest; &#125; 但是在完成这项之后，我们发现我们似乎遗漏掉了对自己和自己进行比较的情况 1234567891011121314151617public static boolean isBiggestOfFour(Dog[] dogs,int i) &#123; boolean isBiggest = true; for(int j = -2; j &lt;= 2;j ++) &#123; int comparedIndex = i + j; //只是命名来方便叙述 if(validIndex(dogs, comparedIndex)) &#123; // avoid comparing ourself to ourself. if(j == 0) &#123; continue; &#125; if(dogs[comparedIndex].weightInPounds &gt;= dogs[i].weightInPounds) &#123; isBiggest = false; &#125; &#125; &#125; return isBiggest; &#125; 这样即可尝试找出如何让程序更加漂亮。整个程序如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package Lecture2; public class DogProblem &#123; public static Dog[] largerThanFourNeighbors(Dog[] dogs) &#123; Dog[] returnDogs = new Dog[dogs.length]; int cnt = 0; for(int i = 0;i &lt; dogs.length;i ++) &#123; if(isBiggestOfFour(dogs, i)) &#123; returnDogs[cnt] = dogs[i]; cnt ++; &#125; &#125; return returnDogs; &#125; /* Return true if dogs[i] is larger than its four neighbors */ public static boolean isBiggestOfFour(Dog[] dogs,int i) &#123; boolean isBiggest = true; for(int j = -2; j &lt;= 2;j ++) &#123; int comparedIndex = i + j; //只是命名来方便叙述 if(validIndex(dogs, comparedIndex)) &#123; // avoid comparing ourself to ourself. if(j == 0) &#123; continue; &#125; if(dogs[comparedIndex].weightInPounds &gt;= dogs[i].weightInPounds) &#123; isBiggest = false; &#125; &#125; &#125; return isBiggest; &#125; public static boolean validIndex(Dog[] dogs, int i) &#123; if(i &lt; 0) return false; if(i &gt;= dogs.length) return false; return true; &#125; public static void main(String args[]) &#123; Dog[] dogs = new Dog[] &#123; new Dog(10), new Dog(15), new Dog(20), new Dog(15), new Dog(10), new Dog(5), new Dog(10), new Dog(15), new Dog(22), new Dog(15), new Dog(20) &#125;; Dog[] bigDogs1 = largerThanFourNeighbors(dogs); for(int k = 0; k &lt; bigDogs1.length; k ++)&#123; System.out.print(bigDogs1[k].weightInPounds + &quot; &quot;); &#125; System.out.println(); &#125; &#125; ![[Pasted image 20240113142014.png]]我们得到了20和22，这是正确的结果，但是为什么后面还有一串错误信息呢，是因为在答案数组的最后有很多空值，其实这个并没有什么问题，只是会输出这样的信息。我们可以选择用一个方法来消除这个错误 12345678//cnt is the number of non-null items public static Dog[] arrayWithNoNulls(Dog[] dogs, int cnt) &#123; Dog[] noNullDogs = new Dog[cnt]; for(int i = 0; i &lt; cnt; i ++) &#123; noNullDogs[i] = dogs[i]; &#125; return noNullDogs; &#125; 最终代码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package Lecture2; public class DogProblem &#123; public static Dog[] largerThanFourNeighbors(Dog[] dogs) &#123; Dog[] returnDogs = new Dog[dogs.length]; int cnt = 0; for(int i = 0;i &lt; dogs.length;i ++) &#123; if(isBiggestOfFour(dogs, i)) &#123; returnDogs[cnt] = dogs[i]; cnt ++; &#125; &#125; returnDogs = arrayWithNoNulls(dogs, cnt); return returnDogs; &#125; //cnt is the number of non-null items public static Dog[] arrayWithNoNulls(Dog[] dogs, int cnt) &#123; Dog[] noNullDogs = new Dog[cnt]; for(int i = 0; i &lt; cnt; i ++) &#123; noNullDogs[i] = dogs[i]; &#125; return noNullDogs; &#125; /* Return true if dogs[i] is larger than its four neighbors */ public static boolean isBiggestOfFour(Dog[] dogs,int i) &#123; boolean isBiggest = true; for(int j = -2; j &lt;= 2;j ++) &#123; int comparedIndex = i + j; //只是命名来方便叙述 if(validIndex(dogs, comparedIndex)) &#123; // avoid comparing ourself to ourself. if(j == 0) &#123; continue; &#125; if(dogs[comparedIndex].weightInPounds &gt;= dogs[i].weightInPounds) &#123; isBiggest = false; &#125; &#125; &#125; return isBiggest; &#125; public static boolean validIndex(Dog[] dogs, int i) &#123; if(i &lt; 0) return false; if(i &gt;= dogs.length) return false; return true; &#125; public static void main(String args[]) &#123; Dog[] dogs = new Dog[] &#123; new Dog(10), new Dog(15), new Dog(20), new Dog(15), new Dog(10), new Dog(5), new Dog(10), new Dog(15), new Dog(22), new Dog(15), new Dog(20) &#125;; Dog[] bigDogs1 = largerThanFourNeighbors(dogs); for(int k = 0; k &lt; bigDogs1.length; k ++)&#123; System.out.print(bigDogs1[k].weightInPounds + &quot; &quot;); &#125; System.out.println(); &#125; &#125; ![[Pasted image 20240113143928.png]]这段代码包含很多东西首先叙述性更好其次编写时更容易正确执行再次如果遇到到麻烦，则更容易调试 用好辅助方法，会事半功倍","categories":[{"name":"CS61B","slug":"CS61B","permalink":"https://primeluoqiu.github.io/categories/CS61B/"}],"tags":[],"keywords":[{"name":"CS61B","slug":"CS61B","permalink":"https://primeluoqiu.github.io/categories/CS61B/"}]},{"title":"Hello World","slug":"计算机网络/Lecture1-Introduction","date":"2024-03-20T14:21:05.826Z","updated":"2024-03-20T14:24:17.895Z","comments":true,"path":"2024/03/20/计算机网络/Lecture1-Introduction/","link":"","permalink":"https://primeluoqiu.github.io/2024/03/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Lecture1-Introduction/","excerpt":"","text":"多做事来获得能力是很重要的 Class 1:Hello World 课程链接：[[https://www.youtube.com/watch?v=E3noTK6T8AE&amp;list=PLnp31xXvnfRq5wRDN8wZFy7GrrJXUtr1q&amp;index=4]] Java 和Python的对比Java 是一种认为类非常重要的语言，事实上呢，所有的代码都必须在类中。它是一种迫使我们面向对象的语言，那么因此定义这个类的话。我们首先要做的是定义一个公共类Hello World.可以认为public class就像另一种语言中的类定义一样 123public class HelloWorld&#123;&#125; 这个时候，我们会发现报错是在类HelloWorld中找不到main方法，即报错信息中会显示the main method as: public static void main(String[] args)，然后我们复制这段代码之后 12345public class HelloWorld&#123; public static void main(String[] args) &#123; &#125;&#125; 我们会发现这段代码可以工作了那么从中我们可以总结出来有关Java这个语言什么样子的特性呢？ In java, all code must be part a class Classes are defined with “public class CLASSNAME” We use { } to delineate the begining and ending of things. We must end lines with a semicolon. The code we want to run must be inside public static void main(String[] args). Class 2:Static Typing 课程链接：[[https://www.youtube.com/watch?v=xX04gYy9en0&amp;list=PLnp31xXvnfRq5wRDN8wZFy7GrrJXUtr1q&amp;index=5]] 一个例题：在Python中和Java中输出从0-9这十个数。Python只是为了用来对比 1234x = 0while x &lt; 10 print(x) x ++ Java： 123456789public class HelloNumbers&#123; public static void main(String[] args) &#123; x = 0; while(x &lt; 10)&#123; System.out.println(x);//ln指line x = x + 1; &#125;; &#125;&#125; 在看了Python的语言之后，你似乎也想在Java中如是这么写，但是很显然，这个在Java的编译中是错误的。(Error:cannot find symbol x),实际上，编译器只是想要提醒我们需要声明变量，也就意味着，在使用这个变量之前，要先声明它存在。所以，正确的应该是 123456789public class HelloNumbers&#123; public static void main(String[] args) &#123; int x = 0; while(x &lt; 10)&#123; System.out.println(x);//ln指line x = x + 1; &#125;; &#125;&#125; 对于Java和Python在变量的方面存在一些很大的差异，使用Python这种非所谓静态类型语言的语言，可以随机创建变量。而在Java中，变量有特定的类型，这些类型永远不会改变。Java会在运行这个程序之前先检验一遍变量的类型是不是正确。接下来是一段总结 Before Java variables can be used, they must be declared. Java variables must have a specific type. Java variables types can never change. 对于现在来讲，类型的错误不仅仅只会存在于Java中，在Python中，如果我们进行这样的语句的时候 1print(&quot;horse&quot; + 5) 我们就会看到出现错误，而且是建立在之前程序都进行输出了的情况下，指在本节最开始的地方添加了这么一句话，那么久就会发现程序是先输出了0123456789之后才输出了报错信息。但是对于Java来说，当我们尝试运行存在类型错误的代码时，我们在此之前并不会得到任何输出，而是给予了我们一大堆的错误信息，由此我们可以得到Java的第四条特性4. Types are varified before the code even runs !!!在这里，这段代码基本上在运行之前就获得了类型正确的证书，这意味着(静态类型的三个优点) 最终用户遇到的错误会更少 使我们更容易调试 当我们使用代码的时候，我们应该知道一切应该是什么，例如x应该始终是整数 Class 3: Declaring Functions接下来是有关定义函数的内容 还是先以一个Python程序来作为示例 12345def large(x, y): if(x &gt; y): return x return yprint(large(-5, 10)) 我们最终可以得到10，那么Java版本长什么样子呢？(我们给这个Java文件命名为LargeDemo) 12345678//如果我们想要定义一个函数，我们不能把它放到这里public class LargeDemo&#123;//所以实际上应该在这里进行函数定义 public static void main(String[] args) &#123; &#125;&#125; 我们要记住，在Java中，所有代码都必须是类的一部分，而在Java中使用特殊短语public static而不是def。那么这个函数目前看起来应该这么写 12345678910public class LargeDemo&#123; public static large(x, y)&#123; if(x &gt; y) return x; return y; &#125; public static void main(String[] args) &#123; &#125;&#125; 现在，如果尝试对其进行编译，它会给我们提醒说需要告诉他x是什么，y是什么，而且还要说返回的值是一个什么类型的值。接下来的函数应该是长这个样子的。最后，我们想要在主函数当中调用这个函数的话，就应该用 12345678910public class LargeDemo&#123;public static int large(x, y) &#123; if(x &gt; y) return x; return y;&#125; public static void main(String[] args) &#123; System.out.println(large(-5, 10)); &#125;&#125; 在这里有一些注意事项 Functions must be declared as a part of a class in Java.A function that is part of a class is called method.So, in Java, all functions are methods To define a function in Java, we use “public static”.We will see alternate ways of defining functions Later. All parameters of a function must have a declared type, and the return value of the function must have a declared type.那么因此，我们在定义函数的时候就不可以定义有两种返回值的函数，类似int String ...有一个重点是，我们完全可以不对函数的名字或者类的名字起名起的如此繁琐，我们完全可以用一个符号来代替一堆繁琐的字符，类似f(x, y)这样，但是我们最后选择以相对来说比较繁琐的方式来命名这个函数的原因是 使我们的代码看起来更加可读 还有一个建议是在编写函数的时候，我们可以选择在它的头顶添加一些字符让他看起来更加的可读，例如 12/*Returns the large of x and y.*/public static int large(x, y) &#123; 最后其实会发现，可读性方便的还是自己。 Class4.Reflection1.Java and Object OrientationJava is an object oriented language with strict declarations: Every Java file must contain a class declaration.* All code lives inside a class*, even helper functions,global constants, etc. To run a Java program, you typically define a main method using public static void main(String[] args) * This is not completely true, e.g. we can also declare “interface” in Java files that may contain code.We’ll cover these later. 2.Java and Static TypingJava is statically typed! All variables, parameters, and methods must have a declared type. That type can never change. Expressions also have a type. The compiler checks that all the types in your program are compatible before the program ever runs! This is unlike a language like Python, where type checks are performed DURING execution. 3.Reflections on Static TypingThe Good: Catches certain types of errors, making it easior on the programmer to debug their code. Type errors can(almost) never occur on the end user’s computer(Even their Android). Makes it easier to read about code. Code can run more effciently, e.g. no need to do expensive runtime type checks. The Bad: Code is more verbose. Code is less general. There is a way around this in Java.例如，还是之前的比较大小的函数，对于Python而言，我们可以对除了字符串之外的所有类型进行比大小的操作，而在Java中就必须要重新写类似于float类型的函数这样才可以进行大小的比较。","categories":[{"name":"CS61B","slug":"CS61B","permalink":"https://primeluoqiu.github.io/categories/CS61B/"}],"tags":[],"keywords":[{"name":"CS61B","slug":"CS61B","permalink":"https://primeluoqiu.github.io/categories/CS61B/"}]},{"title":"第三周计划表","slug":"每周学习计划/第三周学习安排","date":"2024-03-18T02:51:18.471Z","updated":"2024-03-24T13:34:08.487Z","comments":true,"path":"2024/03/18/每周学习计划/第三周学习安排/","link":"","permalink":"https://primeluoqiu.github.io/2024/03/18/%E6%AF%8F%E5%91%A8%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/%E7%AC%AC%E4%B8%89%E5%91%A8%E5%AD%A6%E4%B9%A0%E5%AE%89%E6%8E%92/","excerpt":"","text":"本周学习内容预计 郑铨《计算机网络》:看完1.7 CS61B: 7 - 10 CS61A: 看前两章 深入理解计算机系统 :第一章看完 CS61C：前两周内容 !!! 切记随时更新进度和笔记","categories":[{"name":"大二下","slug":"大二下","permalink":"https://primeluoqiu.github.io/categories/%E5%A4%A7%E4%BA%8C%E4%B8%8B/"}],"tags":[],"keywords":[{"name":"大二下","slug":"大二下","permalink":"https://primeluoqiu.github.io/categories/%E5%A4%A7%E4%BA%8C%E4%B8%8B/"}]}]}