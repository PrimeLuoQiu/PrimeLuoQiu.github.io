{"meta":{"title":"秋过冬漫长","subtitle":"没有比脚更长的路,走过去就好了","description":"","author":"LuoQiu","url":"https://PrimeLuoQiu.github.io"},"pages":[{"title":"abot","date":"2024-03-23T09:13:50.000Z","updated":"2024-03-23T09:13:50.763Z","comments":true,"path":"about/index.html","permalink":"https://primeluoqiu.github.io/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2024-03-23T11:22:46.000Z","updated":"2024-03-23T11:26:53.008Z","comments":true,"path":"categories/index.html","permalink":"https://primeluoqiu.github.io/categories/index.html","excerpt":"","text":"title: 大二下date: 2024-03-18 12:24:49 title: CS61Adate: 2024-03-18 12:24:50 title: CS61Bdate: 2024-03-18 12:24:58title: acwingdate: 2024-03-18 12:24:58 title: 计算机网络date: 2024-03-18 12:24:00"}],"posts":[{"title":"1.1什么是Internet","slug":"1.6","date":"2024-03-23T06:21:33.296Z","updated":"2024-03-23T06:19:34.253Z","comments":true,"path":"2024/03/23/1.6/","link":"","permalink":"https://primeluoqiu.github.io/2024/03/23/1.6/","excerpt":"","text":"","categories":[{"name":"计网","slug":"计网","permalink":"https://primeluoqiu.github.io/categories/%E8%AE%A1%E7%BD%91/"}],"tags":[],"keywords":[{"name":"计网","slug":"计网","permalink":"https://primeluoqiu.github.io/categories/%E8%AE%A1%E7%BD%91/"}]},{"title":"1.5Internet结构和ISP","slug":"1.5","date":"2024-03-23T06:21:32.774Z","updated":"2024-03-23T06:26:38.001Z","comments":true,"path":"2024/03/23/1.5/","link":"","permalink":"https://primeluoqiu.github.io/2024/03/23/1.5/","excerpt":"","text":"","categories":[{"name":"计网","slug":"计网","permalink":"https://primeluoqiu.github.io/categories/%E8%AE%A1%E7%BD%91/"}],"tags":[],"keywords":[{"name":"计网","slug":"计网","permalink":"https://primeluoqiu.github.io/categories/%E8%AE%A1%E7%BD%91/"}]},{"title":"1.4接入网和网络媒体","slug":"1.4","date":"2024-03-23T06:21:32.245Z","updated":"2024-03-23T06:25:55.314Z","comments":true,"path":"2024/03/23/1.4/","link":"","permalink":"https://primeluoqiu.github.io/2024/03/23/1.4/","excerpt":"","text":"","categories":[{"name":"计网","slug":"计网","permalink":"https://primeluoqiu.github.io/categories/%E8%AE%A1%E7%BD%91/"}],"tags":[],"keywords":[{"name":"计网","slug":"计网","permalink":"https://primeluoqiu.github.io/categories/%E8%AE%A1%E7%BD%91/"}]},{"title":"1.3网络核心","slug":"1.3","date":"2024-03-23T06:21:31.662Z","updated":"2024-03-23T06:24:18.483Z","comments":true,"path":"2024/03/23/1.3/","link":"","permalink":"https://primeluoqiu.github.io/2024/03/23/1.3/","excerpt":"","text":"","categories":[{"name":"计网","slug":"计网","permalink":"https://primeluoqiu.github.io/categories/%E8%AE%A1%E7%BD%91/"}],"tags":[],"keywords":[{"name":"计网","slug":"计网","permalink":"https://primeluoqiu.github.io/categories/%E8%AE%A1%E7%BD%91/"}]},{"title":"1.2网络边缘","slug":"1.2","date":"2024-03-23T06:21:30.368Z","updated":"2024-03-23T06:23:32.642Z","comments":true,"path":"2024/03/23/1.2/","link":"","permalink":"https://primeluoqiu.github.io/2024/03/23/1.2/","excerpt":"","text":"","categories":[{"name":"计网","slug":"计网","permalink":"https://primeluoqiu.github.io/categories/%E8%AE%A1%E7%BD%91/"}],"tags":[],"keywords":[{"name":"计网","slug":"计网","permalink":"https://primeluoqiu.github.io/categories/%E8%AE%A1%E7%BD%91/"}]},{"title":"1.1什么是Internet","slug":"1.1什么是Internet","date":"2024-03-23T06:15:09.395Z","updated":"2024-03-23T06:19:34.253Z","comments":true,"path":"2024/03/23/1.1什么是Internet/","link":"","permalink":"https://primeluoqiu.github.io/2024/03/23/1.1%E4%BB%80%E4%B9%88%E6%98%AFInternet/","excerpt":"","text":"","categories":[{"name":"计网","slug":"计网","permalink":"https://primeluoqiu.github.io/categories/%E8%AE%A1%E7%BD%91/"}],"tags":[],"keywords":[{"name":"计网","slug":"计网","permalink":"https://primeluoqiu.github.io/categories/%E8%AE%A1%E7%BD%91/"}]},{"title":"CS61A.Chapter1","slug":"第一章：使用函数构造抽象","date":"2024-03-22T16:54:16.698Z","updated":"2024-03-22T16:56:54.137Z","comments":true,"path":"2024/03/23/第一章：使用函数构造抽象/","link":"","permalink":"https://primeluoqiu.github.io/2024/03/23/%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0%E6%9E%84%E9%80%A0%E6%8A%BD%E8%B1%A1/","excerpt":"","text":"之所以计算机科学的巨大生产力能够成为可能，都是因为其建立在一套优雅而强大的基本思想之上。所有计算都始于三点：信息的表示、处理的逻辑、设计抽象来管理逻辑的复杂性，掌握这些基础知识需要我们去精确理解计算机程序的构造和解释。 1.1.4 第一个例子Python内置了一些常见编程功能，例如处理文本，显示图形以及通过互联网进行通信。下面这行Python代码 1&gt;&gt;&gt; from urlib.request import urlopen 是一个import语句，它会导入一个用于”访问互联网数据”的功能，该功能特别提供了一个名为urlopen的函数，可以访问URL上的内容 语句和表达式Python代码由表达式和语句组成，从广义上讲，计算机程序由一下指令组成 计算一些值 执行一些操作语句通常描述操作，Python解释器每执行一条语句，计算机就会执行相应的操作。另外，表达式通常用于描述计算，当Python计算一个表达式时，它会计算出该式的值。 下面的赋值语句 1shakespeare = urlopen(&#x27;https://www.composingprograms.com/shakespeare.txt&#x27;) 将名称shakespeare与=后面的表达式的值相连，这个表达式将urlopen函数应用在了一个URL身上。 函数: 函数封装了操作数据的逻辑。urlopen就是一个函数，而网址是一个数据，莎士比亚的戏剧是另一个数据。从前者到后者的准换过程可能会很复杂，但我们可以将这种复杂性隐藏在一个函数中，从而能够使用一个简单的表达式来跳过该过程。函数是本章的主题 另一个赋值语句 1&gt;&gt;&gt; words = set(shakespare.read().decode().split()) 将words与莎士比亚戏剧中出现的共33721个单词的集合相连。其命令链调用了read、decode、split，每个函数都会操作一个中间的计算实体：从URL中read(读取)数据，然后将数据decode(解码)为文本，最后将文本split(拆分)为单词放在一个set中。 对象:set就是一种对象，支持如计算交际和集合关系(membership)等计算。对象无缝整合了数据以及用于操作该数据的逻辑，并隐藏了二者的复杂性对象是第二章的主题 最后，这个表达式 {w for w in words if len(W) &#x3D;&#x3D; 6 and w[::1] in words}{‘redder’, ‘drawer’, ‘reward’, ‘diaper’, ‘repaid’} 是一个符合表达式，它的计算结果是反向拼写同时也为单词的莎士比亚单词集合。神秘符号w[::-1]表示枚举单词中的每个字母，其中-1代表反向枚举，当在交互式对话中输入表达式时，Python会在下一行打印值。 解释器：符合表达式的求解需要以一个可预测的方式来精确解释代码的过程。实现在这样的过程，用于计算复合表达式的程序就称为解释器。解释器的设计和实现是第三章的主题 与其他计算机程序相比，编程语言的解释器具有独特的通用性。Python在设计时并不会考虑莎士比亚，但它的高度灵活性使我们能够只用少量的语句和表达式来处理大量的文本。 最后，这些核心概念都是紧密相关的：函数是对象，对象是函数，解释器是二者的实例。但是，清楚的理解每一个概念及其在组织代码中的作用对于掌握编程艺术至关重要。 1.1.5 ERROR Python正在等待命令。即使可能还不了解完整的机会和结构，所以总会有一些失误的情况。因为计算机在极其灵活的同时也十分古板，计算机的特性在斯坦福的入门课程中被描述为 当尝试使用Python解释器时，计算机的古板会立即显现出来：即使是最小的拼写和格式更改也会导致预料之外的输出和错误。 学着解释错误和找到错误的原因被称为调试，关于调试的一些指导原则是： 增量测试：每个编写良好的程序都可以单独测试的小型模块化组件组成。尽快测试已经编写的所有内容，以尽早发现问题并获得对组件的信心。 隔离错误：语句输出中错误常可归因于特定的模块化组件。所以在诊断问题时，先追踪错误到最小的代码片段，然后再试着修复问题 检查假设：解释器会一字不漏地执行指令——不多也不少。当某些代码的行为与程序员假设的行为不匹配时，它们的输出就是不合预期的。明确假设，然后将调试的工作集中在验证假设上。 咨询别人：你不是一个人！如果你不理解错误信息，请询问朋友、老师或者搜索引擎，如果已经找出了一个错误，但却不知道如何更正，可以请其他人查看。 增量测试、模块化设计、明确的假设和团队合作时贯穿本书的主题，希望它们也贯穿你的计算机科学职业生涯。","categories":[{"name":"CS61A","slug":"CS61A","permalink":"https://primeluoqiu.github.io/categories/CS61A/"}],"tags":[],"keywords":[{"name":"CS61A","slug":"CS61A","permalink":"https://primeluoqiu.github.io/categories/CS61A/"}]},{"title":"CS61A.Chapter2","slug":"1.2 编程要素","date":"2024-03-22T16:54:16.694Z","updated":"2024-03-22T16:56:21.324Z","comments":true,"path":"2024/03/23/1.2 编程要素/","link":"","permalink":"https://primeluoqiu.github.io/2024/03/23/1.2%20%E7%BC%96%E7%A8%8B%E8%A6%81%E7%B4%A0/","excerpt":"","text":"编程语言不仅是一种指挥计算机执行任务的手段，它还应该成为一种框架，使我们能够在其中组织自己有关计算过程的思想。程序也会在社区之间互相分享，那么程序必须是人类可读，且恰巧能够被机器执行。 这样，当我们描述一种语言的时候，就需要特别注意该语言所提供的能够将简单思想组合成复杂思想的工具。那么每一种强大的语言都有这样三种机制 原始表达式和语句：语言所关心的最简单的个体。 组合方法：由简单元素组合构建复合元素 抽象方法：命名复合元素，并将其作为单元进行操作。在编程中，我们只会处理两种元素：函数和数据(之后会发现他们之间的区分实际上没那么明显)。不那么正式的说法是：数据是我们想要操作的东西。而函数是操作这些数据的规则的描述。 因此，任何强大的编程语言都必须能表达基本的数据和函数，并且提供对函数和数据进行组合和抽象的方法。 1.2.1 表达式下面就一点一点了解Python语言。先从一种基本表达式开始，也就是键入的数字，十进制的表达式 12&gt;&gt;&gt; 4242 表达式表达的数字可以与数学运算符组成一个复合表达式，解释器将对其进行求值： 1234&gt;&gt;&gt; -1 - -10&gt;&gt;&gt;1/2 + 1/4 + 1/8 + 1/16 + 1/32 + 1/64 + 1/1280.9921875 这些数学表达式使用的是中缀表示法，指的是运算符出现在操作数之间。Python包含多种形成复合表达式的方法，后面会慢慢介绍 1.2.2 调用表达式最重要的一种复合表达式就是调用表达式，它将函数运用于一些参数上。回想一下高中学过的函数概念：函数就是从一些输入参数到输出值的映射。例如, max函数会输出一个最大的输入值，也就是将多个输入映射到了单个输出上。Python中函数应用的方式与传统数学相同 12&gt;&gt;&gt; max(7.5, 9.5)9.5 这个调用表达式包含子表达式(subexpression):在括号之前是运算符表达式，而括号里面是一个以逗号分隔的操作数表达式的列表![[..&#x2F;..&#x2F;Pasted image 20240322110143.png]]运算符指定了一个函数，在对这个调用表达式进行求值时，我们会说，使用参数7.5和9.5来调用函数max，最后返回9.5 调用表达式中参数的顺序是很重要的。例如，pow函数的第二个参数是第一个参数的幂","categories":[{"name":"CS61A","slug":"CS61A","permalink":"https://primeluoqiu.github.io/categories/CS61A/"}],"tags":[],"keywords":[{"name":"CS61A","slug":"CS61A","permalink":"https://primeluoqiu.github.io/categories/CS61A/"}]},{"title":"acwing -堆排序","slug":"sort","date":"2024-03-21T13:54:55.018Z","updated":"2024-03-21T13:56:15.931Z","comments":true,"path":"2024/03/21/sort/","link":"","permalink":"https://primeluoqiu.github.io/2024/03/21/sort/","excerpt":"","text":"如何手写一个堆维护一个数据集合支持的基本操作： 插入一个数 求集合当中的最小值 删除最小值 还有操作可以支持 删除任意一个元素 修改任意一个元素 堆是一个二叉树，完全二叉树，树除了最后一层节点之外，上面的所有节点都是满的。最后一层节点从左到右排列。小根堆有个性质：每个点都小于左右儿子，一个递归定义，根节点就是整个数据结构的最小值。堆的存储：(全新的存储方式):用一个一维数组来存。堆状数据结构几乎都可以用一位数组来存储。 存储的话，数组的第一个节点是根节点，然后从x开始，x的左儿子是2x, x的右儿子是2x+1有两种操作，分别是up 和 down，五个操作都可以用这两个函数来解决。 down操作实际上就是在这三个数字里面找到最小的数字，然后把最大的数字和最小的数字进行交换，然后把相对来说小的数推上去 插入一个数：heap [++size] &#x3D; x; up(size); 求集合当中的最小值:heap[1]; 删除最小值 用堆的最后一个元素来覆盖掉堆顶的元素，然后再把堆顶down一下即可。删除头节点比较困难，尾节点比较简单。 heap[1] &#x3D; heap[size]; size –;down(1); 删除任意一个元素: heap[k] &#x3D; heap[size]; heap –; down(k); up(k); 分情况讨论，变大就down一遍，变小就up一下，或者直接不管，up，down一边就行。 修改任意一个元素:heap[k] &#x3D; x; down(k); up(k);下标从1开始 然后我们来看一道题： 1输入一个长度为n的整数数列，从小到大输出前m小的数。 通过读题我们可以看出来，在这里我们只需要down这个操作，我们来看一下down这个操作是怎么实现的 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1e6 + 10;int n, m;int h[N], cnt; //存的heap和存了多少元素//我们只需要把数组建成堆，然后每一次输出堆顶，第一次输出就是第一小的数，然后是第二小的数，然后balabala//需要第二个操作和第三个操作，然后我们发现只需要实现down就可以了。void down(int u)&#123; int t = u; if(u * 2 &lt;= cnt &amp;&amp; h[u * 2] &lt; h[t]) t = u * 2; if(u * 2 + 1 &lt;= cnt &amp;&amp; h[u * 2 + 1] &lt; h[t]) t = u * 2 + 1; if(u != t) &#123; swap(h[u], h[t]); down(t); &#125;&#125;int main()&#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for(int i = 1; i &lt;= n; i ++) scanf(&quot;%d&quot;, &amp;h[i]); cnt = n; //正常输入，然后建堆，如果是一个一个往里面插入的话，时间复杂度是(nlogn)的，有一种时间复杂度是O(n)的方法是从1/2开始往下down for(int i = n / 2; i; i --) down(i); while(m --) &#123; printf(&quot;%d &quot;, h[1]); h[1] = h[cnt]; cnt --; down(1); &#125; return 0;&#125; 至于为什么是O(n)的呢？ down操作很简单，用t来表示三个点里面的最小值，首先判断一下有没有左儿子。 1234567891011void down(int u)&#123; int t = u; if(u * 2 &lt;= size &amp;&amp; h[u * 2] &lt; h[t]) t = u * 2; if(u * 2 + 1 &lt;= size &amp;&amp; h[u * 2 + 1] &lt; h[t]) t = u * 2 + 1; if(u != t) &#123; swap(h[u], h[t]); down(t); &#125;&#125;","categories":[{"name":"acwing","slug":"acwing","permalink":"https://primeluoqiu.github.io/categories/acwing/"}],"tags":[],"keywords":[{"name":"acwing","slug":"acwing","permalink":"https://primeluoqiu.github.io/categories/acwing/"}]},{"title":"Lecture 5 - List3","slug":"Lecture5 - List3 DLList And Arrays","date":"2024-03-20T14:21:05.839Z","updated":"2024-03-21T13:56:27.690Z","comments":true,"path":"2024/03/20/Lecture5 - List3 DLList And Arrays/","link":"","permalink":"https://primeluoqiu.github.io/2024/03/20/Lecture5%20-%20List3%20DLList%20And%20Arrays/","excerpt":"","text":"之前说到的SLList还是很不错的，不过目前来看的话它存在了一个新的问题，就是对于addLast函数而言，还是相对来说比较缓慢地，效率也是比较低的。 就像是最一开始的size函数，那么我们有什么办法可以提高它的效率呢，我们可以在中间人那里再定义一个last函数用来保存最后一个节点的地址，不过这样的话，就会有新的操作效率较慢了 那便是remove操作，那么如果我们想要删除一个节点的话，那么我们只能首先遍历到节点那里，然后删除这个节点的指针，然后再将last的那个指针指向删除的节点的前一个节点。这听起来实在是太麻烦了，所以这种方法似乎也是不可取的。那么还有什么别的方法吗 那么，我们就想到能不能就是给每一个节点添加一个当前节点的前置节点的指针呢？答案是可以的 这种每个节点都有两个链接的列表叫做双向链表 完成这种方法之后，我们的添加在头部和尾部，删除头部和尾部的方法就会变得十分的快，不过在中间的节点操作相对来说就会比较慢。 不过这样的链表还是会存在一个 限制有这样一种情况：最后一个节点的next指针有的时候指向最开始的哨兵节点，有的时候指向我们称之的最开始的节点(real node)。那么就有可能需要我们在后面再去写相关的判断语句来判断它是否真的是哨兵节点。 为了避免这种麻烦的情况，我们尝试让他变得更纯粹一些。 所以为了完善我们的方法的最自然的方法就是添加第二个哨兵，然后让着第二个哨兵来指向最后一个节点，我们不再是一个指向最后一项的一个指针，而是在开始和末尾两端都添加一个哨兵（因为此时我们已经有了prev和next指针），这样的话，前面就有一个哨兵，后面也有一个哨兵了，那么这样再添加节点或者项目的时候，就只需要将节点滑入这两个哨兵之间就可以了 那么其实还有一种办法，这里依旧还是只有一个哨兵，它既是前面的哨兵也是后面的哨兵 ![[../一些截图（笔记用）/Pasted image 20240226134251.png]] 就像这里的，先指向哨兵节点，然后指向3，指向9，最终再回到sentinal.所以这实际上更像一个循环。 不过即便是这样，还是会有一个限制，就是说在现实世界中不太好使，就是说，如果我们要添加的东西是数字时，它会非常的好用，但是如果我们添加的是字符串或者字符呢？我们又该怎么办，例如 123456public class SLListLauncher &#123; public static void main(String[] args) &#123; SLList s1 = new SLList(&quot;Bone&quot;); s1.addFirst(&quot;thugs&quot;); &#125;&#125; 也就是说，我们不能将字符串转化成整数这样的报错。 我们可以选择重新创建一个全新的SLList类，不过这意味着我们还需要重新写一遍我们的类。这听起来可太麻烦了。 不过，还有一种方法就是使SLList参数化，我们可以参数化SLList将采用的类型，这应该如何操作呢 就是我们要在SLList后面添加新的尖括号&lt;&gt;，然后在尖括号里面添加任意的字符串，例如LochNess，这是充当创建SLList时尚未决定的类型的占位符，因此这个时候我们将使用LochNess来代替int项，然后这个时候我们也会将我们创建一个节点的名字改成 123private class StuffNode(LochNess i, StuffNode n) &#123; ...&#125; 定义是这样的 123456public class SLList&lt;LochNess&gt; &#123; private class StuffNode &#123; public LochNess item; public StuffNode next; &#125;&#125; 这个时候我们只需要将main函数修改一下即可 现在想要创建一个SLList的话，需要指定一个类型 1SLList&lt;String&gt; s1 = new SLList&lt;String&gt;(&quot;bone&quot;); //定义并实例化 然后就正常工作了。 在我们使用的时候，我们往&lt;&gt;里传什么，对应的函数里的&lt;&gt;也会传什么，所以它基本上是一个类型变量或类型参数 在更现代的java中，不再需要在实例化方面指定类型，也是行得通的。 在指定类型的时候，只需要指定一次计科，可以在其他地方多次使用它。使用的时候尖括号内的首字母需要大写!!!","categories":[{"name":"CS61B","slug":"CS61B","permalink":"https://primeluoqiu.github.io/categories/CS61B/"}],"tags":[],"keywords":[{"name":"CS61B","slug":"CS61B","permalink":"https://primeluoqiu.github.io/categories/CS61B/"}]},{"title":"Hello World","slug":"Lecture4-List 2 SLLists","date":"2024-03-20T14:21:05.838Z","updated":"2024-03-20T14:24:22.475Z","comments":true,"path":"2024/03/20/Lecture4-List 2 SLLists/","link":"","permalink":"https://primeluoqiu.github.io/2024/03/20/Lecture4-List%202%20SLLists/","excerpt":"","text":"Video 1:Class A:Introducing the SLListLast Time in 61B: Recursive Implementation of a List 12345678910public class IntList &#123; public int first; public IntList rest; public IntList(int f, IntList r) &#123; first = f; rest = r; &#125;&#125;... While functional, “naked”linked lists like the one above are hard to use. Users of this class are probably going to need to know references very well, and be able to think recursively.Let’s make our users’ lives easier.这些代码对于我们来讲是比较容易看懂的，但是对于用户来讲可能就比较费解，那么我们需要一些其他的方式来重新叙写我们的IntList。对它进行更新换代，以至于让我们的用户理解起来也很方便 Improvement #1: Rebaranding and Culling123456789public class IntNode &#123; public int item; public IntNode next; public IntNode(int i, IntNode n) &#123; item = i; next = n; &#125;&#125; IntNode is now dumb, has no methods.We will reintroduce functionality in the coming slides. Not much of an improvement obviously, but this next weird trick will be more impressive. Class B:Introducing the SLList Bureaucracy这个也提供了一些小方面的改善。下一步，我们创建另一个类，命名为SLList，这个类表示是一个整数列表，隐藏了内部是单纯的数字的真相。这个列表的工作原理是我们已经有一个IntList类 123456789101112131415package Lecture4; /* An SLList is a list of integers, which hides the terrible truth * of thr nakedness within. */ public class SLList &#123; public IntNode first; public SLList(int x) &#123; first = new IntNode(x, null); &#125; public static void main(String[] args) &#123; /*Create a list of one integer, namely 10*/ SLList L = new SLList(10); &#125; &#125; 那么我们为什么要做这种看起来似乎没什么意义的事情呢？这是一个线索，如果考虑一下某个程序员如何创建列表，那么他实际上不必指定null，只需要添加一个数字即可。在之前，当我们想要创建一个列表，我们需要 1IntNode X = new IntNode(10, null); 而现在我们只需要 1SLList Y = new SLList(10); SLList is easier to instantiate(no need to specify null), but wait, there’s more. 123456public class SLList &#123; public IntNode first; public SLList(int x) &#123; front = new IntNode(x, null); &#125;&#125; Next: Let’s add addFirst and getFirst method to SLList. Class C: Introducing the SLList Methods在我们拿走了IntNode能做的所有事情之后，我们将会在SLList中还原他，接下来是我们准备还原的一部分addFirst getFirst当我们想要完成第一个函数的addFirst的时候，我们可以从之前的IntList当中寻找灵感，在这里我们创建一个新的点的时候![[..&#x2F;..&#x2F;Pasted image 20240126093348.png]]用到的是L = new IntList，那么我们在这里也是 1234// Add x to the front of the list.public void addFirst(int x) &#123; first = new IntNode(x, null); &#125; 至于getFirst的话，相对来说我们只需要返回第一个的item，相对来说会简单很多 1234// Returns the first item in the listpublic int getFirst() &#123; return first.item;&#125; SLLists vs. IntLists对比一下之前写的和最近写的 123456789SLList L = new SLList(15);L.addFirst(10);L.addFirst(5);int x = L.getFirst();IntList L = new IntList(15, null);L = new IntList(L, 10);L = new IntList(L, 5);int x = L.first; While functional, “naked”linked lists like the IntList class are hard to use. Users of IntList are need to know Java references well, and be able to think recursively. SLList is much simpler to use. Simply use the provided methods. Why not just add an addFirst method to the IntList class? Turn out there is no efficent way to do this. See exercise in LectureCode repository. Video 2: Access Control and Nested Classes我们不难发现，SLList是很好用的，想要添加，删除，或者获取内容的话，最好使用该类提供的方法，不过，根据java的工作效益，可以尝试做一些奇怪的事情。 123456789101112public class SLList &#123; public IntNode first; public SLList(int x) &#123; first = new IntNode(x, null); &#125; public void addFirst(int x) &#123; first = new IntNode(x, first); &#125; ...&#125; Users of our classes might be tempted to try to manipulate our secret IntNode directly in uncouth ways! 123SLList L = new SLList(15);L.addFirst(10);L.first.next.next = L.first.next; 显然，这是不被允许的。可以猜一下会发生什么![[..&#x2F;..&#x2F;Pasted image 20240127092904.png]]![[..&#x2F;..&#x2F;Pasted image 20240127092922.png]]它最终会指向自身，我们最终毁掉了这个列表。很显然，我们并不想被类似这样的调用其他方法来毁掉我们的列表，因此我们可以在我们的程序之前添加注释，类似 1/*Don&#x27;t mess up my programmer*/ 但是这很显然没有下述方式来的更加畅快 Access Control 123456789101112public class SLList &#123; public IntNode first; public SLList(int x) &#123; first = new IntNode(x, null); &#125; public void addFirst(int x) &#123; first = new IntNode(x, first); &#125; ...&#125; We can prevent programmers from making such mistakes with the private keyword.我们可以给类的成员声明为private而不是声明为public例如 1private IntNode first; 现在，好处是，这不仅是自行记录的，而且还有编译器强制执行，那么在别的类中访问这个变量就会报错因此private关键字的作用是防止其他类中的代码使用该类的成员(包括变量，方法…)不过，java中有一个有趣的功能称为反射。允许绕过这些修饰符，不过很少使用。 Why Restrict Access?Hide implementation details from users of your class. Less for user of class to understand. Safe for you to change private methods.(implementation).E.g:Car analogy: Public: Pedals, Steering Wheel Private:Fuel line, Rotary valve. Despite the term ‘access control’: Nothing to do with protection against hackers, spies, and other evil entities.至于为什么要限制通过呢，也就是说为什么要用private，一个方面是为了对使用你的类的人隐藏实施细节，他们不需要了解这个原理是什么，他们有对应的输入和输出即可。其次，对你来讲去修改这种私有方法是很安全的。例如在一个车的系统当中，公共的部分有例如踏板，轮胎这些，而私有的例如燃油管线（现在有纯电车）。不过，当有人获取到你的源码之后，这些所谓的安全也就不存在了。 总结一下，私有就是你可以随便处置但是用户不可以，公共就是都可以访问你的方法等一系列东西。 Improvement 4: Nested ClassesCan combine two classes into one file pretty simply. 123456789101112131415public class SLList &#123; public class IntNode &#123; //Nested class definition public int item; public IntNode next; public IntNode(int i, IntNode n) &#123; item = i; next = n; &#125; &#125; // Could have made IntNode a private nested class if we wanted.private IntNode first; //Instance variables, constructors, and methods of SLList typical go below nested class definition.public SLList(int x) &#123; first = new IntNode(x, null); &#125;...&#125; 一个嵌套的类定义，那么，嵌套的类有什么好处呢？ Why Nested Classes?Nested Classes are useful when a class doesn’t stand on its own and is obvious subordinate(从属，下属) to another class. Make the nested(嵌套的) class private if other classes should never use the nested class. In my opinion, probably makes sense to make IntNode a nested private class. Hard to imagine other classes having a need to manipulate IntNodes Static Nested Classes If the nested class never uses any instance variables or methods of the outer class, declare it static Static classes cannot access outer class’s instance variables or methods. Results in a minor savings of memory. See book for more details.123456789101112public class SLList &#123; private static class IntNode &#123; //we can declare IntNode static, since it never use any of SLList&#x27;s instance variables or methods. public int item; public int IntNode next; public IntNode(int i, IntNode n) &#123; item = i; next = n; &#125; &#125; ...&#125; Unimportant note:For private nested classes, access modifiers are irrelevant.如果嵌套类从不需要查找，那么可以添加staitc关键字。 Video3: addLast and sizeAdding more SLList Functionality To motivate our remaining improvements, and to give more functionality to our SLList class, let’s add: .addLast(int x) .size()Recommendation: Try writing them yourself before watching how I do it.添加了两个其他的方法。 12345678910public void addLast(int x) &#123; IntNode p = first; /*Move p until it reaches the end of the list. */ while(p.next != null) &#123; p = p.next; &#125; p.next = new IntNode(x, null); &#125; 当想要尝试.size()的时候，我们发现试图搞清楚基本情况是比较困难的。如果使用递归的话情况也是很奇怪，如果想要用递归来做的话，那么就无从下手。原因是SLList这个数据结构本身就不是递归的，它没有SLList指针。因此只能采用相对来说通用性更强一些的策略了、 通常会创建一个私有的静态帮助器方法，它会采用一个特定的节点来帮助我们解决这个问题。所以现在的话，这就是一个非常清晰的递归数据结构 那么这样的话 123456789private static int size(IntNode p) &#123; if(p.next == null) return 1; return 1 + size(p.next); &#125; public int size() &#123; return size(first); &#125; Video 4: Caching假设有一个长度为1000的SLList，我们遍历一遍获得它的长度的时间是两秒，那么如果有一个长度为1,000,000的链表的时候，时间就是2,000秒，那么这个函数实际上是效率很低的，那么我们应该用什么方式来提高它的效率呢？ 我们可以选择在类的内部定义一个私有的成员变量size，然后在类似addFirst, addLast这里对size += 1，然后在定义一个链表的时候让size = 1，这样在写size函数的时候直接return size即可。 不过其实，这样和遍历一个链表的所花费的空间或者说时间还是一样的，只不过是把一个很大的任务分散化了， 也就是说，当我们每操作一次链表，size的值就会被更新一下。 那么还有没有别的办法呢 当然肯定是有的。就是利用我们最开始引入的那个中间人，也就是first节点，在这里我们可以用他来存储有关整个列表的元信息的自然位置 之前说过`SLList`有一个很好的优势，就是每当想要操作数据或者查看数据的时候，都必须经过这个中间人，这个中间人为我们提供了非常简单易懂的办法来保证安全，避免我们以各种方式搬起石头砸自己的脚。 现在`SLList`结构拥有这个中间人的另一个好处是，它可以作为存储有关整个列表元信息的自然位置。例如，我们可以在这里存储列表的大小，这在技术上是多余的，我们可以在没有这个变量的情况下计算大小，但它会加快大小的计算速度，因为我们只需要返回这个大小的值，我们也可以在这里存放其他东西，就像可以存储曾经放入其中的最大值、最小值等，这些也可以正常工作。 相比之下，使用裸递归列表就不那么容易了，指图片中的上者，原则上可以执行诸如缓存每个节点内部的大小之类的操作。但即便如此，这也意味着每当我们更改列表中的某些内容时，都必须更新一堆大大小小的变量，例如如果有一种允许这样做的语言，我们还可以以某种方式在此处绑定一个变量来跟踪整个事物的大小。但是在Java中，没有天然的工具（函数）可以做到这一点。因此，实际上，我们最终要做的就是拥有多个必须保持一致的变量，在这里，这种面向对象的编程方法意味着我们让对象来控制一切，我们告诉对象，你的工作不仅是王城所有这些任务，还要为我跟踪尺寸，这样，这就是组织代码的自然方式。 也就是说，`intList`可以做`SLList`可以做的所有的事情，但是`SLList`在几乎所有方面都是一种更自然的方法 Video 5 The Empty List那么SLList这么好用，他还可以允许我们自己代表空列表，也就是说创建列表的时候可以很自然的实例化一个空列表，那么我们来修改一下我们的代码 123456/*Create an empty SLList*/public SLList()&#123; size = 0; first = null; &#125; 源码此时是这样的 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package Lecture4; /* An SLList is a list of integers, which hides the terrible truth * of thr nakedness within. */ import Lecture3.IntList; public class SLList &#123; public IntNode first; private int size; public SLList() &#123; first = null; size = 0; &#125; /*Creates an empty SLList*/ public SLList(int x) &#123; first = new IntNode(x, null); &#125; // Adds x to the front of the list. public void addFirst(int x) &#123; first = new IntNode(x, first); size += 1; &#125; // Returns the first item in the list. public int getFirst() &#123; return first.item; &#125; //Adds x to the last of the list. public void addLast(int x) &#123; IntNode p = first; /*Move p until it reaches the end of the list. */ while(p.next != null) &#123; p = p.next; &#125; p.next = new IntNode(x, null); size += 1; &#125; /*Returns the sizes of the list from IntNode p*/ /*private static int size(IntNode p) &#123; if(p.next == null) return 1; return 1 + size(p.next); &#125; public int size() &#123; return size(first); &#125;*/ public static void main(String[] args) &#123; /*Create a list of one integer, namely 10*/ SLList L = new SLList(); L.addFirst(10); L.addFirst(5); L.addLast(20); System.out.println(L.size); &#125; &#125; 结果自然而然的就是3但是实际上这个代码会存在一个小小的bug就是，如果我们不是先从头插入的话，就会报错，例如我们第一步先用addLast的话就会报错![[..&#x2F;一些截图（笔记用）&#x2F;Pasted image 20240222155831.png]]是因为我们将一个指针指向了空指针，然而空指针的下一位是空的，就会报错。那么我们应该如何处理这个问题呢？有一个方法就是在addLast中添加一个判断语句，即 123456789public void addLast(int x)&#123; size += 1; if(first == null) &#123; first = new IntNode(x, first); return; &#125; ...&#125; 这样再看的话，我们的程序目前工作就正常了![[..&#x2F;一些截图（笔记用）&#x2F;Pasted image 20240222160836.png]] Video 6: Sentinel Nodes在我们了解到上述问题之后，其实还有一种解决的方式，这种方式未来会在我们在构筑大型项目上的时候有所优势。就是创建一个哨兵节点，然后哨兵节点来传递到第一个节点、第二个节点…这些，然后我们用一个指针来讲创建的列表指向我们的哨兵节点，这样的话无论列表是不是空的都会有一个节点在那里。不过这样的话，我们就需要对基本上所有的函数进行修改了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package Lecture4; /* An SLList is a list of integers, which hides the terrible truth * of thr nakedness within. */ import Lecture3.IntList; public class SLList &#123; private static class IntNode &#123; public int item; public IntNode next; public IntNode(int i, IntNode n) &#123; item = i; next = n; &#125; &#125; private int size; /*The first item (if it exists) is at sentinel.next*/ private IntNode sentinel; public SLList() &#123; sentinel = new IntNode(66, null); size = 0; &#125; /*Creates an empty SLList*/ public SLList(int x) &#123; sentinel = new IntNode(66, null); sentinel.next = new IntNode(x, null); size = 1; &#125; // Adds x to the front of the list. public void addFirst(int x) &#123; sentinel.next = new IntNode(x, sentinel.next); size += 1; &#125; // Returns the first item in the list. public int getFirst() &#123; return sentinel.next.item; &#125; //Adds x to the last of the list. public void addLast(int x) &#123; size += 1; IntNode p = sentinel; /*Move p until it reaches the end of the list. */ while(p.next != null) &#123; p = p.next; &#125; p.next = new IntNode(x, null); &#125; /*Returns the sizes of the list from IntNode p*/ /*private static int size(IntNode p) &#123; if(p.next == null) return 1; return 1 + size(p.next); &#125; public int size() &#123; return size(first); &#125;*/ public static void main(String[] args) &#123; /*Create a list of one integer, namely 10*/ SLList L = new SLList(); L.addFirst(10); L.addFirst(5); L.addLast(20); System.out.println(L.size); &#125; &#125; 改完之后就是大致这样的 那么哨兵节点实际上就是一个虚拟的节点，一个忠实的伙伴。鉴于第一个不再指向第一项，那么我们重命名它为哨兵代码 当然，哨兵对于我们便携的所有代码来说它永远不会为空，并且它总是指向哨兵节点，哨兵节点的值可以随机，我在这里选择了66.当我们编写带么和检查每个构造函数和方法时，我们必须确保所有内容都与我们的哨兵节点兼容。理想情况下，一开始就这样做的话这样就不会感觉那么随意。我们不会一次性做出一堆微小的改变 Video 7: Invariants我们可以使用术语不变性来概括这种保持简单的想法。因此不变量只是一个在代码运行时保证为真的条件。所以它列出了所有可以信赖的事实。因此，带有哨兵节点的SLList那么它总是具有一些不变量，例如哨兵变量——哨兵应用它总是指向一个哨兵节点，这是我们所拥有的东西，并且保证是真实的另一个是列表中的第一个节点(如果存在的话)，那么它始终位于sentinel.next，事实上，这在代码中是作为注释明确写出得一个不变量。 因此，不变量的好处是它可以让我们更容易地推理代码它可能让我们避免出错","categories":[{"name":"CS61B","slug":"CS61B","permalink":"https://primeluoqiu.github.io/categories/CS61B/"}],"tags":[],"keywords":[{"name":"CS61B","slug":"CS61B","permalink":"https://primeluoqiu.github.io/categories/CS61B/"}]},{"title":"Hello World","slug":"Lecture3-List 1 Refrence Recursion and Lists","date":"2024-03-20T14:21:05.836Z","updated":"2024-03-20T14:24:20.763Z","comments":true,"path":"2024/03/20/Lecture3-List 1 Refrence Recursion and Lists/","link":"","permalink":"https://primeluoqiu.github.io/2024/03/20/Lecture3-List%201%20Refrence%20Recursion%20and%20Lists/","excerpt":"","text":"Welcome!MenuLecture 3: References and Recursion Primitive Types Reference Types Linked Data Structures List In lecture2, we saw how we can create a List in Java. Unlike Python, lists are not bulit directly into the Java language123456import java.util.List;import java.util.LinkedList;List&lt;String&gt; L = new LinkedList&lt;&gt;();L.add(&quot;a&quot;);L.add(&quot;b&quot;); Today, we’ll begin our 3 lecture journey towards building our own list implementation We’ll exploit recursion to allow our list to grow infinitely large. But first we need to slove … the mystery of the walrus Video 1:The Mystery of the Walrus.先看一段代码并回答一个问题： 123456Walrus a = new Walrus(1000, 8.3) //创建了一个海象的类，前面是体重，后面是象牙大小Walrus b;b = a;b.weight = 5;System.out.println(a);System.out.println(b); Will the change to b affect a?(y&#x2F;n) :… 12weight: 5, tusk size: 8.30weight: 5, tusk size: 8.30 我们很惊讶的发现A居然会受到B的影响，体重居然被改成了5.接下来，再看一段代码，回答一个问题 123456int x = 5;int y;y = x;x = 2;System.out.println(&quot;x is:&quot; + x);System.out.println(&quot;y is:&quot; + y); Will the change to x affect y?(y&#x2F;n)… 12x is: 2y is: 5 但是在这里我们发现x并不受y的影响，但是这到底是为什么呢？接下来，让我们在可视化工具这里运行他，发现差异的地方 12345678910111213141516171819202122232425262728293031public class PollQuestions &#123; public static void main(String[] args) &#123; Walrus a = new Walrus(1000, 8.3); Walrus b; b = a; b.weight = 5; System.out.println(a); System.out.println(b); int x = 5; int y; y = x; x = 2; System.out.println(&quot;x is: &quot; + x); System.out.println(&quot;y is: &quot; + y); &#125; public static class Walrus &#123; public int weight; public double tuskSize; public Walrus(int w, double ts) &#123; weight = w; tuskSize = ts; &#125; public String toString() &#123; return String.format(&quot;weight: %d, tusk size: %.2f&quot;, weight, tuskSize); &#125; &#125;&#125; ![[Pasted image 20240119121426.png]]在b=a这里时，我们可以看到，我们有两个箭头指向同一个Walrus，所以无论出于何种原因a和b实际上指的都是同一只海象，如果执行b.weight = 5那么就会改变着一个海象(Walrus)的值，因此打印出来为5就不那么奇怪了。 那么整数情况呢![[Pasted image 20240119123108.png]]我们发现在图中这两个整数对应的是两个小盒子，修改的话只会修改对应的小盒子的值。那么，这到底是为什么呢？ Video 2: Primitive Types这个时候就要先解释一下计算机的底层工作原理了(61C) Bits Your computer stores information in “memory” Information is stored in memory as a sequence of ones and zeros Example:72 stored as 01001000 Example:205.75 stored as …01000011 01001101 11000000 00000000 Example:The letter H stored as 01001000(same as the number 72)(计算机知道如何根据特定上下文解释这些位) Example:True stored as 00000001Each Java type has a different way to interpret the bits: 8 primitive types in Java:byte, short, int, long, float, double, boolean, char 想要存储在计算机上的东西实际上都存储在所谓的内存中，内存所存的信息都被编码为0和1的序列即使H和72有单独的表现形式，该类型也会告诉Java解释器如何解释这个变量应该是什么。因此如果有一个字符类型的变量，那么当它看到后面的序列的时候就会考虑到字符H。但是如果有一个整数变量，那么当它看到后面的序列的时候就会考虑到72 Declaring a Variable(Simplified) When you declare a variable of a certain type in Java: Your computer sets aside exactly enough bits to hold a thing of that type. Example:Declaring an int sets aside a “box” of 32 bits. Example:Declaring an double sets aside a “box” of 64 bits. Java creates an internal(内部的) table that maps(映射) each variable name to a location. Java does NOT write anything into the reserved boxes. For safety, Java will not let access a variable that is uninitialized(未初始化的).1234int x;int y; //以上只是声明，并未赋值x = -1431195969;y = 567213.112; 当运行int x的时候，我们得到了一个长度为32位的盒子，而运行double y的时候，我们得到了一个64位的盒子。虽然我们在定义变量的时候并没有往里面放入任何东西，但是实际上里面是有东西的，是因为内存是一些世界上主观存在的物理对象。所以内存将包含一些0和1的序列。但是Java并不允许实际访问现有的信息。这有点像在着急的时候从桌子上拿起来一张纸，因为需要快速写下笔记，类似电话号或者一些其他的事情，上面可能已经有一些东西了，但是我们通常不关心它。因为我们拿起来是想要写一些我们要关注的东西。那么因此，当我们在定义玩变量但是未赋初值的时候，这种操作是不被允许的。 接下来，当运行赋值语句的时候，这些数值就会被变化成一串带有0和1的序列存到int的32位的盒子中，而y存进对应的64位的盒子中。![[Pasted image 20240119153743.png]] Simplified Box Natation We’ll use simplified box notation from here on out: Instead of writing memory box contents in binary,we’ll write them in human readable symbols.正是因为当我们看见那一串0和1的序列的时候看起来很长，很令人生畏。那么这种所谓方框表示法是可以被简化的。也就是说，当我们对x和y存入值的时候，我们用我们能够更轻易理解的数字来代替那些二进制形式写出的内存盒。当x&#x3D;-1431195969的时候，我们就用这一串数来存进去，y同理。而它也就恰好和Java Visulizer所展现的是一样的原理。![[Pasted image 20240119154105.png]]接下来，就可以解开这项谜题了 The Golden Rule of Equals(GRoE) Given variables y and x: y &#x3D; x copies all the bits from x into y.![[Pasted image 20240119154447.png]][https://cscircles.cemc.uwaterloo.ca/java_visualize/#mode=display]12345678910public class PollQuestions &#123; public static void main(String[] args) &#123; int x = 5; int y; y = x; x = 2; System.out.println(&quot;x is: &quot; + x); System.out.println(&quot;y is: &quot; + y); &#125;&#125; 那么当x被执行等于2的时候，根据GRoE法则，也就是只会把用二进制表示的二的这些位放入x所表示的那个框中。所以y没有被改变。有两个不同的盒子。这就是整数为什么不会发生变化所表现出来的答案。 Video 3: Reference TypesReference Types There are 8 primitive(原始的) types in Java： byte, short, int, long, float, double, boolean, charEverything else, including arrays,is a reference(引用) type Class Instantiations When we instantiate an Object(e.g Dog, Walrus, Planet): Java first allocates a box of bits for each instance variable of the class and fills them with a default value(e.g 0, Null). The constructor then usually fills every such box with some other value.123456789public static class Walrus &#123; public int weight; public double tuskSize; public Warlus(int w, double ts) &#123; weight = w; tuskSize = ts; &#125;&#125; 00:53(一个例子)通过这个例子可以看出来每当我们调用new的时候，Java会做的事就是挖掘内存，并找到96位(一个double一个int加起来一共96位)，然后函数找到之后用1000填充这个顶部位，8.3填充那个底部位在此处可见02:46new关键字可以认为是返回了一个放置这个东西的一个首位数。Can you think of new as returning the address of the newly created object. Address in Java are 64 bits. Example(rough picture): If object is created memory location 23874723423, then new returns 2384723423.接下来讨论一下引用类型变量的声明 Reference Type Variable DeclarationsWhen we declare a variable of any reference type(Warlus, Dog, Planet): Java allocates exactly a box of size 64bits, no matter what type of object. These bits can be either set to: Null(all zeros). The 64 bits “address” of a specific instance of that class(return by new)当我们声明的时候,Java会做的就是分配一个刚好64位的盒子（无论类型是什么），这些盒子的返回值可以是0，也可以设置为new返回的该类的特定实例的地址。04:21也就意味着说，即使Warlus本身需要96位，但是我们存储的地址依旧是64位的 06:19介绍了一种方法来简化上面的表达方式，同样也是在Java Visulizer中呈现的 The 64 bit address are meaningless to us as humans, so we’ll represent: All zero addresses with “null” Non-zero addresses as arrows.This is sometimes called “box and pointer” notation.上述是原理 Reference Types Obey the Golden Rule of Equals 06:58对于Warlus的一步一步解释 Just as with primitive types, the equals sign copies the bits. In terms of our visual metaphor, we “copy” the arrow by making the arrow in the b box point at the same instance as a.1234Warlus a;a = new Warlus(1000, 8.3);Warlus b;b = a; equal只是复制位，这对于基本类型是正确的，对于引用类型也是一样的。 Video 4: Parameter PassingThe Golden Rule of Equals(and Parameter Passing) Given variables b and a: b &#x3D; a copies all the bits from a into b.Passing parameters obeys the same rule:Simply copy the bits（This is also called by value按值传递) to the new scope.Example:123456789public static double average(double a, double b) &#123; return (a + b) / 2;&#125;public static void main(String[] args) &#123; double x = 5.5; double y = 10.5; double avg = average(x, y);&#125; 例子解释在00:31 总结： The Golden Role: Summary There are 9 types of variables in Java: 8 primitive types(bytes, short, int, long, float, double, boolean, char). The 9th type is references to Object(an arrow). References may be null. In box-and-pointer notation, each variable is drawn as a labeled box and values are shown in the box. Addresses are represented by arrows to object instance. The golden rule: b &#x3D; a copies the bits from a into b. Passing parameters copies the bits Video 5:Test Your Understand of the GRoETest Your Understanding:Does the call to doStuff(walrus, x) have an affect on Warlus and&#x2F;or main’s x? 123456789101112public static void main(String[] args) &#123; Warlus walrus = new Warlus(3500, 10.5); int x = 9; doStuff(warlus, x); System.out.println(warlus); System.out.println(x);&#125;public static void doStuff(Warlus W, int x) &#123; W.weight = W.weight - 100; x = x - 3;&#125; A. Neither will change.B. warlus will lose 100 lbs, but main’s x will not change.√C. warlus will not change, but main’s x will decrease by 5.D. Both will decrease. 解开答案在视频的这一段01:06简单的来说，就是因为对象类数组是通过一个指针进行访问的，不管是哪个函数，只要是引用到了warlus这个对象，那么都会通过对应的指针访问到这个变量当中，最终修改它最后的值，而数字x所存的是那个数字对应的二进制符号，那么在函数中修改的话，修改范围也就仅限那个函数![[..&#x2F;..&#x2F;Pasted image 20240124112801.png]] Video 6:Instantiating Arrays.视频讲解02:13 Declaration and Instantiation of Arrays Arrays are also Objects.As we’ve seen, object are (usually) instantiated using the new keyword. Planet p = new Planet(0, 0, 0, 0, 0, &quot;blah.png&quot;); int []x = new int[]&#123;0, 1, 2, 95, 4&#125;;1int [] a;//Declaration Declaration creates a 64 bit box intended only for storing a reference to an int array.No objects in instantiated(声明创建了一个64位的盒子，仅仅用于存储对int数组的引用，但是并没有实例化对象)1new int[]&#123;0, 1, 2, 95. 4&#125; Instantiates a new Object, in this case an int array. Object is anonymous上述两种类型创建的数组都是没有效果的，第一个只是声明了有一个a数组，然后并没有对它进行实例化。而第二个数组是anonymous(匿名的)，也就是说，并没有给它赋予名字，new这个函数返回的是一个地址，也就是存放这个数组的地址，但是显然没有一个名称赋予给这个地址的变量，那么在执行完这句话之后这个数组也就会消失。 Assignments of Arrays 1int [] a = new int[]&#123;0, 1, 2, 95, 4&#125;; Creates a 64 bit box for stroring an int array address.(declaration) Creates a new Object, in this case an int array.(instantiation) Puts the address of this new Object into the 64 bit box named a.(assignments) Note: Instantiated objects can be lost. If we were to reassign a to something else, we’d never be able to get the original Object back!也就是说，在上面的语句中，我们将声明、实例化和命名同时进行了，那么我们就会存储这么一个对象a，存了balabala这么一些东西。不过，有趣的是，即使我们存好之后，这个实例化的对象还是有可能会丢失的，假如我们重新new了一个新的对象令它&#x3D;a，那么我们之前创建的这balabala的变量就会被Java的收集器所消耗掉，也就是消失了。![[..&#x2F;..&#x2F;Pasted image 20240124114823.png]] Video 7:Introducing IntLists在了解完这一切之后，我们准备创建一个列表，因此，列表和数组之间的区别在于，列表可以任意增长，这与具有固定大小的数组不同。所以我们将完全从头开始构建它。 IntList Let’s define an IntList as an object containing two member variables: int first; IntList rest; And define two version of the same method: size() iterativeSize()列表将有两个变量，一个是名为first的整数，另一个是另一个int列表的指针或地址。为了简单起见，我们的列表仅仅只用来存储整数。 详情创建及过程视频见00:43 123456789public class IntList &#123; public int first; public IntList rest; public static void main(String args[]) &#123; &#125;&#125; 事实上在这个时候我们就已经创建好一个列表了。接下来我们添加东西 1234567891011121314151617public class IntList &#123; public int first; public IntList rest; public static void main(String args[]) &#123; IntList L = new IntList(); L.first = 5; L.rest = null; L.rest = new IntList(); L.rest.first = 10; L.rest.rest = new IntList(); L.rest.rest.first = 15; &#125;&#125; 通过Java Visualizer来理解过程![[..&#x2F;..&#x2F;Pasted image 20240124122549.png]]这样的代码看起来似乎略有尴尬，那么我们选择往前退一步来看。我们首先先创建一个构造函数 1234public IntList(int f, IntList r) &#123; first = f; rest = r; &#125; 然后我们将以相反的方式建立list 12345678910111213141516public class IntList &#123; public int first; public IntList rest; public IntList(int f, IntList r) &#123; first = f; rest = r; &#125; public static void main(String args[]) &#123; IntList L = new IntList(15, null); L = new IntList(10, L); L = new IntList(5, L); &#125;&#125; ![[..&#x2F;..&#x2F;Pasted image 20240124123309.png]]在这个时候，因为13的L还未执行完成，那么此时的L就是在12行创建出来的L不过这看起来似乎还是略有尴尬… Video 8:IntList size这个时候我们会发先如果我们想要访问这个列表的大小啊，获取第i个元素啊非常麻烦。这个时候，我们就需要对这个列表添加一个size方法和一个迭代size的方法，其行为就类似于Python中的length函数这个函数需要用递归的方法来实现，当我们每次访问它的时候，它会去问它剩下的rest里面还有多少个节点… 12345public int size() &#123; if(rest == null) return 1; return 1 + this.rest.size();&#125; 可以通过Visualizer来阅读每一步的操作![[..&#x2F;..&#x2F;Pasted image 20240124140057.png]] Video 9:IntList iterativeSize在上述方法的基础上，我们还可以考虑用迭代的方法来解决这个问题 1234567891011// Return the size of the list using no recursion! public int interativeSize() &#123; int p = this; int totalSize = 0; while(p != null) &#123; totalSize += 1; p = p.rest; &#125; return totalSize; &#125; Video 10:More IntList ExerciseChallenge Write a method int get(int i) that returns the ith item in the list. For simplicity, OK to assume the item exists. Front item is the 0th item. Ways to work: Paper(best) Laptop(see lecture) Head…先决条件12345678910111213141516171819202122public class IntList &#123; public int first; public IntList rest; public IntList(int f, IntList r) &#123; first = f; rest = r; &#125;// Return the size of this IntList public int size() &#123; if (rest == null) return 1; &#125; return 1 + this.rest.size();&#125;public static void main(String args[]) &#123; IntList L = new IntLise(15, null); L = new IntList(10, L); L = new IntList(5, L); System.out.println(L.get(0));&#125; 输出应该是5 实现函数想法如下: 12345678910public int get(int i) &#123; int a = 0; IntList p = this; while( a != i) &#123; a ++; p = p.rest; &#125; return p.first; &#125; 用迭代方式实现 12345public int get(int i) &#123; if(i == 0) return first; return rest.size(i - 1);&#125; 用递归的方式实现。","categories":[{"name":"CS61B","slug":"CS61B","permalink":"https://primeluoqiu.github.io/categories/CS61B/"}],"tags":[],"keywords":[{"name":"CS61B","slug":"CS61B","permalink":"https://primeluoqiu.github.io/categories/CS61B/"}]},{"title":"Hello World","slug":"Lecture2-Defining and Using Classes 类的定义和实例化","date":"2024-03-20T14:21:05.833Z","updated":"2024-03-20T14:24:19.350Z","comments":true,"path":"2024/03/20/Lecture2-Defining and Using Classes 类的定义和实例化/","link":"","permalink":"https://primeluoqiu.github.io/2024/03/20/Lecture2-Defining%20and%20Using%20Classes%20%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E5%AE%9E%E4%BE%8B%E5%8C%96/","excerpt":"","text":"Class 2Video a:Defining and Instantiating Classes. 想要实际运行一个类，那么我们必须有main方法 假设我们目前创建了一个名为”Dog”的新类，并先暂时取消掉它的main方法。相反，我们给它一个方法，让它发出噪音。 12345public class Dog&#123; public static void makeNoise() &#123; System.out.println(&quot;Bark!&quot;); &#125;&#125; 那么，这个类就是可以编译的，那么当要运行这个程序的时候，就会报错![[Pasted image 20240106163816.png]]也就意味着这只狗不知道应该如何跑(run)对于Python来讲就是 12def makeNoise: print(&quot;Bark!&quot;) 没有任何调用makeNoise的地方于是我们放回main函数 12345678public class Dog&#123; public static void makeNoises() &#123; System.out.println(&quot;Bark!&quot;); &#125; public static void main(String args[]) &#123; makeNoises(); &#125;&#125; 于是，在我们重新编译运行之后我们看到![[Pasted image 20240106164240.png]]通常情况下，我们用Java创建的类没有main方法，就像狗这个类中一开始并没有main方法，相反，我们经常会有其他的类来使用Dog，因此我们创建一个DogLauncher.java 1234567/**The DogLauncher class will &#x27;test drive&#x27; the Dog class ,所以这只是为了展示这个‘狗’是如何工作的**/ //因此在这种情况下，DogLaunch应该有main方法 public class DogLaunch &#123; public static void main(String args[]) &#123; //在这里调用我们的狗类的制造噪音的方法 Dog.makeNoises();//这里的意思就是，告诉Java，我想让你去找狗这个类，然后找到它的对应的制造噪音的方法。 &#125; &#125; ![[Pasted image 20240106165927.png]]编译运行之后就是这个结果了 那么DogLaunch到底是做了什么呢？当它开始运行的时候，它会进入Dog类，然后采用makeNoise这个函数。那么这就是定义类的核心 DogAs we saw last time: Every method(a.k.a Function)is associated with some class. To run a class, we must define a main method. Not all classes have a main method.这里有一个main方法可以调用到其他类中的方法。一个类可以使用另一个类，这是我们能够将问题分解为更小的部分的全部基础。当然，很显然的是，在现实生活中，并不是所有的狗都是相同的。也就意味着，我们并不希望它们都发出相同的叫声，那么我们应该如何才能实现这个目标呢？ 有一个不那么好的方式是：(对于每只狗都创建一个新的类)We could create a separate class for every single dog out there, but this is going to get redundant in a hurry. 1234567891011public class MayaTheDog &#123; public static void makeNoise() &#123; System.out.println(&quot;arooooooooooooooo!&quot;); &#125;&#125;public class YapsterTheDog&#123; public static void makeNoise() &#123; System.out.println(&quot;awawwaawaw wawawawa&quot;); &#125;&#125; 虽然可以这么做，不过在品类多样之后，这显然变得很烦 Video b:Defining and Instantianing Classes那么，我们将使用的关键语言功能是，Java中的类不仅可以包含函数，当然还可以包含数据，以便更自然的表示狗或者其他的任何东西。那么我们就可以通过增强Dog类，以便让Dog拥有属性，例如大小。而这个Class将会成为其他dog的模板，然后我们可以将这个实例化为我们可以操作的特定对象 Object InstantiationClasses can contain not just functions(a.k.a methods), but also data. Classes can be instantiated as objects. We’ll create a single Dog class, and then create instances of this Dog. The classes provides a blueprint that all Dog objects will follow.重写dog class例子如下123456789101112131415public class Dog&#123; //狗不只是只有制造噪音，还有一些属性将是狗所拥有的，例如重量 public int weightInPounds; //然后更改下面的函数 public static void makeNoises() &#123; if(weightInPounds &lt; 10) &#123; System.out.println(&quot;yip!&quot;); &#125; else if (weightInPounds &lt; 30) &#123; System.out.println(&quot;bark!&quot;); &#125; else &#123; System.out.println(&quot;wooooof!&quot;); &#125; &#125; &#125; 当我们在编译这个程序的时候，会发现报这样的错误![[Pasted image 20240106192022.png]]对于我们来说，最快的解决方式就是删掉方法当中的static即可，现在再尝试编译的话就可以通过了。123456789101112131415public class Dog&#123; //狗不只是只有制造噪音，还有一些属性将是狗所拥有的，例如重量 public int weightInPounds; //然后更改下面的函数 public void makeNoises() &#123; if(weightInPounds &lt; 10) &#123; System.out.println(&quot;yip!&quot;); &#125; else if (weightInPounds &lt; 30) &#123; System.out.println(&quot;bark!&quot;); &#125; else &#123; System.out.println(&quot;wooooof!&quot;); &#125; &#125; &#125; 以上就是对Dog的一个模板，它可以根据狗的体重（磅数）有不同的行为。这个时候我们再DogLaunch编译一下，我们会发现![[Pasted image 20240106192733.png]]或许你也会想像上面的报错一样只删掉DogLaunch中的static，但是显然这是错误的，这个时候我们就要用到一个新语法。1Dog d = new Dog(); 这意味着创建一个狗，一只新狗，在这种情况下，我们称那只狗为d，那么接下来的语法将会是这样的123456789/**The DogLauncher class will &#x27;test drive&#x27; the Dog class ,所以这只是为了展示这个‘狗’是如何工作的**/ //因此在这种情况下，DogLaunch应该有main方法 public class DogLaunch &#123; public static void main(String args[]) &#123; //在这里调用我们的狗类的制造噪音的方法 Dog d = new Dog(); d.weightInPounds = 25; d.makeNoises(); &#125;&#125; 就是相当于，在这里我们来问d，让他发出声音，这个时候它去找makeNoise这个方法，然后这里只有三种声音，然后就会有这样的执行结果![[Pasted image 20240106194134.png]]如果我们将25换成51的话并重新编译的话，我们就会得到woof还有最后一点调整可能会有另外的一种想法，例如为什么不在构造这个d的时候直接在后面的()当中赋值呢？就是给定它作为Dog创建过程的参数。为了实现这个呢（当然，直接这么做是不可以的）![[Pasted image 20240106194511.png]]也就是意味着它并不知道应该如何处理这个数字。因此，为了处理这个问题，我们需要在Dog这个类中创建一个特殊的东西，它有点像方法，被称为构造函数1234// One integer constructor for dogs. public Dog(int w) &#123; &#125; 因此，当调用new Dog并给出一个整数的时候，就会调用这个构造函数，这将指定Dog是如何创建的 接下来，我们对这个构造函数里的WeightPounds设置为w 1234// One integer constructor for dogs. public Dog(int w) &#123; weightPounds = w;&#125; 接下来再编译运行的话，就可以直接得到Wooof了![[Pasted image 20240106195124.png]] Video c:Terminology在进行下一步之前，我们首先要搞清楚Java的一些相关术语 123456789101112131415public class Dog&#123; public int weightInPounds; public Dog(int startingWeight) &#123; weightPounds = startingWeight; &#125; public void makeNoise() &#123; if(weightInPounds &lt; 10) &#123; System.out.println(&quot;yipyipyip&quot;); &#125; else if (weightInPounds &lt; 30) &#123; System.out.println(&quot;bark, bark.&quot;); &#125; else &#123; System.out.println(&quot;woof&quot;)&#125; &#125;&#125; 这是一个例子，我们从中来剖析一些术语。 1public int weightInPounds; Instance variable. Can have as many of these as you want.一个实例变量，是一个跟踪当前类的特定实例的属性的变量，我们在这里定义了一个狗的体重，但是原则上我们还可以有它的身高，喜欢的食物，喜欢的颜色等等 123public Dog(int startingWeight) &#123; weightPounds = startingWeight;&#125; Constructor(similar to a method, but not a method). Determines how to instantiate the class.这里是构造函数：我们目前只有一个参数来设置单个实例变量，不过在原则上，可以在构造函数中执行任何操作，但通常最重要的事情之一是设置所有实例变量，不过也不必设置所有的实例变量，可以让他们保持默认值。构造函数告诉我们如何构造对象的实例。 123456789public void makeNoise() &#123; if(weightInPounds &lt; 10) &#123; System.out.println(&quot;yipyipyip&quot;); &#125; else if (weightInPounds &lt; 30) &#123; System.out.println(&quot;bark, bark.&quot;); &#125; else &#123; System.out.println(&quot;woof&quot;)&#125; &#125;&#125; Non-static method, a.k.a Instance Method.Idea: If the method is going to be invoked by an instance of the class(as in the next slide), then it should be non-static. Roughly speaking: If the method needs to use “my instance variables”, the method must be non-static. 非静态方法（实例方法）：也就是由特定实例调用的方法。例如我们有一个叫做Steven的狗 ，它在Steve变量中，那么当我们告诉Steve，Steve.MakeNoise的时候，它就会使用它的体重来决定它要做什么（怎么叫）。当我们阅读方法的时候，可以说，如果我们的体重小于10，那么yipyipyip，这意味着他是一个非静态的方法，事实上，如果这个方法需要使用任何实例变量，那么在定义的时候加入static关键字就会令Java感到困惑，会提示我们不能从静态上下文访问实例变量。 再来点术语 Instantiating a Class and Terminology12345678910public class DogLauncher &#123; public static void main (String[] args) &#123; Dog smallDog; new Dog(20); smallDog = new Dog(5); Dog hugeDog = new Dog(150); smallDog.makeNoise(); hugeDog.makeNoise(); &#125;&#125; 我们最开始的DogLauncher实现的功能很简单，只是让它发出了一下声音。但是我们可能会遇到更复杂的情况（如上） 1Dog smallDog; Declaration of a Dog variable.声明了一个Dog型的变量，有一个Dog变量叫做smallDog，不过我们目前还没创造出任何种类的狗，也就是没有实例化。 1new Dog(20); Instantiation of the Dog class as a Dog Object.这会创建一条尺寸为20的Dog，但是不会将它放置在任何地方，在这种情况下，因为没有人使用它，它只会被所谓的垃圾收集器给销毁掉。、意味着，如果实例化Dog，他们将被某种无情的垃圾收集器销毁 1smallDog = new Dog(5); Instantiation and Assignment.现在呢，如果想要避免失去这条狗，我们会想把它放在某个地方，所以上述代码实例化了一只狗，然后将其分配给一个已经声明的变量。那么这就是实例化和赋值。尽管通常情况下，我们要做的就是同时完成这三项工作。 1Dog hugeDog = new Dog(150); Declaration, Instantiation and Assignment.声明有一个名为HugeDog的变量，我们实例化它，然后将new Dog分配给这个变量 1hugeDog.makeNoise(); Invocation of the 150lb Dog’s makeNoise method.The dot notation means that we want to use a method or variable belonging to hugeDog,or more succinctly, a member of hugeDog.在这里有一些调用，在这里，我们想要HugeDog调用makeNoise方法。可以将这个.视为其成员的意思，所以它属于hugeDog这类。 Video d:Arrays of ObjectsTo create an array of objects: First use the new keyword to create the array. Then use new again for each object that you want to put in the array.Example:1234Dog[] dogs = new Dog[2]; //Create an array of Dogs of size 2.dogs[0] = new Dog(8);dogs[1] = new Dog(20);dogs[0].makeNoise(); //Yipping occurs After code runs![[Pasted image 20240107170741.png]]在项目0中，不仅要创建对象，还要创建对象数组。那么，如果想要创建一个对象数组而不是整数数组，那么就要以两种不同的方式使用new，首先要使用new来创建一个实际的数组。此时还没有创建任何Dog，可以把这个操作想象成建造了目前空着的狗屋，然后后面才会说，在狗屋0中放一只小狗，在狗屋1中放一只中型狗。这样在最后就可以看见两个狗屋辣。 然后我们可以问，嘿，狗屋0里的那个，发出声音，然后它就会YipYipYip Class 3Video a:Static vs Instance Methods我们现在知道什么Key differences between static and non-static (a.k.a instance) methods: Static methods are invoke using the class name, e.g. Dog.makeNoise(); Instance methods are invoked using an instance name, e.g. maya.makeNoise(); Static methods can’t access “my” instance variables, because there is no “me”.Static123public static void makeNoise() &#123; System.out.println(&quot;Bark!&quot;);&#125; This method cannot access weightlnPound.Invocation:Dog.makeNoise();目前我们知道存在静态方法（在声明中包含静态一词）和非静态方法（也被称为实例方法），他们没有静态方法。因此静态方法是使用类名调用的。所以当我们想要调用的时候，就要选择上述的方式Non-static123456789public void makeNoise() &#123; if(weightInPounds &lt; 10) &#123; System.out.println(&quot;yipyipyip&quot;); &#125; else if (weightInPounds &lt; 30) &#123; System.out.println(&quot;bark, bark.&quot;); &#125; else &#123; System.out.println(&quot;woof&quot;); &#125;&#125; Invocation:maya = newDog(100); maya.makeNoise();而这种即时方法，是使用实例名称调用的。所以创建了一个特定的Dog并说发出声音 他们之间的重要区别是 静态方法不能访问实例变量，就是对于静态而言，不能用System.out.println(&quot;makeNoise()&quot;);这样，传入不了实际的变量。而对于非静态方法的话，就是创建出来了一个新的狗并赋予了实际变量，然后就可以通过调用函数输出特定的声音。 虽然非静态方法非常的强势，但是静态方法也有它的用武之地，例如某些类从来没有被实例化，例如数学类，我们通常会这么做： 1x = Math.round(5.6); 这明显要比 12Math m = new Math();x = m.round(); 看来要好很多也就是说，静态方法自然有他们用起来更自然的地方。 现在，有时类实际上也可以混合使用，可以拥有一个即是静态方法又是非静态方法的类看实例假设我们现在要对Dog实现一个方法能够比较两只狗。所以这个时候需要制作另一只狗，需要在DogLauncher中 1Dog d2 = new Dog(100); 然后例如我们要实现比大小，例如比较 1Dog bigger = Dog.maxDog(d, d2); 这个时候我们想要用一个比较公平的裁判来解决这个问题。那么，我们在Dog中解决这个方法 12345public static Dog maxDog(Dog d1, Dog d2)&#123; //不要忘记加返回类型和静态哦（因为是用类名调用该方法 if(d1.weightInPounds &gt; d2.weightInPounds) return d1; return d2; &#125; 试验一下![[Pasted image 20240110091345.png]]显然这并没有输出，那么需要加上一句让大狗发出声音的语句 1bigger.makeNoise(); ![[Pasted image 20240110091642.png]] 那么可以用非静态方法解决这个问题吗？当然是可以的 123456789public class DogLaunch &#123; public static void main(String args[]) &#123; Dog d = new Dog(15); Dog d2 = new Dog(100); Dog bigger = d.maxDog(d2); bigger.makeNoise(); &#125;&#125; 12345678910111213141516171819202122232425262728public class Dog&#123; public int weightInPounds; public Dog(int w) &#123; weightInPounds = w; &#125; public void makeNoise() &#123; if(weightInPounds &lt; 10) &#123; System.out.println(&quot;yip!&quot;); &#125; else if (weightInPounds &lt; 30) &#123; System.out.println(&quot;bark!&quot;); &#125; else &#123; System.out.println(&quot;wooooof!&quot;); &#125; &#125; public static Dog maxDog(Dog d1, Dog d2)&#123; if(d1.weightInPounds &gt; d2.weightInPounds) return d1; return d2; &#125; public Dog maxDog(Dog d2) &#123; if(weightInPounds &gt; d2.weightInPounds) return this; return d2; &#125;&#125; ![[Pasted image 20240110092342.png]]编译之后依旧得到woooof！在这种情况下，这只狗会自己进行判断自己的体重和另一只狗的体重哪个重。上述是两种方法，一种是加入评委，一种是自己判断大小 作为一个快速说明，我们也可以定义静态变量。他们是适用于所有狗的属性，所有狗共享这个属性，例如我们给这些狗添加一个种类 1public static String binomen = &quot;Canis familiar&quot;; 12System.out.println(d.binomen);System.out.println(d2.binomen); ![[Pasted image 20240110093004.png]]但是对于上述的d1和d2并不是一种很有效的方式。例如我并不会问嘿那条狗，你的学名是什么，而应该是问，这些狗的学名是什么。上述方式相对来说会令人比较困惑。所以，如果我们有一个静态变量的话，那么就使用类名作为一种好一些方式来确保我们知道我们正在处理什么。 1System.out.println(Dog.binomen); Some knowledgepoint Static vs. Non-staticA class may have a mix of static and non-static members. A variable or method defined in a class is also called a member of that class. Static members are accessed using class name, e.g. Dog.binomen. Non-static members cannot be invoked using class name:Dog.makeNoise() Static method must access instance variables via a specfic instance e.g. d1. Video b:ExerciseQuestion:Will this program compile? If so, what will it print? 123456789101112131415161718public class DogLoop &#123; public static void main(String args[]) &#123; Dog smallDog = new Dog(5); Dog mediumDog = new Dog(25); Dog hugeDog = new Dog(150); Dog[] manyDogs = new Dog[4]; manyDogs[0] = smallDog; manyDogs[1] = hugeDog; manyDogs[2] = new Dog(130); int i = 0; while(i &lt; manyDogs.length) &#123; Dog.maxDog(manyDogs[i], mediumDog).makeNoise(); i = i + 1; &#125; &#125;&#125; Video c:Exercise Solution在这个网站当中可以将每一步可视化，建议点入之后操作[http://goo.gl/HLzN6s]，认真查看问题所在和结果，答案是 12345bark!woof!woof!Error:... Class 4Video a:Managing Complexity, LargerThanFourNeighborsManaging Complexity with Classes and Static MethodsSome obvious questions arise: Why does Java force us to use classes? Why have static methods at all? The Reason: Fewer choices means fewer ways to do things. Example：Declaring a method static means you can’t use any instance variables in that method. Fewer ways to do things often means less complexity 更少的选择意味着做事的方法更少，如果将一个方法设置为静态，就会对可能得情况施加限制。例如不能使用实例变量。从根本来说，就是降低代码的复杂性 Goal: largerThanFourNeighbors Suppose we want to write a method: 1public static Dog[] largerThanFourNeighbors(Dog[] dogs) This method will return a new array that contains every Dog that is larger than its 4 closest neighbors, i.e. the two on the left and the two in the right.If there are not enough neighbors, i.e. you ‘re at the end of the array, then consider just the neighbrs that exist.For example: input:Dog with size [ 10, 20, 30, 25, 20, 40, 10 ] Returns: Dog with size[ 30, 40]. 30 is the larger than 10,20,25 and 20. 40 is greater than 25, 20, and 10 If input Dog sizes are[10, 15, 20, 15, 10, 5, 10, 15, 22, 20],what will be the size of the Dogs returned？ It Will be [20, 22] Video b:LargerThanFourNeighbors With No Helper Methods在不考虑策略的情况下暂时完成code:打开Intellij 123456789101112131415161718192021222324252627public class DogProblem &#123; public staitc Dog[] largerThanFourNeighbors(Dog[] dogs) &#123; return dogs; &#125; public static void main(String args[]) &#123; Dog[] dogs = new Dog[] &#123; new Dog(10), new Dog(15), new Dog(20), new Dog(15), new Dog(10), new Dog(5), new Dog(10), new Dog(15), new Dog(22), new Dog(15), new Dog(20) &#125;; Dog[] bigDogs1 = largerThanFourNeighbors(dogs); for(int k = 0; k &lt; bigDogs1.length; k ++)&#123; System.out.print(bigDogs1[k].weightInPounds + &quot; &quot;); &#125; System.out.println();; &#125;&#125; 先键入这些基础的输入输出语句，我们的函数目前只能返回dogs。所以首先我们看向我们的larger函数，那么我们首先要做的只能是迭代所有的狗，这看起来很自然，不过棘手的问题是如何迭代邻居们。一个想法是：如果我们从-2到2，那么这应该是迭代狗的邻居。 12345for(int i = 0; i &lt; dogs.length; i ++)&#123; for(int j = -2; j &lt;= 2;j ++)&#123; Dog neighborDog = dogs[i + j] &#125;;&#125; 接下来就要处理边界的一些问题，例如我们如果从0开始的话，那么i + j最开始是-2，很明显是数组越界的行为，还有如果j到了数组的最右边，同样也会存在数组越界的问题。 1234567891011121314public staitc Dog[] largerThanFourNeighbors(Dog[] dogs) &#123; for(int i = 0; i &lt; dogs.length; i ++)&#123; for(int j = -2; j &lt;= 2;j ++)&#123; if(i + j &lt; 0) &#123; continue; &#125; if(i + j &gt;= dogs.length) &#123; break; &#125; Dog neighborDog = dogs[i + j]; &#125;; &#125;&#125; 那么有了这只邻居狗之后，我们应该如何做呢？定义一个布尔值，默认是正确的，来定义默认情况下我们本身就是最大的狗，但如果邻居狗的体重大于或者等于当前狗的体重，那么最大就是假的，那么有一个重要的事实是，在边界问题上，如果j&#x3D;0，那么就会将自己和自己进行比较，那么显然是没必要的，那么代码如下 123456789101112131415161718192021public staitc Dog[] largerThanFourNeighbors(Dog[] dogs) &#123; for(int i = 0; i &lt; dogs.length; i ++)&#123; boolean largest = true; for(int j = -2; j &lt;= 2;j ++)&#123; if(i + j &lt; 0) &#123; continue; &#125; if(i + j &gt;= dogs.length) &#123; break; &#125; if(j == 0) &#123; continue; &#125; Dog neighborDog = dogs[i + j]; if(neighborDog.weightInPounds &gt;= dogs[i].weightInPounds) &#123; largest = false; &#125; &#125;; &#125;&#125; 这只是考虑，但是发现有一些复杂 Video c:LargeThanFourNeighbors With Helper MethodsOpen Intellij接下来我们使用一些辅助方法来编写代码，辅助方法的好处是让我们在编辑他们之前先使用他们。那么最初的框架就是 1234567891011public static Dog[] largerThanFourNeighbors(Dog[] dogs) &#123; for(int i = 0; i &lt; dogs.length; i ++)&#123; if(isBiggestOfFour(dogs, i)) &#123; &#125; &#125;&#125;//先拆出来一个问题：是不是邻居四个当中的一个/* Return true if dogs[i] is larger than its four neighbors */public static boolean isBiggestFour(Dog[] dogs, int i) &#123;&#125; 拆出问题之后，我们来继续完成主函数因为主函数最后返回的值是一个Dog类型的数组，那么，我们就要定义一个返回数组和要返回的数组的大小 12345public static Dog[] largerThanFourNeighbors(Dog[] dogs) &#123; Dog[] returnDogs = new Dog[dogs.length]; int cnt = 0; ...//内容同上&#125; 然后我们对如果这个狗是它的四个邻居当中最大的，那么我们将答案传递给我们最后要返回的那个Dog组，然后完成主函数return returnDogs; 1234567891011public static Dog[] largerThanFourNeighbors(Dog[] dogs) &#123; Dog[] returnDogs = new Dog[dogs.length]; int cnt = 0; for(int i = 0; i &lt; dogs.length; i ++)&#123; if(isBiggestOfFour(dogs, i)) &#123; returnDogs[cnt] = dogs[i]; cnt ++; //这样有利于我们进行统计 &#125; &#125; return returnDogs;&#125; 这段代码正确的叙述了读取它，得到返回值。我们通过i小于等于数组的长度来遍历这一整个大的数组。如果是四个当中最大的，那么我们将它添加到这个新的数组当中并返回它。我们现在回到第二个函数，因为对于主函数我们已经不用考虑它了，接下来我们只需要考虑给出是或否的答案就可以了。 123456boolean isBiggest = true; for(int j = -2; j &lt;= 2;j ++) &#123; &#125; &#125; 我们依旧默认最大值为真。在前面的实例中，我们使用了一堆if语句，当然，在这里，我们还是可以选择用辅助方法来解决这个问题 1234567public static boolean validIndex(Dog[] dogs, int i) &#123; if(i &lt; 0) return false; if(i &gt;= dogs.length) return false; return true; &#125; 在我们实现完这个函数之后，我们回头看调用它的那个方法，对于方法来讲，我们只需要完成比较的那一部分即可 1234567891011121314public static boolean isBiggestOfFour(Dog[] dogs,int i) &#123; boolean isBiggest = true; for(int j = -2; j &lt;= 2;j ++) &#123; int comparedIndex = i + j; if(validIndex(dogs, comparedIndex)) &#123; if(dogs[comparedIndex].weightInPounds &gt;= dogs[i].weightInPounds) &#123; isBiggest = false; &#125; &#125; &#125; return isBiggest; &#125; 但是在完成这项之后，我们发现我们似乎遗漏掉了对自己和自己进行比较的情况 1234567891011121314151617public static boolean isBiggestOfFour(Dog[] dogs,int i) &#123; boolean isBiggest = true; for(int j = -2; j &lt;= 2;j ++) &#123; int comparedIndex = i + j; //只是命名来方便叙述 if(validIndex(dogs, comparedIndex)) &#123; // avoid comparing ourself to ourself. if(j == 0) &#123; continue; &#125; if(dogs[comparedIndex].weightInPounds &gt;= dogs[i].weightInPounds) &#123; isBiggest = false; &#125; &#125; &#125; return isBiggest; &#125; 这样即可尝试找出如何让程序更加漂亮。整个程序如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package Lecture2; public class DogProblem &#123; public static Dog[] largerThanFourNeighbors(Dog[] dogs) &#123; Dog[] returnDogs = new Dog[dogs.length]; int cnt = 0; for(int i = 0;i &lt; dogs.length;i ++) &#123; if(isBiggestOfFour(dogs, i)) &#123; returnDogs[cnt] = dogs[i]; cnt ++; &#125; &#125; return returnDogs; &#125; /* Return true if dogs[i] is larger than its four neighbors */ public static boolean isBiggestOfFour(Dog[] dogs,int i) &#123; boolean isBiggest = true; for(int j = -2; j &lt;= 2;j ++) &#123; int comparedIndex = i + j; //只是命名来方便叙述 if(validIndex(dogs, comparedIndex)) &#123; // avoid comparing ourself to ourself. if(j == 0) &#123; continue; &#125; if(dogs[comparedIndex].weightInPounds &gt;= dogs[i].weightInPounds) &#123; isBiggest = false; &#125; &#125; &#125; return isBiggest; &#125; public static boolean validIndex(Dog[] dogs, int i) &#123; if(i &lt; 0) return false; if(i &gt;= dogs.length) return false; return true; &#125; public static void main(String args[]) &#123; Dog[] dogs = new Dog[] &#123; new Dog(10), new Dog(15), new Dog(20), new Dog(15), new Dog(10), new Dog(5), new Dog(10), new Dog(15), new Dog(22), new Dog(15), new Dog(20) &#125;; Dog[] bigDogs1 = largerThanFourNeighbors(dogs); for(int k = 0; k &lt; bigDogs1.length; k ++)&#123; System.out.print(bigDogs1[k].weightInPounds + &quot; &quot;); &#125; System.out.println(); &#125; &#125; ![[Pasted image 20240113142014.png]]我们得到了20和22，这是正确的结果，但是为什么后面还有一串错误信息呢，是因为在答案数组的最后有很多空值，其实这个并没有什么问题，只是会输出这样的信息。我们可以选择用一个方法来消除这个错误 12345678//cnt is the number of non-null items public static Dog[] arrayWithNoNulls(Dog[] dogs, int cnt) &#123; Dog[] noNullDogs = new Dog[cnt]; for(int i = 0; i &lt; cnt; i ++) &#123; noNullDogs[i] = dogs[i]; &#125; return noNullDogs; &#125; 最终代码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package Lecture2; public class DogProblem &#123; public static Dog[] largerThanFourNeighbors(Dog[] dogs) &#123; Dog[] returnDogs = new Dog[dogs.length]; int cnt = 0; for(int i = 0;i &lt; dogs.length;i ++) &#123; if(isBiggestOfFour(dogs, i)) &#123; returnDogs[cnt] = dogs[i]; cnt ++; &#125; &#125; returnDogs = arrayWithNoNulls(dogs, cnt); return returnDogs; &#125; //cnt is the number of non-null items public static Dog[] arrayWithNoNulls(Dog[] dogs, int cnt) &#123; Dog[] noNullDogs = new Dog[cnt]; for(int i = 0; i &lt; cnt; i ++) &#123; noNullDogs[i] = dogs[i]; &#125; return noNullDogs; &#125; /* Return true if dogs[i] is larger than its four neighbors */ public static boolean isBiggestOfFour(Dog[] dogs,int i) &#123; boolean isBiggest = true; for(int j = -2; j &lt;= 2;j ++) &#123; int comparedIndex = i + j; //只是命名来方便叙述 if(validIndex(dogs, comparedIndex)) &#123; // avoid comparing ourself to ourself. if(j == 0) &#123; continue; &#125; if(dogs[comparedIndex].weightInPounds &gt;= dogs[i].weightInPounds) &#123; isBiggest = false; &#125; &#125; &#125; return isBiggest; &#125; public static boolean validIndex(Dog[] dogs, int i) &#123; if(i &lt; 0) return false; if(i &gt;= dogs.length) return false; return true; &#125; public static void main(String args[]) &#123; Dog[] dogs = new Dog[] &#123; new Dog(10), new Dog(15), new Dog(20), new Dog(15), new Dog(10), new Dog(5), new Dog(10), new Dog(15), new Dog(22), new Dog(15), new Dog(20) &#125;; Dog[] bigDogs1 = largerThanFourNeighbors(dogs); for(int k = 0; k &lt; bigDogs1.length; k ++)&#123; System.out.print(bigDogs1[k].weightInPounds + &quot; &quot;); &#125; System.out.println(); &#125; &#125; ![[Pasted image 20240113143928.png]]这段代码包含很多东西首先叙述性更好其次编写时更容易正确执行再次如果遇到到麻烦，则更容易调试 用好辅助方法，会事半功倍","categories":[{"name":"CS61B","slug":"CS61B","permalink":"https://primeluoqiu.github.io/categories/CS61B/"}],"tags":[],"keywords":[{"name":"CS61B","slug":"CS61B","permalink":"https://primeluoqiu.github.io/categories/CS61B/"}]},{"title":"Hello World","slug":"Lecture1-Introduction","date":"2024-03-20T14:21:05.826Z","updated":"2024-03-20T14:24:17.895Z","comments":true,"path":"2024/03/20/Lecture1-Introduction/","link":"","permalink":"https://primeluoqiu.github.io/2024/03/20/Lecture1-Introduction/","excerpt":"","text":"多做事来获得能力是很重要的 Class 1:Hello World 课程链接：[[https://www.youtube.com/watch?v=E3noTK6T8AE&amp;list=PLnp31xXvnfRq5wRDN8wZFy7GrrJXUtr1q&amp;index=4]] Java 和Python的对比Java 是一种认为类非常重要的语言，事实上呢，所有的代码都必须在类中。它是一种迫使我们面向对象的语言，那么因此定义这个类的话。我们首先要做的是定义一个公共类Hello World.可以认为public class就像另一种语言中的类定义一样 123public class HelloWorld&#123;&#125; 这个时候，我们会发现报错是在类HelloWorld中找不到main方法，即报错信息中会显示the main method as: public static void main(String[] args)，然后我们复制这段代码之后 12345public class HelloWorld&#123; public static void main(String[] args) &#123; &#125;&#125; 我们会发现这段代码可以工作了那么从中我们可以总结出来有关Java这个语言什么样子的特性呢？ In java, all code must be part a class Classes are defined with “public class CLASSNAME” We use { } to delineate the begining and ending of things. We must end lines with a semicolon. The code we want to run must be inside public static void main(String[] args). Class 2:Static Typing 课程链接：[[https://www.youtube.com/watch?v=xX04gYy9en0&amp;list=PLnp31xXvnfRq5wRDN8wZFy7GrrJXUtr1q&amp;index=5]] 一个例题：在Python中和Java中输出从0-9这十个数。Python只是为了用来对比 1234x = 0while x &lt; 10 print(x) x ++ Java： 123456789public class HelloNumbers&#123; public static void main(String[] args) &#123; x = 0; while(x &lt; 10)&#123; System.out.println(x);//ln指line x = x + 1; &#125;; &#125;&#125; 在看了Python的语言之后，你似乎也想在Java中如是这么写，但是很显然，这个在Java的编译中是错误的。(Error:cannot find symbol x),实际上，编译器只是想要提醒我们需要声明变量，也就意味着，在使用这个变量之前，要先声明它存在。所以，正确的应该是 123456789public class HelloNumbers&#123; public static void main(String[] args) &#123; int x = 0; while(x &lt; 10)&#123; System.out.println(x);//ln指line x = x + 1; &#125;; &#125;&#125; 对于Java和Python在变量的方面存在一些很大的差异，使用Python这种非所谓静态类型语言的语言，可以随机创建变量。而在Java中，变量有特定的类型，这些类型永远不会改变。Java会在运行这个程序之前先检验一遍变量的类型是不是正确。接下来是一段总结 Before Java variables can be used, they must be declared. Java variables must have a specific type. Java variables types can never change. 对于现在来讲，类型的错误不仅仅只会存在于Java中，在Python中，如果我们进行这样的语句的时候 1print(&quot;horse&quot; + 5) 我们就会看到出现错误，而且是建立在之前程序都进行输出了的情况下，指在本节最开始的地方添加了这么一句话，那么久就会发现程序是先输出了0123456789之后才输出了报错信息。但是对于Java来说，当我们尝试运行存在类型错误的代码时，我们在此之前并不会得到任何输出，而是给予了我们一大堆的错误信息，由此我们可以得到Java的第四条特性4. Types are varified before the code even runs !!!在这里，这段代码基本上在运行之前就获得了类型正确的证书，这意味着(静态类型的三个优点) 最终用户遇到的错误会更少 使我们更容易调试 当我们使用代码的时候，我们应该知道一切应该是什么，例如x应该始终是整数 Class 3: Declaring Functions接下来是有关定义函数的内容 还是先以一个Python程序来作为示例 12345def large(x, y): if(x &gt; y): return x return yprint(large(-5, 10)) 我们最终可以得到10，那么Java版本长什么样子呢？(我们给这个Java文件命名为LargeDemo) 12345678//如果我们想要定义一个函数，我们不能把它放到这里public class LargeDemo&#123;//所以实际上应该在这里进行函数定义 public static void main(String[] args) &#123; &#125;&#125; 我们要记住，在Java中，所有代码都必须是类的一部分，而在Java中使用特殊短语public static而不是def。那么这个函数目前看起来应该这么写 12345678910public class LargeDemo&#123; public static large(x, y)&#123; if(x &gt; y) return x; return y; &#125; public static void main(String[] args) &#123; &#125;&#125; 现在，如果尝试对其进行编译，它会给我们提醒说需要告诉他x是什么，y是什么，而且还要说返回的值是一个什么类型的值。接下来的函数应该是长这个样子的。最后，我们想要在主函数当中调用这个函数的话，就应该用 12345678910public class LargeDemo&#123;public static int large(x, y) &#123; if(x &gt; y) return x; return y;&#125; public static void main(String[] args) &#123; System.out.println(large(-5, 10)); &#125;&#125; 在这里有一些注意事项 Functions must be declared as a part of a class in Java.A function that is part of a class is called method.So, in Java, all functions are methods To define a function in Java, we use “public static”.We will see alternate ways of defining functions Later. All parameters of a function must have a declared type, and the return value of the function must have a declared type.那么因此，我们在定义函数的时候就不可以定义有两种返回值的函数，类似int String ...有一个重点是，我们完全可以不对函数的名字或者类的名字起名起的如此繁琐，我们完全可以用一个符号来代替一堆繁琐的字符，类似f(x, y)这样，但是我们最后选择以相对来说比较繁琐的方式来命名这个函数的原因是 使我们的代码看起来更加可读 还有一个建议是在编写函数的时候，我们可以选择在它的头顶添加一些字符让他看起来更加的可读，例如 12/*Returns the large of x and y.*/public static int large(x, y) &#123; 最后其实会发现，可读性方便的还是自己。 Class4.Reflection1.Java and Object OrientationJava is an object oriented language with strict declarations: Every Java file must contain a class declaration.* All code lives inside a class*, even helper functions,global constants, etc. To run a Java program, you typically define a main method using public static void main(String[] args) * This is not completely true, e.g. we can also declare “interface” in Java files that may contain code.We’ll cover these later. 2.Java and Static TypingJava is statically typed! All variables, parameters, and methods must have a declared type. That type can never change. Expressions also have a type. The compiler checks that all the types in your program are compatible before the program ever runs! This is unlike a language like Python, where type checks are performed DURING execution. 3.Reflections on Static TypingThe Good: Catches certain types of errors, making it easior on the programmer to debug their code. Type errors can(almost) never occur on the end user’s computer(Even their Android). Makes it easier to read about code. Code can run more effciently, e.g. no need to do expensive runtime type checks. The Bad: Code is more verbose. Code is less general. There is a way around this in Java.例如，还是之前的比较大小的函数，对于Python而言，我们可以对除了字符串之外的所有类型进行比大小的操作，而在Java中就必须要重新写类似于float类型的函数这样才可以进行大小的比较。","categories":[{"name":"CS61B","slug":"CS61B","permalink":"https://primeluoqiu.github.io/categories/CS61B/"}],"tags":[],"keywords":[{"name":"CS61B","slug":"CS61B","permalink":"https://primeluoqiu.github.io/categories/CS61B/"}]},{"title":"Something","slug":"something","date":"2024-03-18T05:32:52.633Z","updated":"2024-03-18T05:33:51.682Z","comments":true,"path":"2024/03/18/something/","link":"","permalink":"https://primeluoqiu.github.io/2024/03/18/something/","excerpt":"","text":"111","categories":[{"name":"CS61B","slug":"CS61B","permalink":"https://primeluoqiu.github.io/categories/CS61B/"}],"tags":[],"keywords":[{"name":"CS61B","slug":"CS61B","permalink":"https://primeluoqiu.github.io/categories/CS61B/"}]},{"title":"第三周计划表","slug":"第三周学习安排","date":"2024-03-18T02:51:18.471Z","updated":"2024-03-23T09:21:19.968Z","comments":true,"path":"2024/03/18/第三周学习安排/","link":"","permalink":"https://primeluoqiu.github.io/2024/03/18/%E7%AC%AC%E4%B8%89%E5%91%A8%E5%AD%A6%E4%B9%A0%E5%AE%89%E6%8E%92/","excerpt":"","text":"本周学习内容预计 郑铨《计算机网络》:看完1.7 CS61B: 7 - 10 CS61A: 看前两章 深入理解计算机系统 :第一章看完 CS61C：前两周内容 !!! 切记随时更新进度和笔记","categories":[{"name":"大二下","slug":"大二下","permalink":"https://primeluoqiu.github.io/categories/%E5%A4%A7%E4%BA%8C%E4%B8%8B/"}],"tags":[],"keywords":[{"name":"大二下","slug":"大二下","permalink":"https://primeluoqiu.github.io/categories/%E5%A4%A7%E4%BA%8C%E4%B8%8B/"}]},{"title":"Hello World","slug":"hello-world","date":"2024-03-17T04:15:53.462Z","updated":"2024-03-20T14:24:03.168Z","comments":true,"path":"2024/03/17/hello-world/","link":"","permalink":"https://primeluoqiu.github.io/2024/03/17/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Hello HexoCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"CS61A","slug":"CS61A","permalink":"https://primeluoqiu.github.io/categories/CS61A/"}],"tags":[],"keywords":[{"name":"CS61A","slug":"CS61A","permalink":"https://primeluoqiu.github.io/categories/CS61A/"}]}]}